---
source: duvet/src/ietf.rs
expression: "Tokenizer::new(&rfc8446).collect::<Vec<_>>()"

---
[
      BREAK#0,
      BREAK#1,
      BREAK#2,
      BREAK#3,
      BREAK#4,
      BREAK#5,
      BREAK#12,
      BREAK#13,
    CONTENT#14(        The Transport Layer Security (TLS) Protocol Version 1.3),
      BREAK#15,
      BREAK#17,
    CONTENT#18(   This document specifies version 1.3 of the Transport Layer Security),
    CONTENT#19(   (TLS) protocol.  TLS allows client/server applications to communicate),
    CONTENT#20(   over the Internet in a way that is designed to prevent eavesdropping,),
    CONTENT#21(   tampering, and message forgery.),
      BREAK#22,
    CONTENT#23(   This document updates RFCs 5705 and 6066, and obsoletes RFCs 5077,),
    CONTENT#24(   5246, and 6961.  This document also specifies new requirements for),
    CONTENT#25(   TLS 1.2 implementations.),
      BREAK#26,
      BREAK#28,
    CONTENT#29(   This is an Internet Standards Track document.),
      BREAK#30,
    CONTENT#31(   This document is a product of the Internet Engineering Task Force),
    CONTENT#32(   (IETF).  It represents the consensus of the IETF community.  It has),
    CONTENT#33(   received public review and has been approved for publication by the),
    CONTENT#34(   Internet Engineering Steering Group (IESG).  Further information on),
    CONTENT#35(   Internet Standards is available in Section 2 of RFC 7841.),
      BREAK#36,
    CONTENT#37(   Information about the current status of this document, any errata,),
    CONTENT#38(   and how to provide feedback on it may be obtained at),
    CONTENT#39(   https://www.rfc-editor.org/info/rfc8446.),
      BREAK#40,
      BREAK#41,
      BREAK#42,
      BREAK#43,
      BREAK#44,
      BREAK#45,
      BREAK#46,
      BREAK#47,
      BREAK#48,
      BREAK#49,
      BREAK#50,
      BREAK#51,
      BREAK#52,
      BREAK#53,
      BREAK#54,
      BREAK#55,
      BREAK#56,
      BREAK#58,
      BREAK#60,
      BREAK#61,
      BREAK#63,
    CONTENT#64(   Copyright (c) 2018 IETF Trust and the persons identified as the),
    CONTENT#65(   document authors.  All rights reserved.),
      BREAK#66,
    CONTENT#67(   This document is subject to BCP 78 and the IETF Trust's Legal),
    CONTENT#68(   Provisions Relating to IETF Documents),
    CONTENT#69(   (https://trustee.ietf.org/license-info) in effect on the date of),
    CONTENT#70(   publication of this document.  Please review these documents),
    CONTENT#71(   carefully, as they describe your rights and restrictions with respect),
    CONTENT#72(   to this document.  Code Components extracted from this document must),
    CONTENT#73(   include Simplified BSD License text as described in Section 4.e of),
    CONTENT#74(   the Trust Legal Provisions and are provided without warranty as),
    CONTENT#75(   described in the Simplified BSD License.),
      BREAK#76,
    CONTENT#77(   This document may contain material from IETF Documents or IETF),
    CONTENT#78(   Contributions published or made publicly available before November),
    CONTENT#79(   10, 2008.  The person(s) controlling the copyright in some of this),
    CONTENT#80(   material may not have granted the IETF Trust the right to allow),
    CONTENT#81(   modifications of such material outside the IETF Standards Process.),
    CONTENT#82(   Without obtaining an adequate license from the person(s) controlling),
    CONTENT#83(   the copyright in such materials, this document may not be modified),
    CONTENT#84(   outside the IETF Standards Process, and derivative works of it may),
    CONTENT#85(   not be created outside the IETF Standards Process, except to format),
    CONTENT#86(   it for publication as an RFC or to translate it into languages other),
    CONTENT#87(   than English.),
      BREAK#88,
      BREAK#89,
      BREAK#90,
      BREAK#91,
      BREAK#92,
      BREAK#93,
      BREAK#94,
      BREAK#95,
      BREAK#96,
      BREAK#97,
      BREAK#98,
      BREAK#99,
      BREAK#100,
      BREAK#101,
      BREAK#102,
      BREAK#103,
      BREAK#104,
      BREAK#105,
      BREAK#106,
      BREAK#107,
      BREAK#108,
      BREAK#109,
      BREAK#110,
      BREAK#111,
      BREAK#112,
      BREAK#114,
      BREAK#116,
      BREAK#117,
      BREAK#119,
    CONTENT#120(   1. Introduction ....................................................6),
    CONTENT#121(      1.1. Conventions and Terminology ................................7),
    CONTENT#122(      1.2. Major Differences from TLS 1.2 .............................8),
    CONTENT#123(      1.3. Updates Affecting TLS 1.2 ..................................9),
    CONTENT#124(   2. Protocol Overview ..............................................10),
    CONTENT#125(      2.1. Incorrect DHE Share .......................................14),
    CONTENT#126(      2.2. Resumption and Pre-Shared Key (PSK) .......................15),
    CONTENT#127(      2.3. 0-RTT Data ................................................17),
    CONTENT#128(   3. Presentation Language ..........................................19),
    CONTENT#129(      3.1. Basic Block Size ..........................................19),
    CONTENT#130(      3.2. Miscellaneous .............................................20),
    CONTENT#131(      3.3. Numbers ...................................................20),
    CONTENT#132(      3.4. Vectors ...................................................20),
    CONTENT#133(      3.5. Enumerateds ...............................................21),
    CONTENT#134(      3.6. Constructed Types .........................................22),
    CONTENT#135(      3.7. Constants .................................................23),
    CONTENT#136(      3.8. Variants ..................................................23),
    CONTENT#137(   4. Handshake Protocol .............................................24),
    CONTENT#138(      4.1. Key Exchange Messages .....................................25),
    CONTENT#139(           4.1.1. Cryptographic Negotiation ..........................26),
    CONTENT#140(           4.1.2. Client Hello .......................................27),
    CONTENT#141(           4.1.3. Server Hello .......................................31),
    CONTENT#142(           4.1.4. Hello Retry Request ................................33),
    CONTENT#143(      4.2. Extensions ................................................35),
    CONTENT#144(           4.2.1. Supported Versions .................................39),
    CONTENT#145(           4.2.2. Cookie .............................................40),
    CONTENT#146(           4.2.3. Signature Algorithms ...............................41),
    CONTENT#147(           4.2.4. Certificate Authorities ............................45),
    CONTENT#148(           4.2.5. OID Filters ........................................45),
    CONTENT#149(           4.2.6. Post-Handshake Client Authentication ...............47),
    CONTENT#150(           4.2.7. Supported Groups ...................................47),
    CONTENT#151(           4.2.8. Key Share ..........................................48),
    CONTENT#152(           4.2.9. Pre-Shared Key Exchange Modes ......................51),
    CONTENT#153(           4.2.10. Early Data Indication .............................52),
    CONTENT#154(           4.2.11. Pre-Shared Key Extension ..........................55),
    CONTENT#155(      4.3. Server Parameters .........................................59),
    CONTENT#156(           4.3.1. Encrypted Extensions ...............................60),
    CONTENT#157(           4.3.2. Certificate Request ................................60),
    CONTENT#158(      4.4. Authentication Messages ...................................61),
    CONTENT#159(           4.4.1. The Transcript Hash ................................63),
    CONTENT#160(           4.4.2. Certificate ........................................64),
    CONTENT#161(           4.4.3. Certificate Verify .................................69),
    CONTENT#162(           4.4.4. Finished ...........................................71),
    CONTENT#163(      4.5. End of Early Data .........................................72),
      BREAK#164,
      BREAK#165,
      BREAK#166,
      BREAK#167,
      BREAK#168,
      BREAK#170,
      BREAK#172,
      BREAK#173,
    CONTENT#174(      4.6. Post-Handshake Messages ...................................73),
    CONTENT#175(           4.6.1. New Session Ticket Message .........................73),
    CONTENT#176(           4.6.2. Post-Handshake Authentication ......................75),
    CONTENT#177(           4.6.3. Key and Initialization Vector Update ...............76),
    CONTENT#178(   5. Record Protocol ................................................77),
    CONTENT#179(      5.1. Record Layer ..............................................78),
    CONTENT#180(      5.2. Record Payload Protection .................................80),
    CONTENT#181(      5.3. Per-Record Nonce ..........................................82),
    CONTENT#182(      5.4. Record Padding ............................................83),
    CONTENT#183(      5.5. Limits on Key Usage .......................................84),
    CONTENT#184(   6. Alert Protocol .................................................85),
    CONTENT#185(      6.1. Closure Alerts ............................................87),
    CONTENT#186(      6.2. Error Alerts ..............................................88),
    CONTENT#187(   7. Cryptographic Computations .....................................90),
    CONTENT#188(      7.1. Key Schedule ..............................................91),
    CONTENT#189(      7.2. Updating Traffic Secrets ..................................94),
    CONTENT#190(      7.3. Traffic Key Calculation ...................................95),
    CONTENT#191(      7.4. (EC)DHE Shared Secret Calculation .........................95),
    CONTENT#192(           7.4.1. Finite Field Diffie-Hellman ........................95),
    CONTENT#193(           7.4.2. Elliptic Curve Diffie-Hellman ......................96),
    CONTENT#194(      7.5. Exporters .................................................97),
    CONTENT#195(   8. 0-RTT and Anti-Replay ..........................................98),
    CONTENT#196(      8.1. Single-Use Tickets ........................................99),
    CONTENT#197(      8.2. Client Hello Recording ....................................99),
    CONTENT#198(      8.3. Freshness Checks .........................................101),
    CONTENT#199(   9. Compliance Requirements .......................................102),
    CONTENT#200(      9.1. Mandatory-to-Implement Cipher Suites .....................102),
    CONTENT#201(      9.2. Mandatory-to-Implement Extensions ........................103),
    CONTENT#202(      9.3. Protocol Invariants ......................................104),
    CONTENT#203(   10. Security Considerations ......................................106),
    CONTENT#204(   11. IANA Considerations ..........................................106),
    CONTENT#205(   12. References ...................................................109),
    CONTENT#206(      12.1. Normative References ....................................109),
    CONTENT#207(      12.2. Informative References ..................................112),
    CONTENT#208(   Appendix A. State Machine ........................................120),
    CONTENT#209(     A.1. Client ....................................................120),
    CONTENT#210(     A.2. Server ....................................................121),
    CONTENT#211(   Appendix B. Protocol Data Structures and Constant Values .........122),
    CONTENT#212(     B.1. Record Layer ..............................................122),
    CONTENT#213(     B.2. Alert Messages ............................................123),
    CONTENT#214(     B.3. Handshake Protocol ........................................124),
    CONTENT#215(       B.3.1. Key Exchange Messages .................................125),
    CONTENT#216(       B.3.2. Server Parameters Messages ............................131),
    CONTENT#217(       B.3.3. Authentication Messages ...............................132),
    CONTENT#218(       B.3.4. Ticket Establishment ..................................132),
    CONTENT#219(       B.3.5. Updating Keys .........................................133),
    CONTENT#220(     B.4. Cipher Suites .............................................133),
      BREAK#221,
      BREAK#222,
      BREAK#223,
      BREAK#224,
      BREAK#226,
      BREAK#228,
      BREAK#229,
    CONTENT#230(   Appendix C. Implementation Notes .................................134),
    CONTENT#231(     C.1. Random Number Generation and Seeding ......................134),
    CONTENT#232(     C.2. Certificates and Authentication ...........................135),
    CONTENT#233(     C.3. Implementation Pitfalls ...................................135),
    CONTENT#234(     C.4. Client Tracking Prevention ................................137),
    CONTENT#235(     C.5. Unauthenticated Operation .................................137),
    CONTENT#236(   Appendix D. Backward Compatibility ...............................138),
    CONTENT#237(     D.1. Negotiating with an Older Server ..........................139),
    CONTENT#238(     D.2. Negotiating with an Older Client ..........................139),
    CONTENT#239(     D.3. 0-RTT Backward Compatibility ..............................140),
    CONTENT#240(     D.4. Middlebox Compatibility Mode ..............................140),
    CONTENT#241(     D.5. Security Restrictions Related to Backward Compatibility ...141),
    CONTENT#242(   Appendix E. Overview of Security Properties ......................142),
    CONTENT#243(     E.1. Handshake .................................................142),
    CONTENT#244(       E.1.1. Key Derivation and HKDF ...............................145),
    CONTENT#245(       E.1.2. Client Authentication .................................146),
    CONTENT#246(       E.1.3. 0-RTT .................................................146),
    CONTENT#247(       E.1.4. Exporter Independence .................................146),
    CONTENT#248(       E.1.5. Post-Compromise Security ..............................146),
    CONTENT#249(       E.1.6. External References ...................................147),
    CONTENT#250(     E.2. Record Layer ..............................................147),
    CONTENT#251(       E.2.1. External References ...................................148),
    CONTENT#252(     E.3. Traffic Analysis ..........................................148),
    CONTENT#253(     E.4. Side-Channel Attacks ......................................149),
    CONTENT#254(     E.5. Replay Attacks on 0-RTT ...................................150),
    CONTENT#255(       E.5.1. Replay and Exporters ..................................151),
    CONTENT#256(     E.6. PSK Identity Exposure .....................................152),
    CONTENT#257(     E.7. Sharing PSKs ..............................................152),
    CONTENT#258(     E.8. Attacks on Static RSA .....................................152),
    CONTENT#259(   Contributors .....................................................153),
    CONTENT#260(   Author's Address .................................................160),
      BREAK#261,
      BREAK#262,
      BREAK#263,
      BREAK#264,
      BREAK#265,
      BREAK#266,
      BREAK#267,
      BREAK#268,
      BREAK#269,
      BREAK#270,
      BREAK#271,
      BREAK#272,
      BREAK#273,
      BREAK#274,
      BREAK#275,
      BREAK#276,
      BREAK#277,
      BREAK#278,
      BREAK#279,
      BREAK#280,
      BREAK#282,
      BREAK#284,
      BREAK#285,
    SECTION#286(id=1, title=Introduction),
      BREAK#287,
    CONTENT#288(   The primary goal of TLS is to provide a secure channel between two),
    CONTENT#289(   communicating peers; the only requirement from the underlying),
    CONTENT#290(   transport is a reliable, in-order data stream.  Specifically, the),
    CONTENT#291(   secure channel should provide the following properties:),
      BREAK#292,
    CONTENT#293(   -  Authentication: The server side of the channel is always),
    CONTENT#294(      authenticated; the client side is optionally authenticated.),
    CONTENT#295(      Authentication can happen via asymmetric cryptography (e.g., RSA),
    CONTENT#296(      [RSA], the Elliptic Curve Digital Signature Algorithm (ECDSA)),
    CONTENT#297(      [ECDSA], or the Edwards-Curve Digital Signature Algorithm (EdDSA)),
    CONTENT#298(      [RFC8032]) or a symmetric pre-shared key (PSK).),
      BREAK#299,
    CONTENT#300(   -  Confidentiality: Data sent over the channel after establishment is),
    CONTENT#301(      only visible to the endpoints.  TLS does not hide the length of),
    CONTENT#302(      the data it transmits, though endpoints are able to pad TLS),
    CONTENT#303(      records in order to obscure lengths and improve protection against),
    CONTENT#304(      traffic analysis techniques.),
      BREAK#305,
    CONTENT#306(   -  Integrity: Data sent over the channel after establishment cannot),
    CONTENT#307(      be modified by attackers without detection.),
      BREAK#308,
    CONTENT#309(   These properties should be true even in the face of an attacker who),
    CONTENT#310(   has complete control of the network, as described in [RFC3552].  See),
    CONTENT#311(   Appendix E for a more complete statement of the relevant security),
    CONTENT#312(   properties.),
      BREAK#313,
    CONTENT#314(   TLS consists of two primary components:),
      BREAK#315,
    CONTENT#316(   -  A handshake protocol (Section 4) that authenticates the),
    CONTENT#317(      communicating parties, negotiates cryptographic modes and),
    CONTENT#318(      parameters, and establishes shared keying material.  The handshake),
    CONTENT#319(      protocol is designed to resist tampering; an active attacker),
    CONTENT#320(      should not be able to force the peers to negotiate different),
    CONTENT#321(      parameters than they would if the connection were not under),
    CONTENT#322(      attack.),
      BREAK#323,
    CONTENT#324(   -  A record protocol (Section 5) that uses the parameters established),
    CONTENT#325(      by the handshake protocol to protect traffic between the),
    CONTENT#326(      communicating peers.  The record protocol divides traffic up into),
    CONTENT#327(      a series of records, each of which is independently protected),
    CONTENT#328(      using the traffic keys.),
      BREAK#329,
      BREAK#330,
      BREAK#331,
      BREAK#332,
      BREAK#333,
      BREAK#334,
      BREAK#335,
      BREAK#336,
      BREAK#338,
      BREAK#340,
      BREAK#341,
    CONTENT#342(   TLS is application protocol independent; higher-level protocols can),
    CONTENT#343(   layer on top of TLS transparently.  The TLS standard, however, does),
    CONTENT#344(   not specify how protocols add security with TLS; how to initiate TLS),
    CONTENT#345(   handshaking and how to interpret the authentication certificates),
    CONTENT#346(   exchanged are left to the judgment of the designers and implementors),
    CONTENT#347(   of protocols that run on top of TLS.),
      BREAK#348,
    CONTENT#349(   This document defines TLS version 1.3.  While TLS 1.3 is not directly),
    CONTENT#350(   compatible with previous versions, all versions of TLS incorporate a),
    CONTENT#351(   versioning mechanism which allows clients and servers to),
    CONTENT#352(   interoperably negotiate a common version if one is supported by both),
    CONTENT#353(   peers.),
      BREAK#354,
    CONTENT#355(   This document supersedes and obsoletes previous versions of TLS,),
    CONTENT#356(   including version 1.2 [RFC5246].  It also obsoletes the TLS ticket),
    CONTENT#357(   mechanism defined in [RFC5077] and replaces it with the mechanism),
    CONTENT#358(   defined in Section 2.2.  Because TLS 1.3 changes the way keys are),
    CONTENT#359(   derived, it updates [RFC5705] as described in Section 7.5.  It also),
    CONTENT#360(   changes how Online Certificate Status Protocol (OCSP) messages are),
    CONTENT#361(   carried and therefore updates [RFC6066] and obsoletes [RFC6961] as),
    CONTENT#362(   described in Section 4.4.2.1.),
      BREAK#363,
    SECTION#364(id=1.1, title=Conventions and Terminology),
      BREAK#365,
    CONTENT#366(   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",),
    CONTENT#367(   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and),
    CONTENT#368(   "OPTIONAL" in this document are to be interpreted as described in),
    CONTENT#369(   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all),
    CONTENT#370(   capitals, as shown here.),
      BREAK#371,
    CONTENT#372(   The following terms are used:),
      BREAK#373,
    CONTENT#374(   client:  The endpoint initiating the TLS connection.),
      BREAK#375,
    CONTENT#376(   connection:  A transport-layer connection between two endpoints.),
      BREAK#377,
    CONTENT#378(   endpoint:  Either the client or server of the connection.),
      BREAK#379,
    CONTENT#380(   handshake:  An initial negotiation between client and server that),
    CONTENT#381(      establishes the parameters of their subsequent interactions),
    CONTENT#382(      within TLS.),
      BREAK#383,
    CONTENT#384(   peer:  An endpoint.  When discussing a particular endpoint, "peer"),
    CONTENT#385(      refers to the endpoint that is not the primary subject of),
    CONTENT#386(      discussion.),
      BREAK#387,
      BREAK#388,
      BREAK#389,
      BREAK#390,
      BREAK#391,
      BREAK#392,
      BREAK#394,
      BREAK#396,
      BREAK#397,
    CONTENT#398(   receiver:  An endpoint that is receiving records.),
      BREAK#399,
    CONTENT#400(   sender:  An endpoint that is transmitting records.),
      BREAK#401,
    CONTENT#402(   server:  The endpoint that did not initiate the TLS connection.),
      BREAK#403,
    SECTION#404(id=1.2, title=Major Differences from TLS 1.2),
      BREAK#405,
    CONTENT#406(   The following is a list of the major functional differences between),
    CONTENT#407(   TLS 1.2 and TLS 1.3.  It is not intended to be exhaustive, and there),
    CONTENT#408(   are many minor differences.),
      BREAK#409,
    CONTENT#410(   -  The list of supported symmetric encryption algorithms has been),
    CONTENT#411(      pruned of all algorithms that are considered legacy.  Those that),
    CONTENT#412(      remain are all Authenticated Encryption with Associated Data),
    CONTENT#413(      (AEAD) algorithms.  The cipher suite concept has been changed to),
    CONTENT#414(      separate the authentication and key exchange mechanisms from the),
    CONTENT#415(      record protection algorithm (including secret key length) and a),
    CONTENT#416(      hash to be used with both the key derivation function and),
    CONTENT#417(      handshake message authentication code (MAC).),
      BREAK#418,
    CONTENT#419(   -  A zero round-trip time (0-RTT) mode was added, saving a round trip),
    CONTENT#420(      at connection setup for some application data, at the cost of),
    CONTENT#421(      certain security properties.),
      BREAK#422,
    CONTENT#423(   -  Static RSA and Diffie-Hellman cipher suites have been removed; all),
    CONTENT#424(      public-key based key exchange mechanisms now provide forward),
    CONTENT#425(      secrecy.),
      BREAK#426,
    CONTENT#427(   -  All handshake messages after the ServerHello are now encrypted.),
    CONTENT#428(      The newly introduced EncryptedExtensions message allows various),
    CONTENT#429(      extensions previously sent in the clear in the ServerHello to also),
    CONTENT#430(      enjoy confidentiality protection.),
      BREAK#431,
    CONTENT#432(   -  The key derivation functions have been redesigned.  The new design),
    CONTENT#433(      allows easier analysis by cryptographers due to their improved key),
    CONTENT#434(      separation properties.  The HMAC-based Extract-and-Expand Key),
    CONTENT#435(      Derivation Function (HKDF) is used as an underlying primitive.),
      BREAK#436,
    CONTENT#437(   -  The handshake state machine has been significantly restructured to),
    CONTENT#438(      be more consistent and to remove superfluous messages such as),
    CONTENT#439(      ChangeCipherSpec (except when needed for middlebox compatibility).),
      BREAK#440,
    CONTENT#441(   -  Elliptic curve algorithms are now in the base spec, and new),
    CONTENT#442(      signature algorithms, such as EdDSA, are included.  TLS 1.3),
    CONTENT#443(      removed point format negotiation in favor of a single point format),
    CONTENT#444(      for each curve.),
      BREAK#445,
      BREAK#446,
      BREAK#447,
      BREAK#448,
      BREAK#450,
      BREAK#452,
      BREAK#453,
    CONTENT#454(   -  Other cryptographic improvements were made, including changing the),
    CONTENT#455(      RSA padding to use the RSA Probabilistic Signature Scheme),
    CONTENT#456(      (RSASSA-PSS), and the removal of compression, the Digital),
    CONTENT#457(      Signature Algorithm (DSA), and custom Ephemeral Diffie-Hellman),
    CONTENT#458(      (DHE) groups.),
      BREAK#459,
    CONTENT#460(   -  The TLS 1.2 version negotiation mechanism has been deprecated in),
    CONTENT#461(      favor of a version list in an extension.  This increases),
    CONTENT#462(      compatibility with existing servers that incorrectly implemented),
    CONTENT#463(      version negotiation.),
      BREAK#464,
    CONTENT#465(   -  Session resumption with and without server-side state as well as),
    CONTENT#466(      the PSK-based cipher suites of earlier TLS versions have been),
    CONTENT#467(      replaced by a single new PSK exchange.),
      BREAK#468,
    CONTENT#469(   -  References have been updated to point to the updated versions of),
    CONTENT#470(      RFCs, as appropriate (e.g., RFC 5280 rather than RFC 3280).),
      BREAK#471,
    SECTION#472(id=1.3, title=Updates Affecting TLS 1.2),
      BREAK#473,
    CONTENT#474(   This document defines several changes that optionally affect),
    CONTENT#475(   implementations of TLS 1.2, including those which do not also support),
    CONTENT#476(   TLS 1.3:),
      BREAK#477,
    CONTENT#478(   -  A version downgrade protection mechanism is described in),
    CONTENT#479(      Section 4.1.3.),
      BREAK#480,
    CONTENT#481(   -  RSASSA-PSS signature schemes are defined in Section 4.2.3.),
      BREAK#482,
    CONTENT#483(   -  The "supported_versions" ClientHello extension can be used to),
    CONTENT#484(      negotiate the version of TLS to use, in preference to the),
    CONTENT#485(      legacy_version field of the ClientHello.),
      BREAK#486,
    CONTENT#487(   -  The "signature_algorithms_cert" extension allows a client to),
    CONTENT#488(      indicate which signature algorithms it can validate in X.509),
    CONTENT#489(      certificates.),
      BREAK#490,
    CONTENT#491(   Additionally, this document clarifies some compliance requirements),
    CONTENT#492(   for earlier versions of TLS; see Section 9.3.),
      BREAK#493,
      BREAK#494,
      BREAK#495,
      BREAK#496,
      BREAK#497,
      BREAK#498,
      BREAK#499,
      BREAK#500,
      BREAK#501,
      BREAK#502,
      BREAK#503,
      BREAK#504,
      BREAK#506,
      BREAK#508,
      BREAK#509,
    SECTION#510(id=2, title=Protocol Overview),
      BREAK#511,
    CONTENT#512(   The cryptographic parameters used by the secure channel are produced),
    CONTENT#513(   by the TLS handshake protocol.  This sub-protocol of TLS is used by),
    CONTENT#514(   the client and server when first communicating with each other.  The),
    CONTENT#515(   handshake protocol allows peers to negotiate a protocol version,),
    CONTENT#516(   select cryptographic algorithms, optionally authenticate each other,),
    CONTENT#517(   and establish shared secret keying material.  Once the handshake is),
    CONTENT#518(   complete, the peers use the established keys to protect the),
    CONTENT#519(   application-layer traffic.),
      BREAK#520,
    CONTENT#521(   A failure of the handshake or other protocol error triggers the),
    CONTENT#522(   termination of the connection, optionally preceded by an alert),
    CONTENT#523(   message (Section 6).),
      BREAK#524,
    CONTENT#525(   TLS supports three basic key exchange modes:),
      BREAK#526,
    CONTENT#527(   -  (EC)DHE (Diffie-Hellman over either finite fields or elliptic),
    CONTENT#528(      curves)),
      BREAK#529,
    CONTENT#530(   -  PSK-only),
      BREAK#531,
    CONTENT#532(   -  PSK with (EC)DHE),
      BREAK#533,
      BREAK#534,
      BREAK#535,
      BREAK#536,
      BREAK#537,
      BREAK#538,
      BREAK#539,
      BREAK#540,
      BREAK#541,
      BREAK#542,
      BREAK#543,
      BREAK#544,
      BREAK#545,
      BREAK#546,
      BREAK#547,
      BREAK#548,
      BREAK#549,
      BREAK#550,
      BREAK#551,
      BREAK#552,
      BREAK#553,
      BREAK#554,
      BREAK#555,
      BREAK#556,
      BREAK#557,
      BREAK#558,
      BREAK#559,
      BREAK#560,
      BREAK#562,
      BREAK#564,
      BREAK#565,
    CONTENT#566(   Figure 1 below shows the basic full TLS handshake:),
      BREAK#567,
    CONTENT#568(       Client                                           Server),
      BREAK#569,
    CONTENT#572(     | + signature_algorithms*),
    CONTENT#573(     | + psk_key_exchange_modes*),
    CONTENT#574(     v + pre_shared_key*       -------->),
    CONTENT#575(                                                  ServerHello  ^ Key),
    CONTENT#576(                                                 + key_share*  | Exch),
    CONTENT#577(                                            + pre_shared_key*  v),
    CONTENT#578(                                        {EncryptedExtensions}  ^  Server),
    CONTENT#579(                                        {CertificateRequest*}  v  Params),
    CONTENT#580(                                               {Certificate*}  ^),
    CONTENT#581(                                         {CertificateVerify*}  | Auth),
    CONTENT#582(                                                   {Finished}  v),
    CONTENT#583(                               <--------  [Application Data*]),
    CONTENT#584(     ^ {Certificate*}),
    CONTENT#586(     v {Finished}              -------->),
    CONTENT#587(       [Application Data]      <------->  [Application Data]),
      BREAK#588,
    CONTENT#589(              +  Indicates noteworthy extensions sent in the),
    CONTENT#590(                 previously noted message.),
      BREAK#591,
    CONTENT#592(              *  Indicates optional or situation-dependent),
    CONTENT#593(                 messages/extensions that are not always sent.),
      BREAK#594,
    CONTENT#595(              {} Indicates messages protected using keys),
    CONTENT#596(                 derived from a [sender]_handshake_traffic_secret.),
      BREAK#597,
    CONTENT#598(              [] Indicates messages protected using keys),
    CONTENT#599(                 derived from [sender]_application_traffic_secret_N.),
      BREAK#600,
    CONTENT#601(               Figure 1: Message Flow for Full TLS Handshake),
      BREAK#602,
    CONTENT#603(   The handshake can be thought of as having three phases (indicated in),
    CONTENT#604(   the diagram above):),
      BREAK#605,
    CONTENT#606(   -  Key Exchange: Establish shared keying material and select the),
    CONTENT#607(      cryptographic parameters.  Everything after this phase is),
    CONTENT#608(      encrypted.),
      BREAK#609,
    CONTENT#610(   -  Server Parameters: Establish other handshake parameters),
    CONTENT#611(      (whether the client is authenticated, application-layer protocol),
    CONTENT#612(      support, etc.).),
      BREAK#613,
      BREAK#614,
      BREAK#615,
      BREAK#616,
      BREAK#618,
      BREAK#620,
      BREAK#621,
    CONTENT#622(   -  Authentication: Authenticate the server (and, optionally, the),
    CONTENT#623(      client) and provide key confirmation and handshake integrity.),
      BREAK#624,
    CONTENT#625(   In the Key Exchange phase, the client sends the ClientHello),
    CONTENT#626(   (Section 4.1.2) message, which contains a random nonce),
    CONTENT#627(   (ClientHello.random); its offered protocol versions; a list of),
    CONTENT#628(   symmetric cipher/HKDF hash pairs; either a set of Diffie-Hellman key),
    CONTENT#629(   shares (in the "key_share" (Section 4.2.8) extension), a set of),
    CONTENT#630(   pre-shared key labels (in the "pre_shared_key" (Section 4.2.11)),
    CONTENT#631(   extension), or both; and potentially additional extensions.),
    CONTENT#632(   Additional fields and/or messages may also be present for middlebox),
    CONTENT#633(   compatibility.),
      BREAK#634,
    CONTENT#635(   The server processes the ClientHello and determines the appropriate),
    CONTENT#636(   cryptographic parameters for the connection.  It then responds with),
    CONTENT#637(   its own ServerHello (Section 4.1.3), which indicates the negotiated),
    CONTENT#638(   connection parameters.  The combination of the ClientHello and the),
    CONTENT#639(   ServerHello determines the shared keys.  If (EC)DHE key establishment),
    CONTENT#640(   is in use, then the ServerHello contains a "key_share" extension with),
    CONTENT#641(   the server's ephemeral Diffie-Hellman share; the server's share MUST),
    CONTENT#642(   be in the same group as one of the client's shares.  If PSK key),
    CONTENT#643(   establishment is in use, then the ServerHello contains a),
    CONTENT#644(   "pre_shared_key" extension indicating which of the client's offered),
    CONTENT#645(   PSKs was selected.  Note that implementations can use (EC)DHE and PSK),
    CONTENT#646(   together, in which case both extensions will be supplied.),
      BREAK#647,
    CONTENT#648(   The server then sends two messages to establish the Server),
    CONTENT#649(   Parameters:),
      BREAK#650,
    CONTENT#651(   EncryptedExtensions:  responses to ClientHello extensions that are),
    CONTENT#652(      not required to determine the cryptographic parameters, other than),
    CONTENT#653(      those that are specific to individual certificates.),
    CONTENT#654(      [Section 4.3.1]),
      BREAK#655,
    CONTENT#656(   CertificateRequest:  if certificate-based client authentication is),
    CONTENT#657(      desired, the desired parameters for that certificate.  This),
    CONTENT#658(      message is omitted if client authentication is not desired.),
    CONTENT#659(      [Section 4.3.2]),
      BREAK#660,
      BREAK#661,
      BREAK#662,
      BREAK#663,
      BREAK#664,
      BREAK#665,
      BREAK#666,
      BREAK#667,
      BREAK#668,
      BREAK#669,
      BREAK#670,
      BREAK#671,
      BREAK#672,
      BREAK#674,
      BREAK#676,
      BREAK#677,
    CONTENT#678(   Finally, the client and server exchange Authentication messages.  TLS),
    CONTENT#679(   uses the same set of messages every time that certificate-based),
    CONTENT#680(   authentication is needed.  (PSK-based authentication happens as a),
    CONTENT#681(   side effect of key exchange.)  Specifically:),
      BREAK#682,
    CONTENT#683(   Certificate:  The certificate of the endpoint and any per-certificate),
    CONTENT#684(      extensions.  This message is omitted by the server if not),
    CONTENT#685(      authenticating with a certificate and by the client if the server),
    CONTENT#686(      did not send CertificateRequest (thus indicating that the client),
    CONTENT#687(      should not authenticate with a certificate).  Note that if raw),
    CONTENT#688(      public keys [RFC7250] or the cached information extension),
    CONTENT#689(      [RFC7924] are in use, then this message will not contain a),
    CONTENT#690(      certificate but rather some other value corresponding to the),
    CONTENT#691(      server's long-term key.  [Section 4.4.2]),
      BREAK#692,
    CONTENT#693(   CertificateVerify:  A signature over the entire handshake using the),
    CONTENT#694(      private key corresponding to the public key in the Certificate),
    CONTENT#695(      message.  This message is omitted if the endpoint is not),
    CONTENT#696(      authenticating via a certificate.  [Section 4.4.3]),
      BREAK#697,
    CONTENT#698(   Finished:  A MAC (Message Authentication Code) over the entire),
    CONTENT#699(      handshake.  This message provides key confirmation, binds the),
    CONTENT#700(      endpoint's identity to the exchanged keys, and in PSK mode also),
    CONTENT#701(      authenticates the handshake.  [Section 4.4.4]),
      BREAK#702,
    CONTENT#703(   Upon receiving the server's messages, the client responds with its),
    CONTENT#704(   Authentication messages, namely Certificate and CertificateVerify (if),
    CONTENT#705(   requested), and Finished.),
      BREAK#706,
    CONTENT#707(   At this point, the handshake is complete, and the client and server),
    CONTENT#708(   derive the keying material required by the record layer to exchange),
    CONTENT#709(   application-layer data protected through authenticated encryption.),
    CONTENT#710(   Application Data MUST NOT be sent prior to sending the Finished),
    CONTENT#711(   message, except as specified in Section 2.3.  Note that while the),
    CONTENT#712(   server may send Application Data prior to receiving the client's),
    CONTENT#713(   Authentication messages, any data sent at that point is, of course,),
    CONTENT#714(   being sent to an unauthenticated peer.),
      BREAK#715,
      BREAK#716,
      BREAK#717,
      BREAK#718,
      BREAK#719,
      BREAK#720,
      BREAK#721,
      BREAK#722,
      BREAK#723,
      BREAK#724,
      BREAK#725,
      BREAK#726,
      BREAK#727,
      BREAK#728,
      BREAK#730,
      BREAK#732,
      BREAK#733,
    SECTION#734(id=2.1, title=Incorrect DHE Share),
      BREAK#735,
    CONTENT#736(   If the client has not provided a sufficient "key_share" extension),
    CONTENT#737(   (e.g., it includes only DHE or ECDHE groups unacceptable to or),
    CONTENT#738(   unsupported by the server), the server corrects the mismatch with a),
    CONTENT#739(   HelloRetryRequest and the client needs to restart the handshake with),
    CONTENT#740(   an appropriate "key_share" extension, as shown in Figure 2.  If no),
    CONTENT#741(   common cryptographic parameters can be negotiated, the server MUST),
    CONTENT#742(   abort the handshake with an appropriate alert.),
      BREAK#743,
    CONTENT#744(        Client                                               Server),
      BREAK#745,
    CONTENT#746(        ClientHello),
    CONTENT#747(        + key_share             -------->),
    CONTENT#748(                                                  HelloRetryRequest),
    CONTENT#749(                                <--------               + key_share),
    CONTENT#750(        ClientHello),
    CONTENT#751(        + key_share             -------->),
    CONTENT#752(                                                        ServerHello),
    CONTENT#753(                                                        + key_share),
    CONTENT#754(                                              {EncryptedExtensions}),
    CONTENT#755(                                              {CertificateRequest*}),
    CONTENT#756(                                                     {Certificate*}),
    CONTENT#757(                                               {CertificateVerify*}),
    CONTENT#758(                                                         {Finished}),
    CONTENT#759(                                <--------       [Application Data*]),
    CONTENT#760(        {Certificate*}),
    CONTENT#761(        {CertificateVerify*}),
    CONTENT#762(        {Finished}              -------->),
    CONTENT#763(        [Application Data]      <------->        [Application Data]),
      BREAK#764,
    CONTENT#765(             Figure 2: Message Flow for a Full Handshake with),
    CONTENT#766(                           Mismatched Parameters),
      BREAK#767,
    CONTENT#768(   Note: The handshake transcript incorporates the initial),
    CONTENT#769(   ClientHello/HelloRetryRequest exchange; it is not reset with the),
    CONTENT#770(   new ClientHello.),
      BREAK#771,
    CONTENT#772(   TLS also allows several optimized variants of the basic handshake, as),
    CONTENT#773(   described in the following sections.),
      BREAK#774,
      BREAK#775,
      BREAK#776,
      BREAK#777,
      BREAK#778,
      BREAK#779,
      BREAK#780,
      BREAK#781,
      BREAK#782,
      BREAK#783,
      BREAK#784,
      BREAK#786,
      BREAK#788,
      BREAK#789,
    SECTION#790(id=2.2, title=Resumption and Pre-Shared Key (PSK)),
      BREAK#791,
    CONTENT#792(   Although TLS PSKs can be established out of band, PSKs can also be),
    CONTENT#793(   established in a previous connection and then used to establish a new),
    CONTENT#794(   connection ("session resumption" or "resuming" with a PSK).  Once a),
    CONTENT#795(   handshake has completed, the server can send the client a PSK),
    CONTENT#796(   identity that corresponds to a unique key derived from the initial),
    CONTENT#797(   handshake (see Section 4.6.1).  The client can then use that PSK),
    CONTENT#798(   identity in future handshakes to negotiate the use of the associated),
    CONTENT#799(   PSK.  If the server accepts the PSK, then the security context of the),
    CONTENT#800(   new connection is cryptographically tied to the original connection),
    CONTENT#801(   and the key derived from the initial handshake is used to bootstrap),
    CONTENT#802(   the cryptographic state instead of a full handshake.  In TLS 1.2 and),
    CONTENT#803(   below, this functionality was provided by "session IDs" and "session),
    CONTENT#804(   tickets" [RFC5077].  Both mechanisms are obsoleted in TLS 1.3.),
      BREAK#805,
    CONTENT#806(   PSKs can be used with (EC)DHE key exchange in order to provide),
    CONTENT#807(   forward secrecy in combination with shared keys, or can be used),
    CONTENT#808(   alone, at the cost of losing forward secrecy for the application),
    CONTENT#809(   data.),
      BREAK#810,
      BREAK#811,
      BREAK#812,
      BREAK#813,
      BREAK#814,
      BREAK#815,
      BREAK#816,
      BREAK#817,
      BREAK#818,
      BREAK#819,
      BREAK#820,
      BREAK#821,
      BREAK#822,
      BREAK#823,
      BREAK#824,
      BREAK#825,
      BREAK#826,
      BREAK#827,
      BREAK#828,
      BREAK#829,
      BREAK#830,
      BREAK#831,
      BREAK#832,
      BREAK#833,
      BREAK#834,
      BREAK#835,
      BREAK#836,
      BREAK#837,
      BREAK#838,
      BREAK#839,
      BREAK#840,
      BREAK#842,
      BREAK#844,
      BREAK#845,
    CONTENT#846(   Figure 3 shows a pair of handshakes in which the first handshake),
    CONTENT#847(   establishes a PSK and the second handshake uses it:),
      BREAK#848,
    CONTENT#849(          Client                                               Server),
      BREAK#850,
    CONTENT#851(   Initial Handshake:),
    CONTENT#852(          ClientHello),
    CONTENT#853(          + key_share               -------->),
    CONTENT#854(                                                          ServerHello),
    CONTENT#855(                                                          + key_share),
    CONTENT#856(                                                {EncryptedExtensions}),
    CONTENT#857(                                                {CertificateRequest*}),
    CONTENT#858(                                                       {Certificate*}),
    CONTENT#859(                                                 {CertificateVerify*}),
    CONTENT#860(                                                           {Finished}),
    CONTENT#861(                                    <--------     [Application Data*]),
    CONTENT#862(          {Certificate*}),
    CONTENT#863(          {CertificateVerify*}),
    CONTENT#864(          {Finished}                -------->),
    CONTENT#865(                                    <--------      [NewSessionTicket]),
    CONTENT#866(          [Application Data]        <------->      [Application Data]),
      BREAK#867,
      BREAK#868,
    CONTENT#869(   Subsequent Handshake:),
    CONTENT#870(          ClientHello),
    CONTENT#871(          + key_share*),
    CONTENT#872(          + pre_shared_key          -------->),
    CONTENT#873(                                                          ServerHello),
    CONTENT#874(                                                     + pre_shared_key),
    CONTENT#875(                                                         + key_share*),
    CONTENT#876(                                                {EncryptedExtensions}),
    CONTENT#877(                                                           {Finished}),
    CONTENT#878(                                    <--------     [Application Data*]),
    CONTENT#879(          {Finished}                -------->),
    CONTENT#880(          [Application Data]        <------->      [Application Data]),
      BREAK#881,
    CONTENT#882(               Figure 3: Message Flow for Resumption and PSK),
      BREAK#883,
    CONTENT#884(   As the server is authenticating via a PSK, it does not send a),
    CONTENT#885(   Certificate or a CertificateVerify message.  When a client offers),
    CONTENT#886(   resumption via a PSK, it SHOULD also supply a "key_share" extension),
    CONTENT#887(   to the server to allow the server to decline resumption and fall back),
    CONTENT#888(   to a full handshake, if needed.  The server responds with a),
    CONTENT#889(   "pre_shared_key" extension to negotiate the use of PSK key),
    CONTENT#890(   establishment and can (as shown here) respond with a "key_share"),
    CONTENT#891(   extension to do (EC)DHE key establishment, thus providing forward),
    CONTENT#892(   secrecy.),
      BREAK#893,
      BREAK#894,
      BREAK#895,
      BREAK#896,
      BREAK#898,
      BREAK#900,
      BREAK#901,
    CONTENT#902(   When PSKs are provisioned out of band, the PSK identity and the KDF),
    CONTENT#903(   hash algorithm to be used with the PSK MUST also be provisioned.),
      BREAK#904,
    CONTENT#905(   Note:  When using an out-of-band provisioned pre-shared secret, a),
    CONTENT#906(      critical consideration is using sufficient entropy during the key),
    CONTENT#907(      generation, as discussed in [RFC4086].  Deriving a shared secret),
    CONTENT#908(      from a password or other low-entropy sources is not secure.  A),
    CONTENT#909(      low-entropy secret, or password, is subject to dictionary attacks),
    CONTENT#910(      based on the PSK binder.  The specified PSK authentication is not),
    CONTENT#911(      a strong password-based authenticated key exchange even when used),
    CONTENT#912(      with Diffie-Hellman key establishment.  Specifically, it does not),
    CONTENT#913(      prevent an attacker that can observe the handshake from performing),
    CONTENT#914(      a brute-force attack on the password/pre-shared key.),
      BREAK#915,
    SECTION#916(id=2.3, title=0-RTT Data),
      BREAK#917,
    CONTENT#918(   When clients and servers share a PSK (either obtained externally or),
    CONTENT#919(   via a previous handshake), TLS 1.3 allows clients to send data on the),
    CONTENT#920(   first flight ("early data").  The client uses the PSK to authenticate),
    CONTENT#921(   the server and to encrypt the early data.),
      BREAK#922,
    CONTENT#923(   As shown in Figure 4, the 0-RTT data is just added to the 1-RTT),
    CONTENT#924(   handshake in the first flight.  The rest of the handshake uses the),
    CONTENT#925(   same messages as for a 1-RTT handshake with PSK resumption.),
      BREAK#926,
      BREAK#927,
      BREAK#928,
      BREAK#929,
      BREAK#930,
      BREAK#931,
      BREAK#932,
      BREAK#933,
      BREAK#934,
      BREAK#935,
      BREAK#936,
      BREAK#937,
      BREAK#938,
      BREAK#939,
      BREAK#940,
      BREAK#941,
      BREAK#942,
      BREAK#943,
      BREAK#944,
      BREAK#945,
      BREAK#946,
      BREAK#947,
      BREAK#948,
      BREAK#949,
      BREAK#950,
      BREAK#951,
      BREAK#952,
      BREAK#954,
      BREAK#956,
      BREAK#957,
    CONTENT#958(         Client                                               Server),
      BREAK#959,
    CONTENT#960(         ClientHello),
    CONTENT#961(         + early_data),
    CONTENT#962(         + key_share*),
    CONTENT#963(         + psk_key_exchange_modes),
    CONTENT#964(         + pre_shared_key),
    CONTENT#965(         (Application Data*)     -------->),
    CONTENT#966(                                                         ServerHello),
    CONTENT#967(                                                    + pre_shared_key),
    CONTENT#968(                                                        + key_share*),
    CONTENT#969(                                               {EncryptedExtensions}),
    CONTENT#970(                                                       + early_data*),
    CONTENT#971(                                                          {Finished}),
    CONTENT#972(                                 <--------       [Application Data*]),
    CONTENT#973(         (EndOfEarlyData)),
    CONTENT#974(         {Finished}              -------->),
    CONTENT#975(         [Application Data]      <------->        [Application Data]),
      BREAK#976,
    CONTENT#977(               +  Indicates noteworthy extensions sent in the),
    CONTENT#978(                  previously noted message.),
      BREAK#979,
    CONTENT#980(               *  Indicates optional or situation-dependent),
    CONTENT#981(                  messages/extensions that are not always sent.),
      BREAK#982,
    CONTENT#983(               () Indicates messages protected using keys),
    CONTENT#984(                  derived from a client_early_traffic_secret.),
      BREAK#985,
    CONTENT#986(               {} Indicates messages protected using keys),
    CONTENT#987(                  derived from a [sender]_handshake_traffic_secret.),
      BREAK#988,
    CONTENT#989(               [] Indicates messages protected using keys),
    CONTENT#990(                  derived from [sender]_application_traffic_secret_N.),
      BREAK#991,
    CONTENT#992(               Figure 4: Message Flow for a 0-RTT Handshake),
      BREAK#993,
      BREAK#994,
      BREAK#995,
      BREAK#996,
      BREAK#997,
      BREAK#998,
      BREAK#999,
      BREAK#1000,
      BREAK#1001,
      BREAK#1002,
      BREAK#1003,
      BREAK#1004,
      BREAK#1005,
      BREAK#1006,
      BREAK#1007,
      BREAK#1008,
      BREAK#1010,
      BREAK#1012,
      BREAK#1013,
    CONTENT#1014(   IMPORTANT NOTE: The security properties for 0-RTT data are weaker),
    CONTENT#1015(   than those for other kinds of TLS data.  Specifically:),
      BREAK#1016,
    CONTENT#1017(   1.  This data is not forward secret, as it is encrypted solely under),
    CONTENT#1018(       keys derived using the offered PSK.),
      BREAK#1019,
    CONTENT#1020(   2.  There are no guarantees of non-replay between connections.),
    CONTENT#1021(       Protection against replay for ordinary TLS 1.3 1-RTT data is),
    CONTENT#1022(       provided via the server's Random value, but 0-RTT data does not),
    CONTENT#1023(       depend on the ServerHello and therefore has weaker guarantees.),
    CONTENT#1024(       This is especially relevant if the data is authenticated either),
    CONTENT#1025(       with TLS client authentication or inside the application),
    CONTENT#1026(       protocol.  The same warnings apply to any use of the),
    CONTENT#1027(       early_exporter_master_secret.),
      BREAK#1028,
    CONTENT#1029(   0-RTT data cannot be duplicated within a connection (i.e., the server),
    CONTENT#1030(   will not process the same data twice for the same connection), and an),
    CONTENT#1031(   attacker will not be able to make 0-RTT data appear to be 1-RTT data),
    CONTENT#1032(   (because it is protected with different keys).  Appendix E.5 contains),
    CONTENT#1033(   a description of potential attacks, and Section 8 describes),
    CONTENT#1034(   mechanisms which the server can use to limit the impact of replay.),
      BREAK#1035,
    SECTION#1036(id=3, title=Presentation Language),
      BREAK#1037,
    CONTENT#1038(   This document deals with the formatting of data in an external),
    CONTENT#1039(   representation.  The following very basic and somewhat casually),
    CONTENT#1040(   defined presentation syntax will be used.),
      BREAK#1041,
    SECTION#1042(id=3.1, title=Basic Block Size),
      BREAK#1043,
    CONTENT#1044(   The representation of all data items is explicitly specified.  The),
    CONTENT#1045(   basic data block size is one byte (i.e., 8 bits).  Multiple-byte data),
    CONTENT#1046(   items are concatenations of bytes, from left to right, from top to),
    CONTENT#1047(   bottom.  From the byte stream, a multi-byte item (a numeric in the),
    CONTENT#1048(   following example) is formed (using C notation) by:),
      BREAK#1049,
    CONTENT#1050(      value = (byte[0] << 8*(n-1)) | (byte[1] << 8*(n-2)) |),
    CONTENT#1051(              ... | byte[n-1];),
      BREAK#1052,
    CONTENT#1053(   This byte ordering for multi-byte values is the commonplace network),
    CONTENT#1054(   byte order or big-endian format.),
      BREAK#1055,
      BREAK#1056,
      BREAK#1057,
      BREAK#1058,
      BREAK#1059,
      BREAK#1060,
      BREAK#1061,
      BREAK#1062,
      BREAK#1063,
      BREAK#1064,
      BREAK#1066,
      BREAK#1068,
      BREAK#1069,
    SECTION#1070(id=3.2, title=Miscellaneous),
      BREAK#1071,
    CONTENT#1072(   Comments begin with "/*" and end with "*/".),
      BREAK#1073,
    CONTENT#1074(   Optional components are denoted by enclosing them in "[[ ]]" (double),
    CONTENT#1075(   brackets).),
      BREAK#1076,
    CONTENT#1077(   Single-byte entities containing uninterpreted data are of),
    CONTENT#1078(   type opaque.),
      BREAK#1079,
    CONTENT#1080(   A type alias T' for an existing type T is defined by:),
      BREAK#1081,
    CONTENT#1082(      T T';),
      BREAK#1083,
    SECTION#1084(id=3.3, title=Numbers),
      BREAK#1085,
    CONTENT#1086(   The basic numeric data type is an unsigned byte (uint8).  All larger),
    CONTENT#1087(   numeric data types are constructed from a fixed-length series of),
    CONTENT#1088(   bytes concatenated as described in Section 3.1 and are also unsigned.),
    CONTENT#1089(   The following numeric types are predefined.),
      BREAK#1090,
    CONTENT#1091(      uint8 uint16[2];),
    CONTENT#1092(      uint8 uint24[3];),
    CONTENT#1093(      uint8 uint32[4];),
    CONTENT#1094(      uint8 uint64[8];),
      BREAK#1095,
    CONTENT#1096(   All values, here and elsewhere in the specification, are transmitted),
    CONTENT#1097(   in network byte (big-endian) order; the uint32 represented by the hex),
    CONTENT#1098(   bytes 01 02 03 04 is equivalent to the decimal value 16909060.),
      BREAK#1099,
    SECTION#1100(id=3.4, title=Vectors),
      BREAK#1101,
    CONTENT#1102(   A vector (single-dimensioned array) is a stream of homogeneous data),
    CONTENT#1103(   elements.  The size of the vector may be specified at documentation),
    CONTENT#1104(   time or left unspecified until runtime.  In either case, the length),
    CONTENT#1105(   declares the number of bytes, not the number of elements, in the),
    CONTENT#1106(   vector.  The syntax for specifying a new type, T', that is a fixed-),
    CONTENT#1107(   length vector of type T is),
      BREAK#1108,
    CONTENT#1109(      T T'[n];),
      BREAK#1110,
    CONTENT#1111(   Here, T' occupies n bytes in the data stream, where n is a multiple),
    CONTENT#1112(   of the size of T.  The length of the vector is not included in the),
    CONTENT#1113(   encoded stream.),
      BREAK#1114,
      BREAK#1115,
      BREAK#1116,
      BREAK#1117,
      BREAK#1118,
      BREAK#1119,
      BREAK#1120,
      BREAK#1122,
      BREAK#1124,
      BREAK#1125,
    CONTENT#1126(   In the following example, Datum is defined to be three consecutive),
    CONTENT#1127(   bytes that the protocol does not interpret, while Data is three),
    CONTENT#1128(   consecutive Datum, consuming a total of nine bytes.),
      BREAK#1129,
    CONTENT#1130(      opaque Datum[3];      /* three uninterpreted bytes */),
    CONTENT#1131(      Datum Data[9];        /* three consecutive 3-byte vectors */),
      BREAK#1132,
    CONTENT#1133(   Variable-length vectors are defined by specifying a subrange of legal),
    CONTENT#1134(   lengths, inclusively, using the notation <floor..ceiling>.  When),
    CONTENT#1135(   these are encoded, the actual length precedes the vector's contents),
    CONTENT#1136(   in the byte stream.  The length will be in the form of a number),
    CONTENT#1137(   consuming as many bytes as required to hold the vector's specified),
    CONTENT#1138(   maximum (ceiling) length.  A variable-length vector with an actual),
    CONTENT#1139(   length field of zero is referred to as an empty vector.),
      BREAK#1140,
    CONTENT#1141(      T T'<floor..ceiling>;),
      BREAK#1142,
    CONTENT#1143(   In the following example, "mandatory" is a vector that must contain),
    CONTENT#1144(   between 300 and 400 bytes of type opaque.  It can never be empty.),
    CONTENT#1145(   The actual length field consumes two bytes, a uint16, which is),
    CONTENT#1146(   sufficient to represent the value 400 (see Section 3.3).  Similarly,),
    CONTENT#1147(   "longer" can represent up to 800 bytes of data, or 400 uint16),
    CONTENT#1148(   elements, and it may be empty.  Its encoding will include a two-byte),
    CONTENT#1149(   actual length field prepended to the vector.  The length of an),
    CONTENT#1150(   encoded vector must be an exact multiple of the length of a single),
    CONTENT#1151(   element (e.g., a 17-byte vector of uint16 would be illegal).),
      BREAK#1152,
    CONTENT#1153(      opaque mandatory<300..400>;),
    CONTENT#1154(            /* length field is two bytes, cannot be empty */),
    CONTENT#1155(      uint16 longer<0..800>;),
    CONTENT#1156(            /* zero to 400 16-bit unsigned integers */),
      BREAK#1157,
    SECTION#1158(id=3.5, title=Enumerateds),
      BREAK#1159,
    CONTENT#1160(   An additional sparse data type, called "enum" or "enumerated", is),
    CONTENT#1161(   available.  Each definition is a different type.  Only enumerateds of),
    CONTENT#1162(   the same type may be assigned or compared.  Every element of an),
    CONTENT#1163(   enumerated must be assigned a value, as demonstrated in the following),
    CONTENT#1164(   example.  Since the elements of the enumerated are not ordered, they),
    CONTENT#1165(   can be assigned any unique value, in any order.),
      BREAK#1166,
    CONTENT#1167(      enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;),
      BREAK#1168,
    CONTENT#1169(   Future extensions or additions to the protocol may define new values.),
    CONTENT#1170(   Implementations need to be able to parse and ignore unknown values),
    CONTENT#1171(   unless the definition of the field states otherwise.),
      BREAK#1172,
      BREAK#1173,
      BREAK#1174,
      BREAK#1175,
      BREAK#1176,
      BREAK#1178,
      BREAK#1180,
      BREAK#1181,
    CONTENT#1182(   An enumerated occupies as much space in the byte stream as would its),
    CONTENT#1183(   maximal defined ordinal value.  The following definition would cause),
    CONTENT#1184(   one byte to be used to carry fields of type Color.),
      BREAK#1185,
    CONTENT#1186(      enum { red(3), blue(5), white(7) } Color;),
      BREAK#1187,
    CONTENT#1188(   One may optionally specify a value without its associated tag to),
    CONTENT#1189(   force the width definition without defining a superfluous element.),
      BREAK#1190,
    CONTENT#1191(   In the following example, Taste will consume two bytes in the data),
    CONTENT#1192(   stream but can only assume the values 1, 2, or 4 in the current),
    CONTENT#1193(   version of the protocol.),
      BREAK#1194,
    CONTENT#1195(      enum { sweet(1), sour(2), bitter(4), (32000) } Taste;),
      BREAK#1196,
    CONTENT#1197(   The names of the elements of an enumeration are scoped within the),
    CONTENT#1198(   defined type.  In the first example, a fully qualified reference to),
    CONTENT#1199(   the second element of the enumeration would be Color.blue.  Such),
    CONTENT#1200(   qualification is not required if the target of the assignment is well),
    CONTENT#1201(   specified.),
      BREAK#1202,
    CONTENT#1203(      Color color = Color.blue;     /* overspecified, legal */),
    CONTENT#1204(      Color color = blue;           /* correct, type implicit */),
      BREAK#1205,
    CONTENT#1206(   The names assigned to enumerateds do not need to be unique.  The),
    CONTENT#1207(   numerical value can describe a range over which the same name),
    CONTENT#1208(   applies.  The value includes the minimum and maximum inclusive values),
    CONTENT#1209(   in that range, separated by two period characters.  This is),
    CONTENT#1210(   principally useful for reserving regions of the space.),
      BREAK#1211,
    CONTENT#1212(      enum { sad(0), meh(1..254), happy(255) } Mood;),
      BREAK#1213,
    SECTION#1214(id=3.6, title=Constructed Types),
      BREAK#1215,
    CONTENT#1216(   Structure types may be constructed from primitive types for),
    CONTENT#1217(   convenience.  Each specification declares a new, unique type.  The),
    CONTENT#1218(   syntax used for definitions is much like that of C.),
      BREAK#1219,
    CONTENT#1220(      struct {),
    CONTENT#1221(          T1 f1;),
    CONTENT#1222(          T2 f2;),
    CONTENT#1223(          ...),
    CONTENT#1224(          Tn fn;),
    CONTENT#1225(      } T;),
      BREAK#1226,
    CONTENT#1227(   Fixed- and variable-length vector fields are allowed using the),
    CONTENT#1228(   standard vector syntax.  Structures V1 and V2 in the variants example),
    CONTENT#1229(   (Section 3.8) demonstrate this.),
      BREAK#1230,
      BREAK#1231,
      BREAK#1232,
      BREAK#1234,
      BREAK#1236,
      BREAK#1237,
    CONTENT#1238(   The fields within a structure may be qualified using the type's name,),
    CONTENT#1239(   with a syntax much like that available for enumerateds.  For example,),
    CONTENT#1240(   T.f2 refers to the second field of the previous declaration.),
      BREAK#1241,
    SECTION#1242(id=3.7, title=Constants),
      BREAK#1243,
    CONTENT#1244(   Fields and variables may be assigned a fixed value using "=", as in:),
      BREAK#1245,
    CONTENT#1246(      struct {),
    CONTENT#1247(          T1 f1 = 8;  /* T.f1 must always be 8 */),
    CONTENT#1248(          T2 f2;),
    CONTENT#1249(      } T;),
      BREAK#1250,
    SECTION#1251(id=3.8, title=Variants),
      BREAK#1252,
    CONTENT#1253(   Defined structures may have variants based on some knowledge that is),
    CONTENT#1254(   available within the environment.  The selector must be an enumerated),
    CONTENT#1255(   type that defines the possible variants the structure defines.  Each),
    CONTENT#1256(   arm of the select (below) specifies the type of that variant's field),
    CONTENT#1257(   and an optional field label.  The mechanism by which the variant is),
    CONTENT#1258(   selected at runtime is not prescribed by the presentation language.),
      BREAK#1259,
    CONTENT#1260(      struct {),
    CONTENT#1261(          T1 f1;),
    CONTENT#1262(          T2 f2;),
    CONTENT#1263(          ....),
    CONTENT#1264(          Tn fn;),
    CONTENT#1265(          select (E) {),
    CONTENT#1266(              case e1: Te1 [[fe1]];),
    CONTENT#1267(              case e2: Te2 [[fe2]];),
    CONTENT#1268(              ....),
    CONTENT#1269(              case en: Ten [[fen]];),
    CONTENT#1270(          };),
    CONTENT#1271(      } Tv;),
      BREAK#1272,
      BREAK#1273,
      BREAK#1274,
      BREAK#1275,
      BREAK#1276,
      BREAK#1277,
      BREAK#1278,
      BREAK#1279,
      BREAK#1280,
      BREAK#1281,
      BREAK#1282,
      BREAK#1283,
      BREAK#1284,
      BREAK#1285,
      BREAK#1286,
      BREAK#1287,
      BREAK#1288,
      BREAK#1290,
      BREAK#1292,
      BREAK#1293,
    CONTENT#1294(   For example:),
      BREAK#1295,
    CONTENT#1296(      enum { apple(0), orange(1) } VariantTag;),
      BREAK#1297,
    CONTENT#1298(      struct {),
    CONTENT#1299(          uint16 number;),
    CONTENT#1300(          opaque string<0..10>; /* variable length */),
    CONTENT#1301(      } V1;),
      BREAK#1302,
    CONTENT#1303(      struct {),
    CONTENT#1304(          uint32 number;),
    CONTENT#1305(          opaque string[10];    /* fixed length */),
    CONTENT#1306(      } V2;),
      BREAK#1307,
    CONTENT#1308(      struct {),
    CONTENT#1309(          VariantTag type;),
    CONTENT#1310(          select (VariantRecord.type) {),
    CONTENT#1311(              case apple:  V1;),
    CONTENT#1312(              case orange: V2;),
    CONTENT#1313(          };),
    CONTENT#1314(      } VariantRecord;),
      BREAK#1315,
    SECTION#1316(id=4, title=Handshake Protocol),
      BREAK#1317,
    CONTENT#1318(   The handshake protocol is used to negotiate the security parameters),
    CONTENT#1319(   of a connection.  Handshake messages are supplied to the TLS record),
    CONTENT#1320(   layer, where they are encapsulated within one or more TLSPlaintext or),
    CONTENT#1321(   TLSCiphertext structures which are processed and transmitted as),
    CONTENT#1322(   specified by the current active connection state.),
      BREAK#1323,
      BREAK#1324,
      BREAK#1325,
      BREAK#1326,
      BREAK#1327,
      BREAK#1328,
      BREAK#1329,
      BREAK#1330,
      BREAK#1331,
      BREAK#1332,
      BREAK#1333,
      BREAK#1334,
      BREAK#1335,
      BREAK#1336,
      BREAK#1337,
      BREAK#1338,
      BREAK#1339,
      BREAK#1340,
      BREAK#1341,
      BREAK#1342,
      BREAK#1343,
      BREAK#1344,
      BREAK#1346,
      BREAK#1348,
      BREAK#1349,
    CONTENT#1350(      enum {),
    CONTENT#1351(          client_hello(1),),
    CONTENT#1352(          server_hello(2),),
    CONTENT#1353(          new_session_ticket(4),),
    CONTENT#1354(          end_of_early_data(5),),
    CONTENT#1355(          encrypted_extensions(8),),
    CONTENT#1356(          certificate(11),),
    CONTENT#1357(          certificate_request(13),),
    CONTENT#1358(          certificate_verify(15),),
    CONTENT#1359(          finished(20),),
    CONTENT#1360(          key_update(24),),
    CONTENT#1361(          message_hash(254),),
    CONTENT#1362(          (255)),
    CONTENT#1363(      } HandshakeType;),
      BREAK#1364,
    CONTENT#1365(      struct {),
    CONTENT#1366(          HandshakeType msg_type;    /* handshake type */),
    CONTENT#1367(          uint24 length;             /* remaining bytes in message */),
    CONTENT#1368(          select (Handshake.msg_type) {),
    CONTENT#1369(              case client_hello:          ClientHello;),
    CONTENT#1370(              case server_hello:          ServerHello;),
    CONTENT#1371(              case end_of_early_data:     EndOfEarlyData;),
    CONTENT#1372(              case encrypted_extensions:  EncryptedExtensions;),
    CONTENT#1373(              case certificate_request:   CertificateRequest;),
    CONTENT#1374(              case certificate:           Certificate;),
    CONTENT#1375(              case certificate_verify:    CertificateVerify;),
    CONTENT#1376(              case finished:              Finished;),
    CONTENT#1377(              case new_session_ticket:    NewSessionTicket;),
    CONTENT#1378(              case key_update:            KeyUpdate;),
    CONTENT#1379(          };),
    CONTENT#1380(      } Handshake;),
      BREAK#1381,
    CONTENT#1382(   Protocol messages MUST be sent in the order defined in Section 4.4.1),
    CONTENT#1383(   and shown in the diagrams in Section 2.  A peer which receives a),
    CONTENT#1384(   handshake message in an unexpected order MUST abort the handshake),
    CONTENT#1385(   with an "unexpected_message" alert.),
      BREAK#1386,
    CONTENT#1387(   New handshake message types are assigned by IANA as described in),
    CONTENT#1388(   Section 11.),
      BREAK#1389,
    SECTION#1390(id=4.1, title=Key Exchange Messages),
      BREAK#1391,
    CONTENT#1392(   The key exchange messages are used to determine the security),
    CONTENT#1393(   capabilities of the client and the server and to establish shared),
    CONTENT#1394(   secrets, including the traffic keys used to protect the rest of the),
    CONTENT#1395(   handshake and the data.),
      BREAK#1396,
      BREAK#1397,
      BREAK#1398,
      BREAK#1399,
      BREAK#1400,
      BREAK#1402,
      BREAK#1404,
      BREAK#1405,
    SECTION#1406(id=4.1.1, title=Cryptographic Negotiation),
      BREAK#1407,
    CONTENT#1408(   In TLS, the cryptographic negotiation proceeds by the client offering),
    CONTENT#1409(   the following four sets of options in its ClientHello:),
      BREAK#1410,
    CONTENT#1411(   -  A list of cipher suites which indicates the AEAD algorithm/HKDF),
    CONTENT#1412(      hash pairs which the client supports.),
      BREAK#1413,
    CONTENT#1414(   -  A "supported_groups" (Section 4.2.7) extension which indicates the),
    CONTENT#1415(      (EC)DHE groups which the client supports and a "key_share"),
    CONTENT#1416(      (Section 4.2.8) extension which contains (EC)DHE shares for some),
    CONTENT#1417(      or all of these groups.),
      BREAK#1418,
    CONTENT#1419(   -  A "signature_algorithms" (Section 4.2.3) extension which indicates),
    CONTENT#1420(      the signature algorithms which the client can accept.  A),
    CONTENT#1421(      "signature_algorithms_cert" extension (Section 4.2.3) may also be),
    CONTENT#1422(      added to indicate certificate-specific signature algorithms.),
      BREAK#1423,
    CONTENT#1424(   -  A "pre_shared_key" (Section 4.2.11) extension which contains a),
    CONTENT#1425(      list of symmetric key identities known to the client and a),
    CONTENT#1426(      "psk_key_exchange_modes" (Section 4.2.9) extension which indicates),
    CONTENT#1427(      the key exchange modes that may be used with PSKs.),
      BREAK#1428,
    CONTENT#1429(   If the server does not select a PSK, then the first three of these),
    CONTENT#1430(   options are entirely orthogonal: the server independently selects a),
    CONTENT#1431(   cipher suite, an (EC)DHE group and key share for key establishment,),
    CONTENT#1432(   and a signature algorithm/certificate pair to authenticate itself to),
    CONTENT#1433(   the client.  If there is no overlap between the received),
    CONTENT#1434(   "supported_groups" and the groups supported by the server, then the),
    CONTENT#1435(   server MUST abort the handshake with a "handshake_failure" or an),
    CONTENT#1436(   "insufficient_security" alert.),
      BREAK#1437,
    CONTENT#1438(   If the server selects a PSK, then it MUST also select a key),
    CONTENT#1439(   establishment mode from the set indicated by the client's),
    CONTENT#1440(   "psk_key_exchange_modes" extension (at present, PSK alone or with),
    CONTENT#1441(   (EC)DHE).  Note that if the PSK can be used without (EC)DHE, then),
    CONTENT#1442(   non-overlap in the "supported_groups" parameters need not be fatal,),
    CONTENT#1443(   as it is in the non-PSK case discussed in the previous paragraph.),
      BREAK#1444,
    CONTENT#1445(   If the server selects an (EC)DHE group and the client did not offer a),
    CONTENT#1446(   compatible "key_share" extension in the initial ClientHello, the),
    CONTENT#1447(   server MUST respond with a HelloRetryRequest (Section 4.1.4) message.),
      BREAK#1448,
      BREAK#1449,
      BREAK#1450,
      BREAK#1451,
      BREAK#1452,
      BREAK#1453,
      BREAK#1454,
      BREAK#1455,
      BREAK#1456,
      BREAK#1458,
      BREAK#1460,
      BREAK#1461,
    CONTENT#1462(   If the server successfully selects parameters and does not require a),
    CONTENT#1463(   HelloRetryRequest, it indicates the selected parameters in the),
    CONTENT#1464(   ServerHello as follows:),
      BREAK#1465,
    CONTENT#1466(   -  If PSK is being used, then the server will send a "pre_shared_key"),
    CONTENT#1467(      extension indicating the selected key.),
      BREAK#1468,
    CONTENT#1469(   -  When (EC)DHE is in use, the server will also provide a "key_share"),
    CONTENT#1470(      extension.  If PSK is not being used, then (EC)DHE and),
    CONTENT#1471(      certificate-based authentication are always used.),
      BREAK#1472,
    CONTENT#1473(   -  When authenticating via a certificate, the server will send the),
    CONTENT#1474(      Certificate (Section 4.4.2) and CertificateVerify (Section 4.4.3)),
    CONTENT#1475(      messages.  In TLS 1.3 as defined by this document, either a PSK or),
    CONTENT#1476(      a certificate is always used, but not both.  Future documents may),
    CONTENT#1477(      define how to use them together.),
      BREAK#1478,
    CONTENT#1479(   If the server is unable to negotiate a supported set of parameters),
    CONTENT#1480(   (i.e., there is no overlap between the client and server parameters),),
    CONTENT#1481(   it MUST abort the handshake with either a "handshake_failure" or),
    CONTENT#1482(   "insufficient_security" fatal alert (see Section 6).),
      BREAK#1483,
    SECTION#1484(id=4.1.2, title=Client Hello),
      BREAK#1485,
    CONTENT#1486(   When a client first connects to a server, it is REQUIRED to send the),
    CONTENT#1487(   ClientHello as its first TLS message.  The client will also send a),
    CONTENT#1488(   ClientHello when the server has responded to its ClientHello with a),
    CONTENT#1489(   HelloRetryRequest.  In that case, the client MUST send the same),
    CONTENT#1490(   ClientHello without modification, except as follows:),
      BREAK#1491,
    CONTENT#1492(   -  If a "key_share" extension was supplied in the HelloRetryRequest,),
    CONTENT#1493(      replacing the list of shares with a list containing a single),
    CONTENT#1494(      KeyShareEntry from the indicated group.),
      BREAK#1495,
    CONTENT#1496(   -  Removing the "early_data" extension (Section 4.2.10) if one was),
    CONTENT#1497(      present.  Early data is not permitted after a HelloRetryRequest.),
      BREAK#1498,
    CONTENT#1499(   -  Including a "cookie" extension if one was provided in the),
    CONTENT#1500(      HelloRetryRequest.),
      BREAK#1501,
      BREAK#1502,
      BREAK#1503,
      BREAK#1504,
      BREAK#1505,
      BREAK#1506,
      BREAK#1507,
      BREAK#1508,
      BREAK#1509,
      BREAK#1510,
      BREAK#1511,
      BREAK#1512,
      BREAK#1514,
      BREAK#1516,
      BREAK#1517,
    CONTENT#1518(   -  Updating the "pre_shared_key" extension if present by recomputing),
    CONTENT#1519(      the "obfuscated_ticket_age" and binder values and (optionally)),
    CONTENT#1520(      removing any PSKs which are incompatible with the server's),
    CONTENT#1521(      indicated cipher suite.),
      BREAK#1522,
    CONTENT#1523(   -  Optionally adding, removing, or changing the length of the),
    CONTENT#1524(      "padding" extension [RFC7685].),
      BREAK#1525,
    CONTENT#1526(   -  Other modifications that may be allowed by an extension defined in),
    CONTENT#1527(      the future and present in the HelloRetryRequest.),
      BREAK#1528,
    CONTENT#1529(   Because TLS 1.3 forbids renegotiation, if a server has negotiated),
    CONTENT#1530(   TLS 1.3 and receives a ClientHello at any other time, it MUST),
    CONTENT#1531(   terminate the connection with an "unexpected_message" alert.),
      BREAK#1532,
    CONTENT#1533(   If a server established a TLS connection with a previous version of),
    CONTENT#1534(   TLS and receives a TLS 1.3 ClientHello in a renegotiation, it MUST),
    CONTENT#1535(   retain the previous protocol version.  In particular, it MUST NOT),
    CONTENT#1536(   negotiate TLS 1.3.),
      BREAK#1537,
    CONTENT#1538(   Structure of this message:),
      BREAK#1539,
    CONTENT#1540(      uint16 ProtocolVersion;),
    CONTENT#1541(      opaque Random[32];),
      BREAK#1542,
    CONTENT#1543(      uint8 CipherSuite[2];    /* Cryptographic suite selector */),
      BREAK#1544,
    CONTENT#1545(      struct {),
    CONTENT#1546(          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */),
    CONTENT#1547(          Random random;),
    CONTENT#1548(          opaque legacy_session_id<0..32>;),
    CONTENT#1549(          CipherSuite cipher_suites<2..2^16-2>;),
    CONTENT#1550(          opaque legacy_compression_methods<1..2^8-1>;),
    CONTENT#1551(          Extension extensions<8..2^16-1>;),
    CONTENT#1552(      } ClientHello;),
      BREAK#1553,
      BREAK#1554,
      BREAK#1555,
      BREAK#1556,
      BREAK#1557,
      BREAK#1558,
      BREAK#1559,
      BREAK#1560,
      BREAK#1561,
      BREAK#1562,
      BREAK#1563,
      BREAK#1564,
      BREAK#1565,
      BREAK#1566,
      BREAK#1567,
      BREAK#1568,
      BREAK#1570,
      BREAK#1572,
      BREAK#1573,
    CONTENT#1574(   legacy_version:  In previous versions of TLS, this field was used for),
    CONTENT#1575(      version negotiation and represented the highest version number),
    CONTENT#1576(      supported by the client.  Experience has shown that many servers),
    CONTENT#1577(      do not properly implement version negotiation, leading to "version),
    CONTENT#1578(      intolerance" in which the server rejects an otherwise acceptable),
    CONTENT#1579(      ClientHello with a version number higher than it supports.  In),
    CONTENT#1580(      TLS 1.3, the client indicates its version preferences in the),
    CONTENT#1581(      "supported_versions" extension (Section 4.2.1) and the),
    CONTENT#1582(      legacy_version field MUST be set to 0x0303, which is the version),
    CONTENT#1583(      number for TLS 1.2.  TLS 1.3 ClientHellos are identified as having),
    CONTENT#1584(      a legacy_version of 0x0303 and a supported_versions extension),
    CONTENT#1585(      present with 0x0304 as the highest version indicated therein.),
    CONTENT#1586(      (See Appendix D for details about backward compatibility.)),
      BREAK#1587,
    CONTENT#1588(   random:  32 bytes generated by a secure random number generator.  See),
    CONTENT#1589(      Appendix C for additional information.),
      BREAK#1590,
    CONTENT#1591(   legacy_session_id:  Versions of TLS before TLS 1.3 supported a),
    CONTENT#1592(      "session resumption" feature which has been merged with pre-shared),
    CONTENT#1593(      keys in this version (see Section 2.2).  A client which has a),
    CONTENT#1594(      cached session ID set by a pre-TLS 1.3 server SHOULD set this),
    CONTENT#1595(      field to that value.  In compatibility mode (see Appendix D.4),),
    CONTENT#1596(      this field MUST be non-empty, so a client not offering a),
    CONTENT#1597(      pre-TLS 1.3 session MUST generate a new 32-byte value.  This value),
    CONTENT#1598(      need not be random but SHOULD be unpredictable to avoid),
    CONTENT#1599(      implementations fixating on a specific value (also known as),
    CONTENT#1600(      ossification).  Otherwise, it MUST be set as a zero-length vector),
    CONTENT#1601(      (i.e., a zero-valued single byte length field).),
      BREAK#1602,
    CONTENT#1603(   cipher_suites:  A list of the symmetric cipher options supported by),
    CONTENT#1604(      the client, specifically the record protection algorithm),
    CONTENT#1605(      (including secret key length) and a hash to be used with HKDF, in),
    CONTENT#1606(      descending order of client preference.  Values are defined in),
    CONTENT#1607(      Appendix B.4.  If the list contains cipher suites that the server),
    CONTENT#1608(      does not recognize, support, or wish to use, the server MUST),
    CONTENT#1609(      ignore those cipher suites and process the remaining ones as),
    CONTENT#1610(      usual.  If the client is attempting a PSK key establishment, it),
    CONTENT#1611(      SHOULD advertise at least one cipher suite indicating a Hash),
    CONTENT#1612(      associated with the PSK.),
      BREAK#1613,
      BREAK#1614,
      BREAK#1615,
      BREAK#1616,
      BREAK#1617,
      BREAK#1618,
      BREAK#1619,
      BREAK#1620,
      BREAK#1621,
      BREAK#1622,
      BREAK#1623,
      BREAK#1624,
      BREAK#1626,
      BREAK#1628,
      BREAK#1629,
    CONTENT#1630(   legacy_compression_methods:  Versions of TLS before 1.3 supported),
    CONTENT#1631(      compression with the list of supported compression methods being),
    CONTENT#1632(      sent in this field.  For every TLS 1.3 ClientHello, this vector),
    CONTENT#1633(      MUST contain exactly one byte, set to zero, which corresponds to),
    CONTENT#1634(      the "null" compression method in prior versions of TLS.  If a),
    CONTENT#1635(      TLS 1.3 ClientHello is received with any other value in this),
    CONTENT#1636(      field, the server MUST abort the handshake with an),
    CONTENT#1637(      "illegal_parameter" alert.  Note that TLS 1.3 servers might),
    CONTENT#1638(      receive TLS 1.2 or prior ClientHellos which contain other),
    CONTENT#1639(      compression methods and (if negotiating such a prior version) MUST),
    CONTENT#1640(      follow the procedures for the appropriate prior version of TLS.),
      BREAK#1641,
    CONTENT#1642(   extensions:  Clients request extended functionality from servers by),
    CONTENT#1643(      sending data in the extensions field.  The actual "Extension"),
    CONTENT#1644(      format is defined in Section 4.2.  In TLS 1.3, the use of certain),
    CONTENT#1645(      extensions is mandatory, as functionality has moved into),
    CONTENT#1646(      extensions to preserve ClientHello compatibility with previous),
    CONTENT#1647(      versions of TLS.  Servers MUST ignore unrecognized extensions.),
      BREAK#1648,
    CONTENT#1649(   All versions of TLS allow an extensions field to optionally follow),
    CONTENT#1650(   the compression_methods field.  TLS 1.3 ClientHello messages always),
    CONTENT#1651(   contain extensions (minimally "supported_versions", otherwise, they),
    CONTENT#1652(   will be interpreted as TLS 1.2 ClientHello messages).  However,),
    CONTENT#1653(   TLS 1.3 servers might receive ClientHello messages without an),
    CONTENT#1654(   extensions field from prior versions of TLS.  The presence of),
    CONTENT#1655(   extensions can be detected by determining whether there are bytes),
    CONTENT#1656(   following the compression_methods field at the end of the),
    CONTENT#1657(   ClientHello.  Note that this method of detecting optional data),
    CONTENT#1658(   differs from the normal TLS method of having a variable-length field,),
    CONTENT#1659(   but it is used for compatibility with TLS before extensions were),
    CONTENT#1660(   defined.  TLS 1.3 servers will need to perform this check first and),
    CONTENT#1661(   only attempt to negotiate TLS 1.3 if the "supported_versions"),
    CONTENT#1662(   extension is present.  If negotiating a version of TLS prior to 1.3,),
    CONTENT#1663(   a server MUST check that the message either contains no data after),
    CONTENT#1664(   legacy_compression_methods or that it contains a valid extensions),
    CONTENT#1665(   block with no data following.  If not, then it MUST abort the),
    CONTENT#1666(   handshake with a "decode_error" alert.),
      BREAK#1667,
    CONTENT#1668(   In the event that a client requests additional functionality using),
    CONTENT#1669(   extensions and this functionality is not supplied by the server, the),
    CONTENT#1670(   client MAY abort the handshake.),
      BREAK#1671,
    CONTENT#1672(   After sending the ClientHello message, the client waits for a),
    CONTENT#1673(   ServerHello or HelloRetryRequest message.  If early data is in use,),
    CONTENT#1674(   the client may transmit early Application Data (Section 2.3) while),
    CONTENT#1675(   waiting for the next handshake message.),
      BREAK#1676,
      BREAK#1677,
      BREAK#1678,
      BREAK#1679,
      BREAK#1680,
      BREAK#1682,
      BREAK#1684,
      BREAK#1685,
    SECTION#1686(id=4.1.3, title=Server Hello),
      BREAK#1687,
    CONTENT#1688(   The server will send this message in response to a ClientHello),
    CONTENT#1689(   message to proceed with the handshake if it is able to negotiate an),
    CONTENT#1690(   acceptable set of handshake parameters based on the ClientHello.),
      BREAK#1691,
    CONTENT#1692(   Structure of this message:),
      BREAK#1693,
    CONTENT#1694(      struct {),
    CONTENT#1695(          ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */),
    CONTENT#1696(          Random random;),
    CONTENT#1697(          opaque legacy_session_id_echo<0..32>;),
    CONTENT#1698(          CipherSuite cipher_suite;),
    CONTENT#1699(          uint8 legacy_compression_method = 0;),
    CONTENT#1700(          Extension extensions<6..2^16-1>;),
    CONTENT#1701(      } ServerHello;),
      BREAK#1702,
    CONTENT#1703(   legacy_version:  In previous versions of TLS, this field was used for),
    CONTENT#1704(      version negotiation and represented the selected version number),
    CONTENT#1705(      for the connection.  Unfortunately, some middleboxes fail when),
    CONTENT#1706(      presented with new values.  In TLS 1.3, the TLS server indicates),
    CONTENT#1707(      its version using the "supported_versions" extension),
    CONTENT#1708(      (Section 4.2.1), and the legacy_version field MUST be set to),
    CONTENT#1709(      0x0303, which is the version number for TLS 1.2.  (See Appendix D),
    CONTENT#1710(      for details about backward compatibility.)),
      BREAK#1711,
    CONTENT#1712(   random:  32 bytes generated by a secure random number generator.  See),
    CONTENT#1713(      Appendix C for additional information.  The last 8 bytes MUST be),
    CONTENT#1714(      overwritten as described below if negotiating TLS 1.2 or TLS 1.1,),
    CONTENT#1715(      but the remaining bytes MUST be random.  This structure is),
    CONTENT#1716(      generated by the server and MUST be generated independently of the),
    CONTENT#1717(      ClientHello.random.),
      BREAK#1718,
    CONTENT#1719(   legacy_session_id_echo:  The contents of the client's),
    CONTENT#1720(      legacy_session_id field.  Note that this field is echoed even if),
    CONTENT#1721(      the client's value corresponded to a cached pre-TLS 1.3 session),
    CONTENT#1722(      which the server has chosen not to resume.  A client which),
    CONTENT#1723(      receives a legacy_session_id_echo field that does not match what),
    CONTENT#1724(      it sent in the ClientHello MUST abort the handshake with an),
    CONTENT#1725(      "illegal_parameter" alert.),
      BREAK#1726,
    CONTENT#1727(   cipher_suite:  The single cipher suite selected by the server from),
    CONTENT#1728(      the list in ClientHello.cipher_suites.  A client which receives a),
    CONTENT#1729(      cipher suite that was not offered MUST abort the handshake with an),
    CONTENT#1730(      "illegal_parameter" alert.),
      BREAK#1731,
    CONTENT#1732(   legacy_compression_method:  A single byte which MUST have the),
    CONTENT#1733(      value 0.),
      BREAK#1734,
      BREAK#1735,
      BREAK#1736,
      BREAK#1738,
      BREAK#1740,
      BREAK#1741,
    CONTENT#1742(   extensions:  A list of extensions.  The ServerHello MUST only include),
    CONTENT#1743(      extensions which are required to establish the cryptographic),
    CONTENT#1744(      context and negotiate the protocol version.  All TLS 1.3),
    CONTENT#1745(      ServerHello messages MUST contain the "supported_versions"),
    CONTENT#1746(      extension.  Current ServerHello messages additionally contain),
    CONTENT#1747(      either the "pre_shared_key" extension or the "key_share"),
    CONTENT#1748(      extension, or both (when using a PSK with (EC)DHE key),
    CONTENT#1749(      establishment).  Other extensions (see Section 4.2) are sent),
    CONTENT#1750(      separately in the EncryptedExtensions message.),
      BREAK#1751,
    CONTENT#1752(   For reasons of backward compatibility with middleboxes (see),
    CONTENT#1753(   Appendix D.4), the HelloRetryRequest message uses the same structure),
    CONTENT#1754(   as the ServerHello, but with Random set to the special value of the),
    CONTENT#1755(   SHA-256 of "HelloRetryRequest":),
      BREAK#1756,
    CONTENT#1757(     CF 21 AD 74 E5 9A 61 11 BE 1D 8C 02 1E 65 B8 91),
    CONTENT#1758(     C2 A2 11 16 7A BB 8C 5E 07 9E 09 E2 C8 A8 33 9C),
      BREAK#1759,
    CONTENT#1760(   Upon receiving a message with type server_hello, implementations MUST),
    CONTENT#1761(   first examine the Random value and, if it matches this value, process),
    CONTENT#1762(   it as described in Section 4.1.4).),
      BREAK#1763,
    CONTENT#1764(   TLS 1.3 has a downgrade protection mechanism embedded in the server's),
    CONTENT#1765(   random value.  TLS 1.3 servers which negotiate TLS 1.2 or below in),
    CONTENT#1766(   response to a ClientHello MUST set the last 8 bytes of their Random),
    CONTENT#1767(   value specially in their ServerHello.),
      BREAK#1768,
    CONTENT#1769(   If negotiating TLS 1.2, TLS 1.3 servers MUST set the last 8 bytes of),
    CONTENT#1770(   their Random value to the bytes:),
      BREAK#1771,
    CONTENT#1772(     44 4F 57 4E 47 52 44 01),
      BREAK#1773,
    CONTENT#1774(   If negotiating TLS 1.1 or below, TLS 1.3 servers MUST, and TLS 1.2),
    CONTENT#1775(   servers SHOULD, set the last 8 bytes of their ServerHello.Random),
    CONTENT#1776(   value to the bytes:),
      BREAK#1777,
    CONTENT#1778(     44 4F 57 4E 47 52 44 00),
      BREAK#1779,
    CONTENT#1780(   TLS 1.3 clients receiving a ServerHello indicating TLS 1.2 or below),
    CONTENT#1781(   MUST check that the last 8 bytes are not equal to either of these),
    CONTENT#1782(   values.  TLS 1.2 clients SHOULD also check that the last 8 bytes are),
    CONTENT#1783(   not equal to the second value if the ServerHello indicates TLS 1.1 or),
    CONTENT#1784(   below.  If a match is found, the client MUST abort the handshake with),
    CONTENT#1785(   an "illegal_parameter" alert.  This mechanism provides limited),
    CONTENT#1786(   protection against downgrade attacks over and above what is provided),
    CONTENT#1787(   by the Finished exchange: because the ServerKeyExchange, a message),
    CONTENT#1788(   present in TLS 1.2 and below, includes a signature over both random),
    CONTENT#1789(   values, it is not possible for an active attacker to modify the),
      BREAK#1790,
      BREAK#1791,
      BREAK#1792,
      BREAK#1794,
      BREAK#1796,
      BREAK#1797,
    CONTENT#1798(   random values without detection as long as ephemeral ciphers are),
    CONTENT#1799(   used.  It does not provide downgrade protection when static RSA),
    CONTENT#1800(   is used.),
      BREAK#1801,
    CONTENT#1802(   Note: This is a change from [RFC5246], so in practice many TLS 1.2),
    CONTENT#1803(   clients and servers will not behave as specified above.),
      BREAK#1804,
    CONTENT#1805(   A legacy TLS client performing renegotiation with TLS 1.2 or prior),
    CONTENT#1806(   and which receives a TLS 1.3 ServerHello during renegotiation MUST),
    CONTENT#1807(   abort the handshake with a "protocol_version" alert.  Note that),
    CONTENT#1808(   renegotiation is not possible when TLS 1.3 has been negotiated.),
      BREAK#1809,
    SECTION#1810(id=4.1.4, title=Hello Retry Request),
      BREAK#1811,
    CONTENT#1812(   The server will send this message in response to a ClientHello),
    CONTENT#1813(   message if it is able to find an acceptable set of parameters but the),
    CONTENT#1814(   ClientHello does not contain sufficient information to proceed with),
    CONTENT#1815(   the handshake.  As discussed in Section 4.1.3, the HelloRetryRequest),
    CONTENT#1816(   has the same format as a ServerHello message, and the legacy_version,),
    CONTENT#1817(   legacy_session_id_echo, cipher_suite, and legacy_compression_method),
    CONTENT#1818(   fields have the same meaning.  However, for convenience we discuss),
    CONTENT#1819(   "HelloRetryRequest" throughout this document as if it were a distinct),
    CONTENT#1820(   message.),
      BREAK#1821,
    CONTENT#1822(   The server's extensions MUST contain "supported_versions".),
    CONTENT#1823(   Additionally, it SHOULD contain the minimal set of extensions),
    CONTENT#1824(   necessary for the client to generate a correct ClientHello pair.  As),
    CONTENT#1825(   with the ServerHello, a HelloRetryRequest MUST NOT contain any),
    CONTENT#1826(   extensions that were not first offered by the client in its),
    CONTENT#1827(   ClientHello, with the exception of optionally the "cookie" (see),
    CONTENT#1828(   Section 4.2.2) extension.),
      BREAK#1829,
    CONTENT#1830(   Upon receipt of a HelloRetryRequest, the client MUST check the),
    CONTENT#1831(   legacy_version, legacy_session_id_echo, cipher_suite, and),
    CONTENT#1832(   legacy_compression_method as specified in Section 4.1.3 and then),
    CONTENT#1833(   process the extensions, starting with determining the version using),
    CONTENT#1834(   "supported_versions".  Clients MUST abort the handshake with an),
    CONTENT#1835(   "illegal_parameter" alert if the HelloRetryRequest would not result),
    CONTENT#1836(   in any change in the ClientHello.  If a client receives a second),
    CONTENT#1837(   HelloRetryRequest in the same connection (i.e., where the ClientHello),
    CONTENT#1838(   was itself in response to a HelloRetryRequest), it MUST abort the),
    CONTENT#1839(   handshake with an "unexpected_message" alert.),
      BREAK#1840,
      BREAK#1841,
      BREAK#1842,
      BREAK#1843,
      BREAK#1844,
      BREAK#1845,
      BREAK#1846,
      BREAK#1847,
      BREAK#1848,
      BREAK#1850,
      BREAK#1852,
      BREAK#1853,
    CONTENT#1854(   Otherwise, the client MUST process all extensions in the),
    CONTENT#1855(   HelloRetryRequest and send a second updated ClientHello.  The),
    CONTENT#1856(   HelloRetryRequest extensions defined in this specification are:),
      BREAK#1857,
    CONTENT#1858(   -  supported_versions (see Section 4.2.1)),
      BREAK#1859,
    CONTENT#1860(   -  cookie (see Section 4.2.2)),
      BREAK#1861,
    CONTENT#1862(   -  key_share (see Section 4.2.8)),
      BREAK#1863,
    CONTENT#1864(   A client which receives a cipher suite that was not offered MUST),
    CONTENT#1865(   abort the handshake.  Servers MUST ensure that they negotiate the),
    CONTENT#1866(   same cipher suite when receiving a conformant updated ClientHello (if),
    CONTENT#1867(   the server selects the cipher suite as the first step in the),
    CONTENT#1868(   negotiation, then this will happen automatically).  Upon receiving),
    CONTENT#1869(   the ServerHello, clients MUST check that the cipher suite supplied in),
    CONTENT#1870(   the ServerHello is the same as that in the HelloRetryRequest and),
    CONTENT#1871(   otherwise abort the handshake with an "illegal_parameter" alert.),
      BREAK#1872,
    CONTENT#1873(   In addition, in its updated ClientHello, the client SHOULD NOT offer),
    CONTENT#1874(   any pre-shared keys associated with a hash other than that of the),
    CONTENT#1875(   selected cipher suite.  This allows the client to avoid having to),
    CONTENT#1876(   compute partial hash transcripts for multiple hashes in the second),
    CONTENT#1877(   ClientHello.),
      BREAK#1878,
    CONTENT#1879(   The value of selected_version in the HelloRetryRequest),
    CONTENT#1880(   "supported_versions" extension MUST be retained in the ServerHello,),
    CONTENT#1881(   and a client MUST abort the handshake with an "illegal_parameter"),
    CONTENT#1882(   alert if the value changes.),
      BREAK#1883,
      BREAK#1884,
      BREAK#1885,
      BREAK#1886,
      BREAK#1887,
      BREAK#1888,
      BREAK#1889,
      BREAK#1890,
      BREAK#1891,
      BREAK#1892,
      BREAK#1893,
      BREAK#1894,
      BREAK#1895,
      BREAK#1896,
      BREAK#1897,
      BREAK#1898,
      BREAK#1899,
      BREAK#1900,
      BREAK#1901,
      BREAK#1902,
      BREAK#1903,
      BREAK#1904,
      BREAK#1906,
      BREAK#1908,
      BREAK#1909,
    SECTION#1910(id=4.2, title=Extensions),
      BREAK#1911,
    CONTENT#1912(   A number of TLS messages contain tag-length-value encoded extensions),
    CONTENT#1913(   structures.),
      BREAK#1914,
    CONTENT#1915(    struct {),
    CONTENT#1916(        ExtensionType extension_type;),
    CONTENT#1917(        opaque extension_data<0..2^16-1>;),
    CONTENT#1918(    } Extension;),
      BREAK#1919,
    CONTENT#1920(    enum {),
    CONTENT#1921(        server_name(0),                             /* RFC 6066 */),
    CONTENT#1922(        max_fragment_length(1),                     /* RFC 6066 */),
    CONTENT#1923(        status_request(5),                          /* RFC 6066 */),
    CONTENT#1924(        supported_groups(10),                       /* RFC 8422, 7919 */),
    CONTENT#1925(        signature_algorithms(13),                   /* RFC 8446 */),
    CONTENT#1926(        use_srtp(14),                               /* RFC 5764 */),
    CONTENT#1927(        heartbeat(15),                              /* RFC 6520 */),
    CONTENT#1928(        application_layer_protocol_negotiation(16), /* RFC 7301 */),
    CONTENT#1929(        signed_certificate_timestamp(18),           /* RFC 6962 */),
    CONTENT#1930(        client_certificate_type(19),                /* RFC 7250 */),
    CONTENT#1931(        server_certificate_type(20),                /* RFC 7250 */),
    CONTENT#1932(        padding(21),                                /* RFC 7685 */),
    CONTENT#1933(        pre_shared_key(41),                         /* RFC 8446 */),
    CONTENT#1934(        early_data(42),                             /* RFC 8446 */),
    CONTENT#1935(        supported_versions(43),                     /* RFC 8446 */),
    CONTENT#1936(        cookie(44),                                 /* RFC 8446 */),
    CONTENT#1937(        psk_key_exchange_modes(45),                 /* RFC 8446 */),
    CONTENT#1938(        certificate_authorities(47),                /* RFC 8446 */),
    CONTENT#1939(        oid_filters(48),                            /* RFC 8446 */),
    CONTENT#1940(        post_handshake_auth(49),                    /* RFC 8446 */),
    CONTENT#1941(        signature_algorithms_cert(50),              /* RFC 8446 */),
    CONTENT#1942(        key_share(51),                              /* RFC 8446 */),
    CONTENT#1943(        (65535)),
    CONTENT#1944(    } ExtensionType;),
      BREAK#1945,
      BREAK#1946,
      BREAK#1947,
      BREAK#1948,
      BREAK#1949,
      BREAK#1950,
      BREAK#1951,
      BREAK#1952,
      BREAK#1953,
      BREAK#1954,
      BREAK#1955,
      BREAK#1956,
      BREAK#1957,
      BREAK#1958,
      BREAK#1959,
      BREAK#1960,
      BREAK#1962,
      BREAK#1964,
      BREAK#1965,
    CONTENT#1966(   Here:),
      BREAK#1967,
    CONTENT#1968(   -  "extension_type" identifies the particular extension type.),
      BREAK#1969,
    CONTENT#1970(   -  "extension_data" contains information specific to the particular),
    CONTENT#1971(      extension type.),
      BREAK#1972,
    CONTENT#1973(   The list of extension types is maintained by IANA as described in),
    CONTENT#1974(   Section 11.),
      BREAK#1975,
    CONTENT#1976(   Extensions are generally structured in a request/response fashion,),
    CONTENT#1977(   though some extensions are just indications with no corresponding),
    CONTENT#1978(   response.  The client sends its extension requests in the ClientHello),
    CONTENT#1979(   message, and the server sends its extension responses in the),
    CONTENT#1980(   ServerHello, EncryptedExtensions, HelloRetryRequest, and Certificate),
    CONTENT#1981(   messages.  The server sends extension requests in the),
    CONTENT#1982(   CertificateRequest message which a client MAY respond to with a),
    CONTENT#1983(   Certificate message.  The server MAY also send unsolicited extensions),
    CONTENT#1984(   in the NewSessionTicket, though the client does not respond directly),
    CONTENT#1985(   to these.),
      BREAK#1986,
    CONTENT#1987(   Implementations MUST NOT send extension responses if the remote),
    CONTENT#1988(   endpoint did not send the corresponding extension requests, with the),
    CONTENT#1989(   exception of the "cookie" extension in the HelloRetryRequest.  Upon),
    CONTENT#1990(   receiving such an extension, an endpoint MUST abort the handshake),
    CONTENT#1991(   with an "unsupported_extension" alert.),
      BREAK#1992,
    CONTENT#1993(   The table below indicates the messages where a given extension may),
    CONTENT#1994(   appear, using the following notation: CH (ClientHello),),
    CONTENT#1995(   SH (ServerHello), EE (EncryptedExtensions), CT (Certificate),),
    CONTENT#1996(   CR (CertificateRequest), NST (NewSessionTicket), and),
    CONTENT#1997(   HRR (HelloRetryRequest).  If an implementation receives an extension),
    CONTENT#1998(   which it recognizes and which is not specified for the message in),
    CONTENT#1999(   which it appears, it MUST abort the handshake with an),
    CONTENT#2000(   "illegal_parameter" alert.),
      BREAK#2001,
      BREAK#2002,
      BREAK#2003,
      BREAK#2004,
      BREAK#2005,
      BREAK#2006,
      BREAK#2007,
      BREAK#2008,
      BREAK#2009,
      BREAK#2010,
      BREAK#2011,
      BREAK#2012,
      BREAK#2013,
      BREAK#2014,
      BREAK#2015,
      BREAK#2016,
      BREAK#2018,
      BREAK#2020,
      BREAK#2021,
    CONTENT#2022(   +--------------------------------------------------+-------------+),
    CONTENT#2023(   | Extension                                        |     TLS 1.3 |),
    CONTENT#2024(   +--------------------------------------------------+-------------+),
    CONTENT#2025(   | server_name [RFC6066]                            |      CH, EE |),
    CONTENT#2026(   |                                                  |             |),
    CONTENT#2027(   | max_fragment_length [RFC6066]                    |      CH, EE |),
    CONTENT#2028(   |                                                  |             |),
    CONTENT#2029(   | status_request [RFC6066]                         |  CH, CR, CT |),
    CONTENT#2030(   |                                                  |             |),
    CONTENT#2031(   | supported_groups [RFC7919]                       |      CH, EE |),
    CONTENT#2032(   |                                                  |             |),
    CONTENT#2033(   | signature_algorithms (RFC 8446)                  |      CH, CR |),
    CONTENT#2034(   |                                                  |             |),
    CONTENT#2035(   | use_srtp [RFC5764]                               |      CH, EE |),
    CONTENT#2036(   |                                                  |             |),
    CONTENT#2037(   | heartbeat [RFC6520]                              |      CH, EE |),
    CONTENT#2038(   |                                                  |             |),
    CONTENT#2039(   | application_layer_protocol_negotiation [RFC7301] |      CH, EE |),
    CONTENT#2040(   |                                                  |             |),
    CONTENT#2041(   | signed_certificate_timestamp [RFC6962]           |  CH, CR, CT |),
    CONTENT#2042(   |                                                  |             |),
    CONTENT#2043(   | client_certificate_type [RFC7250]                |      CH, EE |),
    CONTENT#2044(   |                                                  |             |),
    CONTENT#2045(   | server_certificate_type [RFC7250]                |      CH, EE |),
    CONTENT#2046(   |                                                  |             |),
    CONTENT#2047(   | padding [RFC7685]                                |          CH |),
    CONTENT#2048(   |                                                  |             |),
    CONTENT#2049(   | key_share (RFC 8446)                             | CH, SH, HRR |),
    CONTENT#2050(   |                                                  |             |),
    CONTENT#2051(   | pre_shared_key (RFC 8446)                        |      CH, SH |),
    CONTENT#2052(   |                                                  |             |),
    CONTENT#2053(   | psk_key_exchange_modes (RFC 8446)                |          CH |),
    CONTENT#2054(   |                                                  |             |),
    CONTENT#2055(   | early_data (RFC 8446)                            | CH, EE, NST |),
    CONTENT#2056(   |                                                  |             |),
    CONTENT#2057(   | cookie (RFC 8446)                                |     CH, HRR |),
    CONTENT#2058(   |                                                  |             |),
    CONTENT#2059(   | supported_versions (RFC 8446)                    | CH, SH, HRR |),
    CONTENT#2060(   |                                                  |             |),
    CONTENT#2061(   | certificate_authorities (RFC 8446)               |      CH, CR |),
    CONTENT#2062(   |                                                  |             |),
    CONTENT#2063(   | oid_filters (RFC 8446)                           |          CR |),
    CONTENT#2064(   |                                                  |             |),
    CONTENT#2065(   | post_handshake_auth (RFC 8446)                   |          CH |),
    CONTENT#2066(   |                                                  |             |),
    CONTENT#2067(   | signature_algorithms_cert (RFC 8446)             |      CH, CR |),
    CONTENT#2068(   +--------------------------------------------------+-------------+),
      BREAK#2069,
      BREAK#2070,
      BREAK#2071,
      BREAK#2072,
      BREAK#2074,
      BREAK#2076,
      BREAK#2077,
    CONTENT#2078(   When multiple extensions of different types are present, the),
    CONTENT#2079(   extensions MAY appear in any order, with the exception of),
    CONTENT#2080(   "pre_shared_key" (Section 4.2.11) which MUST be the last extension in),
    CONTENT#2081(   the ClientHello (but can appear anywhere in the ServerHello),
    CONTENT#2082(   extensions block).  There MUST NOT be more than one extension of the),
    CONTENT#2083(   same type in a given extension block.),
      BREAK#2084,
    CONTENT#2085(   In TLS 1.3, unlike TLS 1.2, extensions are negotiated for each),
    CONTENT#2086(   handshake even when in resumption-PSK mode.  However, 0-RTT),
    CONTENT#2087(   parameters are those negotiated in the previous handshake; mismatches),
    CONTENT#2088(   may require rejecting 0-RTT (see Section 4.2.10).),
      BREAK#2089,
    CONTENT#2090(   There are subtle (and not so subtle) interactions that may occur in),
    CONTENT#2091(   this protocol between new features and existing features which may),
    CONTENT#2092(   result in a significant reduction in overall security.  The following),
    CONTENT#2093(   considerations should be taken into account when designing new),
    CONTENT#2094(   extensions:),
      BREAK#2095,
    CONTENT#2096(   -  Some cases where a server does not agree to an extension are error),
    CONTENT#2097(      conditions (e.g., the handshake cannot continue), and some are),
    CONTENT#2098(      simply refusals to support particular features.  In general, error),
    CONTENT#2099(      alerts should be used for the former and a field in the server),
    CONTENT#2100(      extension response for the latter.),
      BREAK#2101,
    CONTENT#2102(   -  Extensions should, as far as possible, be designed to prevent any),
    CONTENT#2103(      attack that forces use (or non-use) of a particular feature by),
    CONTENT#2104(      manipulation of handshake messages.  This principle should be),
    CONTENT#2105(      followed regardless of whether the feature is believed to cause a),
    CONTENT#2106(      security problem.  Often the fact that the extension fields are),
    CONTENT#2107(      included in the inputs to the Finished message hashes will be),
    CONTENT#2108(      sufficient, but extreme care is needed when the extension changes),
    CONTENT#2109(      the meaning of messages sent in the handshake phase.  Designers),
    CONTENT#2110(      and implementors should be aware of the fact that until the),
    CONTENT#2111(      handshake has been authenticated, active attackers can modify),
    CONTENT#2112(      messages and insert, remove, or replace extensions.),
      BREAK#2113,
      BREAK#2114,
      BREAK#2115,
      BREAK#2116,
      BREAK#2117,
      BREAK#2118,
      BREAK#2119,
      BREAK#2120,
      BREAK#2121,
      BREAK#2122,
      BREAK#2123,
      BREAK#2124,
      BREAK#2125,
      BREAK#2126,
      BREAK#2127,
      BREAK#2128,
      BREAK#2130,
      BREAK#2132,
      BREAK#2133,
    SECTION#2134(id=4.2.1, title=Supported Versions),
      BREAK#2135,
    CONTENT#2136(      struct {),
    CONTENT#2137(          select (Handshake.msg_type) {),
    CONTENT#2138(              case client_hello:),
    CONTENT#2139(                   ProtocolVersion versions<2..254>;),
      BREAK#2140,
    CONTENT#2141(              case server_hello: /* and HelloRetryRequest */),
    CONTENT#2142(                   ProtocolVersion selected_version;),
    CONTENT#2143(          };),
    CONTENT#2144(      } SupportedVersions;),
      BREAK#2145,
    CONTENT#2146(   The "supported_versions" extension is used by the client to indicate),
    CONTENT#2147(   which versions of TLS it supports and by the server to indicate which),
    CONTENT#2148(   version it is using.  The extension contains a list of supported),
    CONTENT#2149(   versions in preference order, with the most preferred version first.),
    CONTENT#2150(   Implementations of this specification MUST send this extension in the),
    CONTENT#2151(   ClientHello containing all versions of TLS which they are prepared to),
    CONTENT#2152(   negotiate (for this specification, that means minimally 0x0304, but),
    CONTENT#2153(   if previous versions of TLS are allowed to be negotiated, they MUST),
    CONTENT#2154(   be present as well).),
      BREAK#2155,
    CONTENT#2156(   If this extension is not present, servers which are compliant with),
    CONTENT#2157(   this specification and which also support TLS 1.2 MUST negotiate),
    CONTENT#2158(   TLS 1.2 or prior as specified in [RFC5246], even if),
    CONTENT#2159(   ClientHello.legacy_version is 0x0304 or later.  Servers MAY abort the),
    CONTENT#2160(   handshake upon receiving a ClientHello with legacy_version 0x0304 or),
    CONTENT#2161(   later.),
      BREAK#2162,
    CONTENT#2163(   If this extension is present in the ClientHello, servers MUST NOT use),
    CONTENT#2164(   the ClientHello.legacy_version value for version negotiation and MUST),
    CONTENT#2165(   use only the "supported_versions" extension to determine client),
    CONTENT#2166(   preferences.  Servers MUST only select a version of TLS present in),
    CONTENT#2167(   that extension and MUST ignore any unknown versions that are present),
    CONTENT#2168(   in that extension.  Note that this mechanism makes it possible to),
    CONTENT#2169(   negotiate a version prior to TLS 1.2 if one side supports a sparse),
    CONTENT#2170(   range.  Implementations of TLS 1.3 which choose to support prior),
    CONTENT#2171(   versions of TLS SHOULD support TLS 1.2.  Servers MUST be prepared to),
    CONTENT#2172(   receive ClientHellos that include this extension but do not include),
    CONTENT#2173(   0x0304 in the list of versions.),
      BREAK#2174,
    CONTENT#2175(   A server which negotiates a version of TLS prior to TLS 1.3 MUST set),
    CONTENT#2176(   ServerHello.version and MUST NOT send the "supported_versions"),
    CONTENT#2177(   extension.  A server which negotiates TLS 1.3 MUST respond by sending),
    CONTENT#2178(   a "supported_versions" extension containing the selected version),
    CONTENT#2179(   value (0x0304).  It MUST set the ServerHello.legacy_version field to),
    CONTENT#2180(   0x0303 (TLS 1.2).  Clients MUST check for this extension prior to),
    CONTENT#2181(   processing the rest of the ServerHello (although they will have to),
      BREAK#2182,
      BREAK#2183,
      BREAK#2184,
      BREAK#2186,
      BREAK#2188,
      BREAK#2189,
    CONTENT#2190(   parse the ServerHello in order to read the extension).  If this),
    CONTENT#2191(   extension is present, clients MUST ignore the),
    CONTENT#2192(   ServerHello.legacy_version value and MUST use only the),
    CONTENT#2193(   "supported_versions" extension to determine the selected version.  If),
    CONTENT#2194(   the "supported_versions" extension in the ServerHello contains a),
    CONTENT#2195(   version not offered by the client or contains a version prior to),
    CONTENT#2196(   TLS 1.3, the client MUST abort the handshake with an),
    CONTENT#2197(   "illegal_parameter" alert.),
      BREAK#2198,
    SECTION#2199(id=4.2.2, title=Cookie),
      BREAK#2200,
    CONTENT#2201(      struct {),
    CONTENT#2202(          opaque cookie<1..2^16-1>;),
    CONTENT#2203(      } Cookie;),
      BREAK#2204,
    CONTENT#2205(   Cookies serve two primary purposes:),
      BREAK#2206,
    CONTENT#2207(   -  Allowing the server to force the client to demonstrate),
    CONTENT#2208(      reachability at their apparent network address (thus providing a),
    CONTENT#2209(      measure of DoS protection).  This is primarily useful for),
    CONTENT#2210(      non-connection-oriented transports (see [RFC6347] for an example),
    CONTENT#2211(      of this).),
      BREAK#2212,
    CONTENT#2213(   -  Allowing the server to offload state to the client, thus allowing),
    CONTENT#2214(      it to send a HelloRetryRequest without storing any state.  The),
    CONTENT#2215(      server can do this by storing the hash of the ClientHello in the),
    CONTENT#2216(      HelloRetryRequest cookie (protected with some suitable integrity),
    CONTENT#2217(      protection algorithm).),
      BREAK#2218,
    CONTENT#2219(   When sending a HelloRetryRequest, the server MAY provide a "cookie"),
    CONTENT#2220(   extension to the client (this is an exception to the usual rule that),
    CONTENT#2221(   the only extensions that may be sent are those that appear in the),
    CONTENT#2222(   ClientHello).  When sending the new ClientHello, the client MUST copy),
    CONTENT#2223(   the contents of the extension received in the HelloRetryRequest into),
    CONTENT#2224(   a "cookie" extension in the new ClientHello.  Clients MUST NOT use),
    CONTENT#2225(   cookies in their initial ClientHello in subsequent connections.),
      BREAK#2226,
    CONTENT#2227(   When a server is operating statelessly, it may receive an unprotected),
    CONTENT#2228(   record of type change_cipher_spec between the first and second),
    CONTENT#2229(   ClientHello (see Section 5).  Since the server is not storing any),
    CONTENT#2230(   state, this will appear as if it were the first message to be),
    CONTENT#2231(   received.  Servers operating statelessly MUST ignore these records.),
      BREAK#2232,
      BREAK#2233,
      BREAK#2234,
      BREAK#2235,
      BREAK#2236,
      BREAK#2237,
      BREAK#2238,
      BREAK#2239,
      BREAK#2240,
      BREAK#2242,
      BREAK#2244,
      BREAK#2245,
    SECTION#2246(id=4.2.3, title=Signature Algorithms),
      BREAK#2247,
    CONTENT#2248(   TLS 1.3 provides two extensions for indicating which signature),
    CONTENT#2249(   algorithms may be used in digital signatures.  The),
    CONTENT#2250(   "signature_algorithms_cert" extension applies to signatures in),
    CONTENT#2251(   certificates, and the "signature_algorithms" extension, which),
    CONTENT#2252(   originally appeared in TLS 1.2, applies to signatures in),
    CONTENT#2253(   CertificateVerify messages.  The keys found in certificates MUST also),
    CONTENT#2254(   be of appropriate type for the signature algorithms they are used),
    CONTENT#2255(   with.  This is a particular issue for RSA keys and PSS signatures, as),
    CONTENT#2256(   described below.  If no "signature_algorithms_cert" extension is),
    CONTENT#2257(   present, then the "signature_algorithms" extension also applies to),
    CONTENT#2258(   signatures appearing in certificates.  Clients which desire the),
    CONTENT#2259(   server to authenticate itself via a certificate MUST send the),
    CONTENT#2260(   "signature_algorithms" extension.  If a server is authenticating via),
    CONTENT#2261(   a certificate and the client has not sent a "signature_algorithms"),
    CONTENT#2262(   extension, then the server MUST abort the handshake with a),
    CONTENT#2263(   "missing_extension" alert (see Section 9.2).),
      BREAK#2264,
    CONTENT#2265(   The "signature_algorithms_cert" extension was added to allow),
    CONTENT#2266(   implementations which supported different sets of algorithms for),
    CONTENT#2267(   certificates and in TLS itself to clearly signal their capabilities.),
    CONTENT#2268(   TLS 1.2 implementations SHOULD also process this extension.),
    CONTENT#2269(   Implementations which have the same policy in both cases MAY omit the),
    CONTENT#2270(   "signature_algorithms_cert" extension.),
      BREAK#2271,
      BREAK#2272,
      BREAK#2273,
      BREAK#2274,
      BREAK#2275,
      BREAK#2276,
      BREAK#2277,
      BREAK#2278,
      BREAK#2279,
      BREAK#2280,
      BREAK#2281,
      BREAK#2282,
      BREAK#2283,
      BREAK#2284,
      BREAK#2285,
      BREAK#2286,
      BREAK#2287,
      BREAK#2288,
      BREAK#2289,
      BREAK#2290,
      BREAK#2291,
      BREAK#2292,
      BREAK#2293,
      BREAK#2294,
      BREAK#2295,
      BREAK#2296,
      BREAK#2298,
      BREAK#2300,
      BREAK#2301,
    CONTENT#2302(   The "extension_data" field of these extensions contains a),
    CONTENT#2303(   SignatureSchemeList value:),
      BREAK#2304,
    CONTENT#2305(      enum {),
    CONTENT#2306(          /* RSASSA-PKCS1-v1_5 algorithms */),
    CONTENT#2307(          rsa_pkcs1_sha256(0x0401),),
    CONTENT#2308(          rsa_pkcs1_sha384(0x0501),),
    CONTENT#2309(          rsa_pkcs1_sha512(0x0601),),
      BREAK#2310,
    CONTENT#2311(          /* ECDSA algorithms */),
    CONTENT#2312(          ecdsa_secp256r1_sha256(0x0403),),
    CONTENT#2313(          ecdsa_secp384r1_sha384(0x0503),),
    CONTENT#2314(          ecdsa_secp521r1_sha512(0x0603),),
      BREAK#2315,
    CONTENT#2316(          /* RSASSA-PSS algorithms with public key OID rsaEncryption */),
    CONTENT#2317(          rsa_pss_rsae_sha256(0x0804),),
    CONTENT#2318(          rsa_pss_rsae_sha384(0x0805),),
    CONTENT#2319(          rsa_pss_rsae_sha512(0x0806),),
      BREAK#2320,
    CONTENT#2321(          /* EdDSA algorithms */),
    CONTENT#2322(          ed25519(0x0807),),
    CONTENT#2323(          ed448(0x0808),),
      BREAK#2324,
    CONTENT#2325(          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */),
    CONTENT#2326(          rsa_pss_pss_sha256(0x0809),),
    CONTENT#2327(          rsa_pss_pss_sha384(0x080a),),
    CONTENT#2328(          rsa_pss_pss_sha512(0x080b),),
      BREAK#2329,
    CONTENT#2330(          /* Legacy algorithms */),
    CONTENT#2331(          rsa_pkcs1_sha1(0x0201),),
    CONTENT#2332(          ecdsa_sha1(0x0203),),
      BREAK#2333,
    CONTENT#2334(          /* Reserved Code Points */),
    CONTENT#2335(          private_use(0xFE00..0xFFFF),),
    CONTENT#2336(          (0xFFFF)),
    CONTENT#2337(      } SignatureScheme;),
      BREAK#2338,
    CONTENT#2339(      struct {),
    CONTENT#2340(          SignatureScheme supported_signature_algorithms<2..2^16-2>;),
    CONTENT#2341(      } SignatureSchemeList;),
      BREAK#2342,
    CONTENT#2343(   Note: This enum is named "SignatureScheme" because there is already a),
    CONTENT#2344(   "SignatureAlgorithm" type in TLS 1.2, which this replaces.  We use),
    CONTENT#2345(   the term "signature algorithm" throughout the text.),
      BREAK#2346,
      BREAK#2347,
      BREAK#2348,
      BREAK#2349,
      BREAK#2350,
      BREAK#2351,
      BREAK#2352,
      BREAK#2354,
      BREAK#2356,
      BREAK#2357,
    CONTENT#2358(   Each SignatureScheme value lists a single signature algorithm that),
    CONTENT#2359(   the client is willing to verify.  The values are indicated in),
    CONTENT#2360(   descending order of preference.  Note that a signature algorithm),
    CONTENT#2361(   takes as input an arbitrary-length message, rather than a digest.),
    CONTENT#2362(   Algorithms which traditionally act on a digest should be defined in),
    CONTENT#2363(   TLS to first hash the input with a specified hash algorithm and then),
    CONTENT#2364(   proceed as usual.  The code point groups listed above have the),
    CONTENT#2365(   following meanings:),
      BREAK#2366,
    CONTENT#2367(   RSASSA-PKCS1-v1_5 algorithms:  Indicates a signature algorithm using),
    CONTENT#2368(      RSASSA-PKCS1-v1_5 [RFC8017] with the corresponding hash algorithm),
    CONTENT#2369(      as defined in [SHS].  These values refer solely to signatures),
    CONTENT#2370(      which appear in certificates (see Section 4.4.2.2) and are not),
    CONTENT#2371(      defined for use in signed TLS handshake messages, although they),
    CONTENT#2372(      MAY appear in "signature_algorithms" and),
    CONTENT#2373(      "signature_algorithms_cert" for backward compatibility with),
    CONTENT#2374(      TLS 1.2.),
      BREAK#2375,
    CONTENT#2376(   ECDSA algorithms:  Indicates a signature algorithm using ECDSA),
    CONTENT#2377(      [ECDSA], the corresponding curve as defined in ANSI X9.62 [ECDSA]),
    CONTENT#2378(      and FIPS 186-4 [DSS], and the corresponding hash algorithm as),
    CONTENT#2379(      defined in [SHS].  The signature is represented as a DER-encoded),
    CONTENT#2380(      [X690] ECDSA-Sig-Value structure.),
      BREAK#2381,
    CONTENT#2382(   RSASSA-PSS RSAE algorithms:  Indicates a signature algorithm using),
    CONTENT#2383(      RSASSA-PSS [RFC8017] with mask generation function 1.  The digest),
    CONTENT#2384(      used in the mask generation function and the digest being signed),
    CONTENT#2385(      are both the corresponding hash algorithm as defined in [SHS].),
    CONTENT#2386(      The length of the Salt MUST be equal to the length of the output),
    CONTENT#2387(      of the digest algorithm.  If the public key is carried in an X.509),
    CONTENT#2388(      certificate, it MUST use the rsaEncryption OID [RFC5280].),
      BREAK#2389,
    CONTENT#2390(   EdDSA algorithms:  Indicates a signature algorithm using EdDSA as),
    CONTENT#2391(      defined in [RFC8032] or its successors.  Note that these),
    CONTENT#2392(      correspond to the "PureEdDSA" algorithms and not the "prehash"),
    CONTENT#2393(      variants.),
      BREAK#2394,
    CONTENT#2395(   RSASSA-PSS PSS algorithms:  Indicates a signature algorithm using),
    CONTENT#2396(      RSASSA-PSS [RFC8017] with mask generation function 1.  The digest),
    CONTENT#2397(      used in the mask generation function and the digest being signed),
    CONTENT#2398(      are both the corresponding hash algorithm as defined in [SHS].),
    CONTENT#2399(      The length of the Salt MUST be equal to the length of the digest),
    CONTENT#2400(      algorithm.  If the public key is carried in an X.509 certificate,),
    CONTENT#2401(      it MUST use the RSASSA-PSS OID [RFC5756].  When used in),
    CONTENT#2402(      certificate signatures, the algorithm parameters MUST be DER),
    CONTENT#2403(      encoded.  If the corresponding public key's parameters are),
    CONTENT#2404(      present, then the parameters in the signature MUST be identical to),
    CONTENT#2405(      those in the public key.),
      BREAK#2406,
      BREAK#2407,
      BREAK#2408,
      BREAK#2410,
      BREAK#2412,
      BREAK#2413,
    CONTENT#2414(   Legacy algorithms:  Indicates algorithms which are being deprecated),
    CONTENT#2415(      because they use algorithms with known weaknesses, specifically),
    CONTENT#2416(      SHA-1 which is used in this context with either (1) RSA using),
    CONTENT#2417(      RSASSA-PKCS1-v1_5 or (2) ECDSA.  These values refer solely to),
    CONTENT#2418(      signatures which appear in certificates (see Section 4.4.2.2) and),
    CONTENT#2419(      are not defined for use in signed TLS handshake messages, although),
    CONTENT#2420(      they MAY appear in "signature_algorithms" and),
    CONTENT#2421(      "signature_algorithms_cert" for backward compatibility with),
    CONTENT#2422(      TLS 1.2.  Endpoints SHOULD NOT negotiate these algorithms but are),
    CONTENT#2423(      permitted to do so solely for backward compatibility.  Clients),
    CONTENT#2424(      offering these values MUST list them as the lowest priority),
    CONTENT#2425(      (listed after all other algorithms in SignatureSchemeList).),
    CONTENT#2426(      TLS 1.3 servers MUST NOT offer a SHA-1 signed certificate unless),
    CONTENT#2427(      no valid certificate chain can be produced without it (see),
    CONTENT#2428(      Section 4.4.2.2).),
      BREAK#2429,
    CONTENT#2430(   The signatures on certificates that are self-signed or certificates),
    CONTENT#2431(   that are trust anchors are not validated, since they begin a),
    CONTENT#2432(   certification path (see [RFC5280], Section 3.2).  A certificate that),
    CONTENT#2433(   begins a certification path MAY use a signature algorithm that is not),
    CONTENT#2434(   advertised as being supported in the "signature_algorithms"),
    CONTENT#2435(   extension.),
      BREAK#2436,
    CONTENT#2437(   Note that TLS 1.2 defines this extension differently.  TLS 1.3),
    CONTENT#2438(   implementations willing to negotiate TLS 1.2 MUST behave in),
    CONTENT#2439(   accordance with the requirements of [RFC5246] when negotiating that),
    CONTENT#2440(   version.  In particular:),
      BREAK#2441,
    CONTENT#2442(   -  TLS 1.2 ClientHellos MAY omit this extension.),
      BREAK#2443,
    CONTENT#2444(   -  In TLS 1.2, the extension contained hash/signature pairs.  The),
    CONTENT#2445(      pairs are encoded in two octets, so SignatureScheme values have),
    CONTENT#2446(      been allocated to align with TLS 1.2's encoding.  Some legacy),
    CONTENT#2447(      pairs are left unallocated.  These algorithms are deprecated as of),
    CONTENT#2448(      TLS 1.3.  They MUST NOT be offered or negotiated by any),
    CONTENT#2449(      implementation.  In particular, MD5 [SLOTH], SHA-224, and DSA),
    CONTENT#2450(      MUST NOT be used.),
      BREAK#2451,
    CONTENT#2452(   -  ECDSA signature schemes align with TLS 1.2's ECDSA hash/signature),
    CONTENT#2453(      pairs.  However, the old semantics did not constrain the signing),
    CONTENT#2454(      curve.  If TLS 1.2 is negotiated, implementations MUST be prepared),
    CONTENT#2455(      to accept a signature that uses any curve that they advertised in),
    CONTENT#2456(      the "supported_groups" extension.),
      BREAK#2457,
    CONTENT#2458(   -  Implementations that advertise support for RSASSA-PSS (which is),
    CONTENT#2459(      mandatory in TLS 1.3) MUST be prepared to accept a signature using),
    CONTENT#2460(      that scheme even when TLS 1.2 is negotiated.  In TLS 1.2,),
    CONTENT#2461(      RSASSA-PSS is used with RSA cipher suites.),
      BREAK#2462,
      BREAK#2463,
      BREAK#2464,
      BREAK#2466,
      BREAK#2468,
      BREAK#2469,
    SECTION#2470(id=4.2.4, title=Certificate Authorities),
      BREAK#2471,
    CONTENT#2472(   The "certificate_authorities" extension is used to indicate the),
    CONTENT#2473(   certificate authorities (CAs) which an endpoint supports and which),
    CONTENT#2474(   SHOULD be used by the receiving endpoint to guide certificate),
    CONTENT#2475(   selection.),
      BREAK#2476,
    CONTENT#2477(   The body of the "certificate_authorities" extension consists of a),
    CONTENT#2478(   CertificateAuthoritiesExtension structure.),
      BREAK#2479,
    CONTENT#2480(      opaque DistinguishedName<1..2^16-1>;),
      BREAK#2481,
    CONTENT#2482(      struct {),
    CONTENT#2483(          DistinguishedName authorities<3..2^16-1>;),
    CONTENT#2484(      } CertificateAuthoritiesExtension;),
      BREAK#2485,
    CONTENT#2486(   authorities:  A list of the distinguished names [X501] of acceptable),
    CONTENT#2487(      certificate authorities, represented in DER-encoded [X690] format.),
    CONTENT#2488(      These distinguished names specify a desired distinguished name for),
    CONTENT#2489(      a trust anchor or subordinate CA; thus, this message can be used),
    CONTENT#2490(      to describe known trust anchors as well as a desired authorization),
    CONTENT#2491(      space.),
      BREAK#2492,
    CONTENT#2493(   The client MAY send the "certificate_authorities" extension in the),
    CONTENT#2494(   ClientHello message.  The server MAY send it in the),
    CONTENT#2495(   CertificateRequest message.),
      BREAK#2496,
    CONTENT#2497(   The "trusted_ca_keys" extension [RFC6066], which serves a similar),
    CONTENT#2498(   purpose but is more complicated, is not used in TLS 1.3 (although it),
    CONTENT#2499(   may appear in ClientHello messages from clients which are offering),
    CONTENT#2500(   prior versions of TLS).),
      BREAK#2501,
    SECTION#2502(id=4.2.5, title=OID Filters),
      BREAK#2503,
    CONTENT#2504(   The "oid_filters" extension allows servers to provide a set of),
    CONTENT#2505(   OID/value pairs which it would like the client's certificate to),
    CONTENT#2506(   match.  This extension, if provided by the server, MUST only be sent),
    CONTENT#2507(   in the CertificateRequest message.),
      BREAK#2508,
    CONTENT#2509(      struct {),
    CONTENT#2510(          opaque certificate_extension_oid<1..2^8-1>;),
    CONTENT#2511(          opaque certificate_extension_values<0..2^16-1>;),
    CONTENT#2512(      } OIDFilter;),
      BREAK#2513,
    CONTENT#2514(      struct {),
    CONTENT#2515(          OIDFilter filters<0..2^16-1>;),
    CONTENT#2516(      } OIDFilterExtension;),
      BREAK#2517,
      BREAK#2518,
      BREAK#2519,
      BREAK#2520,
      BREAK#2522,
      BREAK#2524,
      BREAK#2525,
    CONTENT#2526(   filters:  A list of certificate extension OIDs [RFC5280] with their),
    CONTENT#2527(      allowed value(s) and represented in DER-encoded [X690] format.),
    CONTENT#2528(      Some certificate extension OIDs allow multiple values (e.g.,),
    CONTENT#2529(      Extended Key Usage).  If the server has included a non-empty),
    CONTENT#2530(      filters list, the client certificate included in the response MUST),
    CONTENT#2531(      contain all of the specified extension OIDs that the client),
    CONTENT#2532(      recognizes.  For each extension OID recognized by the client, all),
    CONTENT#2533(      of the specified values MUST be present in the client certificate),
    CONTENT#2534(      (but the certificate MAY have other values as well).  However, the),
    CONTENT#2535(      client MUST ignore and skip any unrecognized certificate extension),
    CONTENT#2536(      OIDs.  If the client ignored some of the required certificate),
    CONTENT#2537(      extension OIDs and supplied a certificate that does not satisfy),
    CONTENT#2538(      the request, the server MAY at its discretion either continue the),
    CONTENT#2539(      connection without client authentication or abort the handshake),
    CONTENT#2540(      with an "unsupported_certificate" alert.  Any given OID MUST NOT),
    CONTENT#2541(      appear more than once in the filters list.),
      BREAK#2542,
    CONTENT#2543(   PKIX RFCs define a variety of certificate extension OIDs and their),
    CONTENT#2544(   corresponding value types.  Depending on the type, matching),
    CONTENT#2545(   certificate extension values are not necessarily bitwise-equal.  It),
    CONTENT#2546(   is expected that TLS implementations will rely on their PKI libraries),
    CONTENT#2547(   to perform certificate selection using certificate extension OIDs.),
      BREAK#2548,
    CONTENT#2549(   This document defines matching rules for two standard certificate),
    CONTENT#2550(   extensions defined in [RFC5280]:),
      BREAK#2551,
    CONTENT#2552(   -  The Key Usage extension in a certificate matches the request when),
    CONTENT#2553(      all key usage bits asserted in the request are also asserted in),
    CONTENT#2554(      the Key Usage certificate extension.),
      BREAK#2555,
    CONTENT#2556(   -  The Extended Key Usage extension in a certificate matches the),
    CONTENT#2557(      request when all key purpose OIDs present in the request are also),
    CONTENT#2558(      found in the Extended Key Usage certificate extension.  The),
    CONTENT#2559(      special anyExtendedKeyUsage OID MUST NOT be used in the request.),
      BREAK#2560,
    CONTENT#2561(   Separate specifications may define matching rules for other),
    CONTENT#2562(   certificate extensions.),
      BREAK#2563,
      BREAK#2564,
      BREAK#2565,
      BREAK#2566,
      BREAK#2567,
      BREAK#2568,
      BREAK#2569,
      BREAK#2570,
      BREAK#2571,
      BREAK#2572,
      BREAK#2573,
      BREAK#2574,
      BREAK#2575,
      BREAK#2576,
      BREAK#2578,
      BREAK#2580,
      BREAK#2581,
    SECTION#2582(id=4.2.6, title=Post-Handshake Client Authentication),
      BREAK#2583,
    CONTENT#2584(   The "post_handshake_auth" extension is used to indicate that a client),
    CONTENT#2585(   is willing to perform post-handshake authentication (Section 4.6.2).),
    CONTENT#2586(   Servers MUST NOT send a post-handshake CertificateRequest to clients),
    CONTENT#2587(   which do not offer this extension.  Servers MUST NOT send this),
    CONTENT#2588(   extension.),
      BREAK#2589,
    CONTENT#2590(      struct {} PostHandshakeAuth;),
      BREAK#2591,
    CONTENT#2592(   The "extension_data" field of the "post_handshake_auth" extension is),
    CONTENT#2593(   zero length.),
      BREAK#2594,
    SECTION#2595(id=4.2.7, title=Supported Groups),
      BREAK#2596,
    CONTENT#2597(   When sent by the client, the "supported_groups" extension indicates),
    CONTENT#2598(   the named groups which the client supports for key exchange, ordered),
    CONTENT#2599(   from most preferred to least preferred.),
      BREAK#2600,
    CONTENT#2601(   Note: In versions of TLS prior to TLS 1.3, this extension was named),
    CONTENT#2602(   "elliptic_curves" and only contained elliptic curve groups.  See),
    CONTENT#2603(   [RFC8422] and [RFC7919].  This extension was also used to negotiate),
    CONTENT#2604(   ECDSA curves.  Signature algorithms are now negotiated independently),
    CONTENT#2605(   (see Section 4.2.3).),
      BREAK#2606,
    CONTENT#2607(   The "extension_data" field of this extension contains a),
    CONTENT#2608(   "NamedGroupList" value:),
      BREAK#2609,
    CONTENT#2610(      enum {),
      BREAK#2611,
    CONTENT#2612(          /* Elliptic Curve Groups (ECDHE) */),
    CONTENT#2613(          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),),
    CONTENT#2614(          x25519(0x001D), x448(0x001E),),
      BREAK#2615,
    CONTENT#2616(          /* Finite Field Groups (DHE) */),
    CONTENT#2617(          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),),
    CONTENT#2618(          ffdhe6144(0x0103), ffdhe8192(0x0104),),
      BREAK#2619,
    CONTENT#2620(          /* Reserved Code Points */),
    CONTENT#2621(          ffdhe_private_use(0x01FC..0x01FF),),
    CONTENT#2622(          ecdhe_private_use(0xFE00..0xFEFF),),
    CONTENT#2623(          (0xFFFF)),
    CONTENT#2624(      } NamedGroup;),
      BREAK#2625,
    CONTENT#2626(      struct {),
    CONTENT#2627(          NamedGroup named_group_list<2..2^16-1>;),
    CONTENT#2628(      } NamedGroupList;),
      BREAK#2629,
      BREAK#2630,
      BREAK#2631,
      BREAK#2632,
      BREAK#2634,
      BREAK#2636,
      BREAK#2637,
    CONTENT#2638(   Elliptic Curve Groups (ECDHE):  Indicates support for the),
    CONTENT#2639(      corresponding named curve, defined in either FIPS 186-4 [DSS] or),
    CONTENT#2640(      [RFC7748].  Values 0xFE00 through 0xFEFF are reserved for),
    CONTENT#2641(      Private Use [RFC8126].),
      BREAK#2642,
    CONTENT#2643(   Finite Field Groups (DHE):  Indicates support for the corresponding),
    CONTENT#2644(      finite field group, defined in [RFC7919].  Values 0x01FC through),
    CONTENT#2645(      0x01FF are reserved for Private Use.),
      BREAK#2646,
    CONTENT#2647(   Items in named_group_list are ordered according to the sender's),
    CONTENT#2648(   preferences (most preferred choice first).),
      BREAK#2649,
    CONTENT#2650(   As of TLS 1.3, servers are permitted to send the "supported_groups"),
    CONTENT#2651(   extension to the client.  Clients MUST NOT act upon any information),
    CONTENT#2652(   found in "supported_groups" prior to successful completion of the),
    CONTENT#2653(   handshake but MAY use the information learned from a successfully),
    CONTENT#2654(   completed handshake to change what groups they use in their),
    CONTENT#2655(   "key_share" extension in subsequent connections.  If the server has a),
    CONTENT#2656(   group it prefers to the ones in the "key_share" extension but is),
    CONTENT#2657(   still willing to accept the ClientHello, it SHOULD send),
    CONTENT#2658(   "supported_groups" to update the client's view of its preferences;),
    CONTENT#2659(   this extension SHOULD contain all groups the server supports,),
    CONTENT#2660(   regardless of whether they are currently supported by the client.),
      BREAK#2661,
    SECTION#2662(id=4.2.8, title=Key Share),
      BREAK#2663,
    CONTENT#2664(   The "key_share" extension contains the endpoint's cryptographic),
    CONTENT#2665(   parameters.),
      BREAK#2666,
    CONTENT#2667(   Clients MAY send an empty client_shares vector in order to request),
    CONTENT#2668(   group selection from the server, at the cost of an additional round),
    CONTENT#2669(   trip (see Section 4.1.4).),
      BREAK#2670,
    CONTENT#2671(      struct {),
    CONTENT#2672(          NamedGroup group;),
    CONTENT#2673(          opaque key_exchange<1..2^16-1>;),
    CONTENT#2674(      } KeyShareEntry;),
      BREAK#2675,
    CONTENT#2676(   group:  The named group for the key being exchanged.),
      BREAK#2677,
    CONTENT#2678(   key_exchange:  Key exchange information.  The contents of this field),
    CONTENT#2679(      are determined by the specified group and its corresponding),
    CONTENT#2680(      definition.  Finite Field Diffie-Hellman [DH76] parameters are),
    CONTENT#2681(      described in Section 4.2.8.1; Elliptic Curve Diffie-Hellman),
    CONTENT#2682(      parameters are described in Section 4.2.8.2.),
      BREAK#2683,
      BREAK#2684,
      BREAK#2685,
      BREAK#2686,
      BREAK#2687,
      BREAK#2688,
      BREAK#2690,
      BREAK#2692,
      BREAK#2693,
    CONTENT#2694(   In the ClientHello message, the "extension_data" field of this),
    CONTENT#2695(   extension contains a "KeyShareClientHello" value:),
      BREAK#2696,
    CONTENT#2697(      struct {),
    CONTENT#2698(          KeyShareEntry client_shares<0..2^16-1>;),
    CONTENT#2699(      } KeyShareClientHello;),
      BREAK#2700,
    CONTENT#2701(   client_shares:  A list of offered KeyShareEntry values in descending),
    CONTENT#2702(      order of client preference.),
      BREAK#2703,
    CONTENT#2704(   This vector MAY be empty if the client is requesting a),
    CONTENT#2705(   HelloRetryRequest.  Each KeyShareEntry value MUST correspond to a),
    CONTENT#2706(   group offered in the "supported_groups" extension and MUST appear in),
    CONTENT#2707(   the same order.  However, the values MAY be a non-contiguous subset),
    CONTENT#2708(   of the "supported_groups" extension and MAY omit the most preferred),
    CONTENT#2709(   groups.  Such a situation could arise if the most preferred groups),
    CONTENT#2710(   are new and unlikely to be supported in enough places to make),
    CONTENT#2711(   pregenerating key shares for them efficient.),
      BREAK#2712,
    CONTENT#2713(   Clients can offer as many KeyShareEntry values as the number of),
    CONTENT#2714(   supported groups it is offering, each representing a single set of),
    CONTENT#2715(   key exchange parameters.  For instance, a client might offer shares),
    CONTENT#2716(   for several elliptic curves or multiple FFDHE groups.  The),
    CONTENT#2717(   key_exchange values for each KeyShareEntry MUST be generated),
    CONTENT#2718(   independently.  Clients MUST NOT offer multiple KeyShareEntry values),
    CONTENT#2719(   for the same group.  Clients MUST NOT offer any KeyShareEntry values),
    CONTENT#2720(   for groups not listed in the client's "supported_groups" extension.),
    CONTENT#2721(   Servers MAY check for violations of these rules and abort the),
    CONTENT#2722(   handshake with an "illegal_parameter" alert if one is violated.),
      BREAK#2723,
    CONTENT#2724(   In a HelloRetryRequest message, the "extension_data" field of this),
    CONTENT#2725(   extension contains a KeyShareHelloRetryRequest value:),
      BREAK#2726,
    CONTENT#2727(      struct {),
    CONTENT#2728(          NamedGroup selected_group;),
    CONTENT#2729(      } KeyShareHelloRetryRequest;),
      BREAK#2730,
    CONTENT#2731(   selected_group:  The mutually supported group the server intends to),
    CONTENT#2732(      negotiate and is requesting a retried ClientHello/KeyShare for.),
      BREAK#2733,
    CONTENT#2734(   Upon receipt of this extension in a HelloRetryRequest, the client),
    CONTENT#2735(   MUST verify that (1) the selected_group field corresponds to a group),
    CONTENT#2736(   which was provided in the "supported_groups" extension in the),
    CONTENT#2737(   original ClientHello and (2) the selected_group field does not),
    CONTENT#2738(   correspond to a group which was provided in the "key_share" extension),
    CONTENT#2739(   in the original ClientHello.  If either of these checks fails, then),
    CONTENT#2740(   the client MUST abort the handshake with an "illegal_parameter"),
    CONTENT#2741(   alert.  Otherwise, when sending the new ClientHello, the client MUST),
      BREAK#2742,
      BREAK#2743,
      BREAK#2744,
      BREAK#2746,
      BREAK#2748,
      BREAK#2749,
    CONTENT#2750(   replace the original "key_share" extension with one containing only a),
    CONTENT#2751(   new KeyShareEntry for the group indicated in the selected_group field),
    CONTENT#2752(   of the triggering HelloRetryRequest.),
      BREAK#2753,
    CONTENT#2754(   In a ServerHello message, the "extension_data" field of this),
    CONTENT#2755(   extension contains a KeyShareServerHello value:),
      BREAK#2756,
    CONTENT#2757(      struct {),
    CONTENT#2758(          KeyShareEntry server_share;),
    CONTENT#2759(      } KeyShareServerHello;),
      BREAK#2760,
    CONTENT#2761(   server_share:  A single KeyShareEntry value that is in the same group),
    CONTENT#2762(      as one of the client's shares.),
      BREAK#2763,
    CONTENT#2764(   If using (EC)DHE key establishment, servers offer exactly one),
    CONTENT#2765(   KeyShareEntry in the ServerHello.  This value MUST be in the same),
    CONTENT#2766(   group as the KeyShareEntry value offered by the client that the),
    CONTENT#2767(   server has selected for the negotiated key exchange.  Servers),
    CONTENT#2768(   MUST NOT send a KeyShareEntry for any group not indicated in the),
    CONTENT#2769(   client's "supported_groups" extension and MUST NOT send a),
    CONTENT#2770(   KeyShareEntry when using the "psk_ke" PskKeyExchangeMode.  If using),
    CONTENT#2771(   (EC)DHE key establishment and a HelloRetryRequest containing a),
    CONTENT#2772(   "key_share" extension was received by the client, the client MUST),
    CONTENT#2773(   verify that the selected NamedGroup in the ServerHello is the same as),
    CONTENT#2774(   that in the HelloRetryRequest.  If this check fails, the client MUST),
    CONTENT#2775(   abort the handshake with an "illegal_parameter" alert.),
      BREAK#2776,
    SECTION#2777(id=4.2.8.1, title=Diffie-Hellman Parameters),
      BREAK#2778,
    CONTENT#2779(   Diffie-Hellman [DH76] parameters for both clients and servers are),
    CONTENT#2780(   encoded in the opaque key_exchange field of a KeyShareEntry in a),
    CONTENT#2781(   KeyShare structure.  The opaque value contains the Diffie-Hellman),
    CONTENT#2782(   public value (Y = g^X mod p) for the specified group (see [RFC7919]),
    CONTENT#2783(   for group definitions) encoded as a big-endian integer and padded to),
    CONTENT#2784(   the left with zeros to the size of p in bytes.),
      BREAK#2785,
    CONTENT#2786(   Note: For a given Diffie-Hellman group, the padding results in all),
    CONTENT#2787(   public keys having the same length.),
      BREAK#2788,
    CONTENT#2789(   Peers MUST validate each other's public key Y by ensuring that 1 < Y),
    CONTENT#2790(   < p-1.  This check ensures that the remote peer is properly behaved),
    CONTENT#2791(   and isn't forcing the local system into a small subgroup.),
      BREAK#2792,
      BREAK#2793,
      BREAK#2794,
      BREAK#2795,
      BREAK#2796,
      BREAK#2797,
      BREAK#2798,
      BREAK#2799,
      BREAK#2800,
      BREAK#2802,
      BREAK#2804,
      BREAK#2805,
    SECTION#2806(id=4.2.8.2, title=ECDHE Parameters),
      BREAK#2807,
    CONTENT#2808(   ECDHE parameters for both clients and servers are encoded in the),
    CONTENT#2809(   opaque key_exchange field of a KeyShareEntry in a KeyShare structure.),
      BREAK#2810,
    CONTENT#2811(   For secp256r1, secp384r1, and secp521r1, the contents are the),
    CONTENT#2812(   serialized value of the following struct:),
      BREAK#2813,
    CONTENT#2814(      struct {),
    CONTENT#2815(          uint8 legacy_form = 4;),
    CONTENT#2816(          opaque X[coordinate_length];),
    CONTENT#2817(          opaque Y[coordinate_length];),
    CONTENT#2818(      } UncompressedPointRepresentation;),
      BREAK#2819,
    CONTENT#2820(   X and Y, respectively, are the binary representations of the x and y),
    CONTENT#2821(   values in network byte order.  There are no internal length markers,),
    CONTENT#2822(   so each number representation occupies as many octets as implied by),
    CONTENT#2823(   the curve parameters.  For P-256, this means that each of X and Y use),
    CONTENT#2824(   32 octets, padded on the left by zeros if necessary.  For P-384, they),
    CONTENT#2825(   take 48 octets each.  For P-521, they take 66 octets each.),
      BREAK#2826,
    CONTENT#2827(   For the curves secp256r1, secp384r1, and secp521r1, peers MUST),
    CONTENT#2828(   validate each other's public value Q by ensuring that the point is a),
    CONTENT#2829(   valid point on the elliptic curve.  The appropriate validation),
    CONTENT#2830(   procedures are defined in Section 4.3.7 of [ECDSA] and alternatively),
    CONTENT#2831(   in Section 5.6.2.3 of [KEYAGREEMENT].  This process consists of three),
    CONTENT#2832(   steps: (1) verify that Q is not the point at infinity (O), (2) verify),
    CONTENT#2833(   that for Q = (x, y) both integers x and y are in the correct),
    CONTENT#2834(   interval, and (3) ensure that (x, y) is a correct solution to the),
    CONTENT#2835(   elliptic curve equation.  For these curves, implementors do not need),
    CONTENT#2836(   to verify membership in the correct subgroup.),
      BREAK#2837,
    CONTENT#2838(   For X25519 and X448, the contents of the public value are the byte),
    CONTENT#2839(   string inputs and outputs of the corresponding functions defined in),
    CONTENT#2840(   [RFC7748]: 32 bytes for X25519 and 56 bytes for X448.),
      BREAK#2841,
    CONTENT#2842(   Note: Versions of TLS prior to 1.3 permitted point format),
    CONTENT#2843(   negotiation; TLS 1.3 removes this feature in favor of a single point),
    CONTENT#2844(   format for each curve.),
      BREAK#2845,
    SECTION#2846(id=4.2.9, title=Pre-Shared Key Exchange Modes),
      BREAK#2847,
    CONTENT#2848(   In order to use PSKs, clients MUST also send a),
    CONTENT#2849(   "psk_key_exchange_modes" extension.  The semantics of this extension),
    CONTENT#2850(   are that the client only supports the use of PSKs with these modes,),
    CONTENT#2851(   which restricts both the use of PSKs offered in this ClientHello and),
    CONTENT#2852(   those which the server might supply via NewSessionTicket.),
      BREAK#2853,
      BREAK#2854,
      BREAK#2855,
      BREAK#2856,
      BREAK#2858,
      BREAK#2860,
      BREAK#2861,
    CONTENT#2862(   A client MUST provide a "psk_key_exchange_modes" extension if it),
    CONTENT#2863(   offers a "pre_shared_key" extension.  If clients offer),
    CONTENT#2864(   "pre_shared_key" without a "psk_key_exchange_modes" extension,),
    CONTENT#2865(   servers MUST abort the handshake.  Servers MUST NOT select a key),
    CONTENT#2866(   exchange mode that is not listed by the client.  This extension also),
    CONTENT#2867(   restricts the modes for use with PSK resumption.  Servers SHOULD NOT),
    CONTENT#2868(   send NewSessionTicket with tickets that are not compatible with the),
    CONTENT#2869(   advertised modes; however, if a server does so, the impact will just),
    CONTENT#2870(   be that the client's attempts at resumption fail.),
      BREAK#2871,
    CONTENT#2872(   The server MUST NOT send a "psk_key_exchange_modes" extension.),
      BREAK#2873,
    CONTENT#2874(      enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;),
      BREAK#2875,
    CONTENT#2876(      struct {),
    CONTENT#2877(          PskKeyExchangeMode ke_modes<1..255>;),
    CONTENT#2878(      } PskKeyExchangeModes;),
      BREAK#2879,
    CONTENT#2880(   psk_ke:  PSK-only key establishment.  In this mode, the server),
    CONTENT#2881(      MUST NOT supply a "key_share" value.),
      BREAK#2882,
    CONTENT#2883(   psk_dhe_ke:  PSK with (EC)DHE key establishment.  In this mode, the),
    CONTENT#2884(      client and server MUST supply "key_share" values as described in),
    CONTENT#2885(      Section 4.2.8.),
      BREAK#2886,
    CONTENT#2887(   Any future values that are allocated must ensure that the transmitted),
    CONTENT#2888(   protocol messages unambiguously identify which mode was selected by),
    CONTENT#2889(   the server; at present, this is indicated by the presence of the),
    CONTENT#2890(   "key_share" in the ServerHello.),
      BREAK#2891,
    SECTION#2892(id=4.2.10, title=Early Data Indication),
      BREAK#2893,
    CONTENT#2894(   When a PSK is used and early data is allowed for that PSK, the client),
    CONTENT#2895(   can send Application Data in its first flight of messages.  If the),
    CONTENT#2896(   client opts to do so, it MUST supply both the "pre_shared_key" and),
    CONTENT#2897(   "early_data" extensions.),
      BREAK#2898,
    CONTENT#2899(   The "extension_data" field of this extension contains an),
    CONTENT#2900(   "EarlyDataIndication" value.),
      BREAK#2901,
      BREAK#2902,
      BREAK#2903,
      BREAK#2904,
      BREAK#2905,
      BREAK#2906,
      BREAK#2907,
      BREAK#2908,
      BREAK#2909,
      BREAK#2910,
      BREAK#2911,
      BREAK#2912,
      BREAK#2914,
      BREAK#2916,
      BREAK#2917,
    CONTENT#2918(      struct {} Empty;),
      BREAK#2919,
    CONTENT#2920(      struct {),
    CONTENT#2921(          select (Handshake.msg_type) {),
    CONTENT#2922(              case new_session_ticket:   uint32 max_early_data_size;),
    CONTENT#2923(              case client_hello:         Empty;),
    CONTENT#2924(              case encrypted_extensions: Empty;),
    CONTENT#2925(          };),
    CONTENT#2926(      } EarlyDataIndication;),
      BREAK#2927,
    CONTENT#2928(   See Section 4.6.1 for details regarding the use of the),
    CONTENT#2929(   max_early_data_size field.),
      BREAK#2930,
    CONTENT#2931(   The parameters for the 0-RTT data (version, symmetric cipher suite,),
    CONTENT#2932(   Application-Layer Protocol Negotiation (ALPN) [RFC7301] protocol,),
    CONTENT#2933(   etc.) are those associated with the PSK in use.  For externally),
    CONTENT#2934(   provisioned PSKs, the associated values are those provisioned along),
    CONTENT#2935(   with the key.  For PSKs established via a NewSessionTicket message,),
    CONTENT#2936(   the associated values are those which were negotiated in the),
    CONTENT#2937(   connection which established the PSK.  The PSK used to encrypt the),
    CONTENT#2938(   early data MUST be the first PSK listed in the client's),
    CONTENT#2939(   "pre_shared_key" extension.),
      BREAK#2940,
    CONTENT#2941(   For PSKs provisioned via NewSessionTicket, a server MUST validate),
    CONTENT#2942(   that the ticket age for the selected PSK identity (computed by),
    CONTENT#2943(   subtracting ticket_age_add from PskIdentity.obfuscated_ticket_age),
    CONTENT#2944(   modulo 2^32) is within a small tolerance of the time since the ticket),
    CONTENT#2945(   was issued (see Section 8).  If it is not, the server SHOULD proceed),
    CONTENT#2946(   with the handshake but reject 0-RTT, and SHOULD NOT take any other),
    CONTENT#2947(   action that assumes that this ClientHello is fresh.),
      BREAK#2948,
    CONTENT#2949(   0-RTT messages sent in the first flight have the same (encrypted)),
    CONTENT#2950(   content types as messages of the same type sent in other flights),
    CONTENT#2951(   (handshake and application_data) but are protected under different),
    CONTENT#2952(   keys.  After receiving the server's Finished message, if the server),
    CONTENT#2953(   has accepted early data, an EndOfEarlyData message will be sent to),
    CONTENT#2954(   indicate the key change.  This message will be encrypted with the),
    CONTENT#2955(   0-RTT traffic keys.),
      BREAK#2956,
      BREAK#2957,
      BREAK#2958,
      BREAK#2959,
      BREAK#2960,
      BREAK#2961,
      BREAK#2962,
      BREAK#2963,
      BREAK#2964,
      BREAK#2965,
      BREAK#2966,
      BREAK#2967,
      BREAK#2968,
      BREAK#2970,
      BREAK#2972,
      BREAK#2973,
    CONTENT#2974(   A server which receives an "early_data" extension MUST behave in one),
    CONTENT#2975(   of three ways:),
      BREAK#2976,
    CONTENT#2977(   -  Ignore the extension and return a regular 1-RTT response.  The),
    CONTENT#2978(      server then skips past early data by attempting to deprotect),
    CONTENT#2979(      received records using the handshake traffic key, discarding),
    CONTENT#2980(      records which fail deprotection (up to the configured),
    CONTENT#2981(      max_early_data_size).  Once a record is deprotected successfully,),
    CONTENT#2982(      it is treated as the start of the client's second flight and the),
    CONTENT#2983(      server proceeds as with an ordinary 1-RTT handshake.),
      BREAK#2984,
    CONTENT#2985(   -  Request that the client send another ClientHello by responding),
    CONTENT#2986(      with a HelloRetryRequest.  A client MUST NOT include the),
    CONTENT#2987(      "early_data" extension in its followup ClientHello.  The server),
    CONTENT#2988(      then ignores early data by skipping all records with an external),
    CONTENT#2989(      content type of "application_data" (indicating that they are),
    CONTENT#2990(      encrypted), up to the configured max_early_data_size.),
      BREAK#2991,
    CONTENT#2992(   -  Return its own "early_data" extension in EncryptedExtensions,),
    CONTENT#2993(      indicating that it intends to process the early data.  It is not),
    CONTENT#2994(      possible for the server to accept only a subset of the early data),
    CONTENT#2995(      messages.  Even though the server sends a message accepting early),
    CONTENT#2996(      data, the actual early data itself may already be in flight by the),
    CONTENT#2997(      time the server generates this message.),
      BREAK#2998,
    CONTENT#2999(   In order to accept early data, the server MUST have accepted a PSK),
    CONTENT#3000(   cipher suite and selected the first key offered in the client's),
    CONTENT#3001(   "pre_shared_key" extension.  In addition, it MUST verify that the),
    CONTENT#3002(   following values are the same as those associated with the),
    CONTENT#3003(   selected PSK:),
      BREAK#3004,
    CONTENT#3005(   -  The TLS version number),
      BREAK#3006,
    CONTENT#3007(   -  The selected cipher suite),
      BREAK#3008,
    CONTENT#3009(   -  The selected ALPN [RFC7301] protocol, if any),
      BREAK#3010,
    CONTENT#3011(   These requirements are a superset of those needed to perform a 1-RTT),
    CONTENT#3012(   handshake using the PSK in question.  For externally established),
    CONTENT#3013(   PSKs, the associated values are those provisioned along with the key.),
    CONTENT#3014(   For PSKs established via a NewSessionTicket message, the associated),
    CONTENT#3015(   values are those negotiated in the connection during which the ticket),
    CONTENT#3016(   was established.),
      BREAK#3017,
    CONTENT#3018(   Future extensions MUST define their interaction with 0-RTT.),
      BREAK#3019,
      BREAK#3020,
      BREAK#3021,
      BREAK#3022,
      BREAK#3023,
      BREAK#3024,
      BREAK#3026,
      BREAK#3028,
      BREAK#3029,
    CONTENT#3030(   If any of these checks fail, the server MUST NOT respond with the),
    CONTENT#3031(   extension and must discard all the first-flight data using one of the),
    CONTENT#3032(   first two mechanisms listed above (thus falling back to 1-RTT or),
    CONTENT#3033(   2-RTT).  If the client attempts a 0-RTT handshake but the server),
    CONTENT#3034(   rejects it, the server will generally not have the 0-RTT record),
    CONTENT#3035(   protection keys and must instead use trial decryption (either with),
    CONTENT#3036(   the 1-RTT handshake keys or by looking for a cleartext ClientHello in),
    CONTENT#3037(   the case of a HelloRetryRequest) to find the first non-0-RTT message.),
      BREAK#3038,
    CONTENT#3039(   If the server chooses to accept the "early_data" extension, then it),
    CONTENT#3040(   MUST comply with the same error-handling requirements specified for),
    CONTENT#3041(   all records when processing early data records.  Specifically, if the),
    CONTENT#3042(   server fails to decrypt a 0-RTT record following an accepted),
    CONTENT#3043(   "early_data" extension, it MUST terminate the connection with a),
    CONTENT#3044(   "bad_record_mac" alert as per Section 5.2.),
      BREAK#3045,
    CONTENT#3046(   If the server rejects the "early_data" extension, the client),
    CONTENT#3047(   application MAY opt to retransmit the Application Data previously),
    CONTENT#3048(   sent in early data once the handshake has been completed.  Note that),
    CONTENT#3049(   automatic retransmission of early data could result in incorrect),
    CONTENT#3050(   assumptions regarding the status of the connection.  For instance,),
    CONTENT#3051(   when the negotiated connection selects a different ALPN protocol from),
    CONTENT#3052(   what was used for the early data, an application might need to),
    CONTENT#3053(   construct different messages.  Similarly, if early data assumes),
    CONTENT#3054(   anything about the connection state, it might be sent in error after),
    CONTENT#3055(   the handshake completes.),
      BREAK#3056,
    CONTENT#3057(   A TLS implementation SHOULD NOT automatically resend early data;),
    CONTENT#3058(   applications are in a better position to decide when retransmission),
    CONTENT#3059(   is appropriate.  A TLS implementation MUST NOT automatically resend),
    CONTENT#3060(   early data unless the negotiated connection selects the same ALPN),
    CONTENT#3061(   protocol.),
      BREAK#3062,
    SECTION#3063(id=4.2.11, title=Pre-Shared Key Extension),
      BREAK#3064,
    CONTENT#3065(   The "pre_shared_key" extension is used to negotiate the identity of),
    CONTENT#3066(   the pre-shared key to be used with a given handshake in association),
    CONTENT#3067(   with PSK key establishment.),
      BREAK#3068,
      BREAK#3069,
      BREAK#3070,
      BREAK#3071,
      BREAK#3072,
      BREAK#3073,
      BREAK#3074,
      BREAK#3075,
      BREAK#3076,
      BREAK#3077,
      BREAK#3078,
      BREAK#3079,
      BREAK#3080,
      BREAK#3082,
      BREAK#3084,
      BREAK#3085,
    CONTENT#3086(   The "extension_data" field of this extension contains a),
    CONTENT#3087(   "PreSharedKeyExtension" value:),
      BREAK#3088,
    CONTENT#3089(      struct {),
    CONTENT#3090(          opaque identity<1..2^16-1>;),
    CONTENT#3091(          uint32 obfuscated_ticket_age;),
    CONTENT#3092(      } PskIdentity;),
      BREAK#3093,
    CONTENT#3094(      opaque PskBinderEntry<32..255>;),
      BREAK#3095,
    CONTENT#3096(      struct {),
    CONTENT#3097(          PskIdentity identities<7..2^16-1>;),
    CONTENT#3098(          PskBinderEntry binders<33..2^16-1>;),
    CONTENT#3099(      } OfferedPsks;),
      BREAK#3100,
    CONTENT#3101(      struct {),
    CONTENT#3102(          select (Handshake.msg_type) {),
    CONTENT#3103(              case client_hello: OfferedPsks;),
    CONTENT#3104(              case server_hello: uint16 selected_identity;),
    CONTENT#3105(          };),
    CONTENT#3106(      } PreSharedKeyExtension;),
      BREAK#3107,
    CONTENT#3108(   identity:  A label for a key.  For instance, a ticket (as defined in),
    CONTENT#3109(      Appendix B.3.4) or a label for a pre-shared key established),
    CONTENT#3110(      externally.),
      BREAK#3111,
    CONTENT#3112(   obfuscated_ticket_age:  An obfuscated version of the age of the key.),
    CONTENT#3113(      Section 4.2.11.1 describes how to form this value for identities),
    CONTENT#3114(      established via the NewSessionTicket message.  For identities),
    CONTENT#3115(      established externally, an obfuscated_ticket_age of 0 SHOULD be),
    CONTENT#3116(      used, and servers MUST ignore the value.),
      BREAK#3117,
    CONTENT#3118(   identities:  A list of the identities that the client is willing to),
    CONTENT#3119(      negotiate with the server.  If sent alongside the "early_data"),
    CONTENT#3120(      extension (see Section 4.2.10), the first identity is the one used),
    CONTENT#3121(      for 0-RTT data.),
      BREAK#3122,
    CONTENT#3123(   binders:  A series of HMAC values, one for each value in the),
    CONTENT#3124(      identities list and in the same order, computed as described),
    CONTENT#3125(      below.),
      BREAK#3126,
    CONTENT#3127(   selected_identity:  The server's chosen identity expressed as a),
    CONTENT#3128(      (0-based) index into the identities in the client's list.),
      BREAK#3129,
    CONTENT#3130(   Each PSK is associated with a single Hash algorithm.  For PSKs),
    CONTENT#3131(   established via the ticket mechanism (Section 4.6.1), this is the KDF),
    CONTENT#3132(   Hash algorithm on the connection where the ticket was established.),
    CONTENT#3133(   For externally established PSKs, the Hash algorithm MUST be set when),
      BREAK#3134,
      BREAK#3135,
      BREAK#3136,
      BREAK#3138,
      BREAK#3140,
      BREAK#3141,
    CONTENT#3142(   the PSK is established or default to SHA-256 if no such algorithm is),
    CONTENT#3143(   defined.  The server MUST ensure that it selects a compatible PSK),
    CONTENT#3144(   (if any) and cipher suite.),
      BREAK#3145,
    CONTENT#3146(   In TLS versions prior to TLS 1.3, the Server Name Identification),
    CONTENT#3147(   (SNI) value was intended to be associated with the session (Section 3),
    CONTENT#3148(   of [RFC6066]), with the server being required to enforce that the SNI),
    CONTENT#3149(   value associated with the session matches the one specified in the),
    CONTENT#3150(   resumption handshake.  However, in reality the implementations were),
    CONTENT#3151(   not consistent on which of two supplied SNI values they would use,),
    CONTENT#3152(   leading to the consistency requirement being de facto enforced by the),
    CONTENT#3153(   clients.  In TLS 1.3, the SNI value is always explicitly specified in),
    CONTENT#3154(   the resumption handshake, and there is no need for the server to),
    CONTENT#3155(   associate an SNI value with the ticket.  Clients, however, SHOULD),
    CONTENT#3156(   store the SNI with the PSK to fulfill the requirements of),
    CONTENT#3157(   Section 4.6.1.),
      BREAK#3158,
    CONTENT#3159(   Implementor's note: When session resumption is the primary use case),
    CONTENT#3160(   of PSKs, the most straightforward way to implement the PSK/cipher),
    CONTENT#3161(   suite matching requirements is to negotiate the cipher suite first),
    CONTENT#3162(   and then exclude any incompatible PSKs.  Any unknown PSKs (e.g., ones),
    CONTENT#3163(   not in the PSK database or encrypted with an unknown key) SHOULD),
    CONTENT#3164(   simply be ignored.  If no acceptable PSKs are found, the server),
    CONTENT#3165(   SHOULD perform a non-PSK handshake if possible.  If backward),
    CONTENT#3166(   compatibility is important, client-provided, externally established),
    CONTENT#3167(   PSKs SHOULD influence cipher suite selection.),
      BREAK#3168,
    CONTENT#3169(   Prior to accepting PSK key establishment, the server MUST validate),
    CONTENT#3170(   the corresponding binder value (see Section 4.2.11.2 below).  If this),
    CONTENT#3171(   value is not present or does not validate, the server MUST abort the),
    CONTENT#3172(   handshake.  Servers SHOULD NOT attempt to validate multiple binders;),
    CONTENT#3173(   rather, they SHOULD select a single PSK and validate solely the),
    CONTENT#3174(   binder that corresponds to that PSK.  See Section 8.2 and),
    CONTENT#3175(   Appendix E.6 for the security rationale for this requirement.  In),
    CONTENT#3176(   order to accept PSK key establishment, the server sends a),
    CONTENT#3177(   "pre_shared_key" extension indicating the selected identity.),
      BREAK#3178,
    CONTENT#3179(   Clients MUST verify that the server's selected_identity is within the),
    CONTENT#3180(   range supplied by the client, that the server selected a cipher suite),
    CONTENT#3181(   indicating a Hash associated with the PSK, and that a server),
    CONTENT#3182(   "key_share" extension is present if required by the ClientHello),
    CONTENT#3183(   "psk_key_exchange_modes" extension.  If these values are not),
    CONTENT#3184(   consistent, the client MUST abort the handshake with an),
    CONTENT#3185(   "illegal_parameter" alert.),
      BREAK#3186,
      BREAK#3187,
      BREAK#3188,
      BREAK#3189,
      BREAK#3190,
      BREAK#3191,
      BREAK#3192,
      BREAK#3194,
      BREAK#3196,
      BREAK#3197,
    CONTENT#3198(   If the server supplies an "early_data" extension, the client MUST),
    CONTENT#3199(   verify that the server's selected_identity is 0.  If any other value),
    CONTENT#3200(   is returned, the client MUST abort the handshake with an),
    CONTENT#3201(   "illegal_parameter" alert.),
      BREAK#3202,
    CONTENT#3203(   The "pre_shared_key" extension MUST be the last extension in the),
    CONTENT#3204(   ClientHello (this facilitates implementation as described below).),
    CONTENT#3205(   Servers MUST check that it is the last extension and otherwise fail),
    CONTENT#3206(   the handshake with an "illegal_parameter" alert.),
      BREAK#3207,
    SECTION#3208(id=4.2.11.1, title=Ticket Age),
      BREAK#3209,
    CONTENT#3210(   The client's view of the age of a ticket is the time since the),
    CONTENT#3211(   receipt of the NewSessionTicket message.  Clients MUST NOT attempt to),
    CONTENT#3212(   use tickets which have ages greater than the "ticket_lifetime" value),
    CONTENT#3213(   which was provided with the ticket.  The "obfuscated_ticket_age"),
    CONTENT#3214(   field of each PskIdentity contains an obfuscated version of the),
    CONTENT#3215(   ticket age formed by taking the age in milliseconds and adding the),
    CONTENT#3216(   "ticket_age_add" value that was included with the ticket (see),
    CONTENT#3217(   Section 4.6.1), modulo 2^32.  This addition prevents passive),
    CONTENT#3218(   observers from correlating connections unless tickets are reused.),
    CONTENT#3219(   Note that the "ticket_lifetime" field in the NewSessionTicket message),
    CONTENT#3220(   is in seconds but the "obfuscated_ticket_age" is in milliseconds.),
    CONTENT#3221(   Because ticket lifetimes are restricted to a week, 32 bits is enough),
    CONTENT#3222(   to represent any plausible age, even in milliseconds.),
      BREAK#3223,
    SECTION#3224(id=4.2.11.2, title=PSK Binder),
      BREAK#3225,
    CONTENT#3226(   The PSK binder value forms a binding between a PSK and the current),
    CONTENT#3227(   handshake, as well as a binding between the handshake in which the),
    CONTENT#3228(   PSK was generated (if via a NewSessionTicket message) and the current),
    CONTENT#3229(   handshake.  Each entry in the binders list is computed as an HMAC),
    CONTENT#3230(   over a transcript hash (see Section 4.4.1) containing a partial),
    CONTENT#3231(   ClientHello up to and including the PreSharedKeyExtension.identities),
    CONTENT#3232(   field.  That is, it includes all of the ClientHello but not the),
    CONTENT#3233(   binders list itself.  The length fields for the message (including),
    CONTENT#3234(   the overall length, the length of the extensions block, and the),
    CONTENT#3235(   length of the "pre_shared_key" extension) are all set as if binders),
    CONTENT#3236(   of the correct lengths were present.),
      BREAK#3237,
    CONTENT#3238(   The PskBinderEntry is computed in the same way as the Finished),
    CONTENT#3239(   message (Section 4.4.4) but with the BaseKey being the binder_key),
    CONTENT#3240(   derived via the key schedule from the corresponding PSK which is),
    CONTENT#3241(   being offered (see Section 7.1).),
      BREAK#3242,
      BREAK#3243,
      BREAK#3244,
      BREAK#3245,
      BREAK#3246,
      BREAK#3247,
      BREAK#3248,
      BREAK#3250,
      BREAK#3252,
      BREAK#3253,
    CONTENT#3254(   If the handshake includes a HelloRetryRequest, the initial),
    CONTENT#3255(   ClientHello and HelloRetryRequest are included in the transcript),
    CONTENT#3256(   along with the new ClientHello.  For instance, if the client sends),
    CONTENT#3257(   ClientHello1, its binder will be computed over:),
      BREAK#3258,
    CONTENT#3259(      Transcript-Hash(Truncate(ClientHello1))),
      BREAK#3260,
    CONTENT#3261(   Where Truncate() removes the binders list from the ClientHello.),
      BREAK#3262,
    CONTENT#3263(   If the server responds with a HelloRetryRequest and the client then),
    CONTENT#3264(   sends ClientHello2, its binder will be computed over:),
      BREAK#3265,
    CONTENT#3266(      Transcript-Hash(ClientHello1,),
    CONTENT#3267(                      HelloRetryRequest,),
    CONTENT#3268(                      Truncate(ClientHello2))),
      BREAK#3269,
    CONTENT#3270(   The full ClientHello1/ClientHello2 is included in all other handshake),
    CONTENT#3271(   hash computations.  Note that in the first flight,),
    CONTENT#3272(   Truncate(ClientHello1) is hashed directly, but in the second flight,),
    CONTENT#3273(   ClientHello1 is hashed and then reinjected as a "message_hash"),
    CONTENT#3274(   message, as described in Section 4.4.1.),
      BREAK#3275,
    SECTION#3276(id=4.2.11.3, title=Processing Order),
      BREAK#3277,
    CONTENT#3278(   Clients are permitted to "stream" 0-RTT data until they receive the),
    CONTENT#3279(   server's Finished, only then sending the EndOfEarlyData message,),
    CONTENT#3280(   followed by the rest of the handshake.  In order to avoid deadlocks,),
    CONTENT#3281(   when accepting "early_data", servers MUST process the client's),
    CONTENT#3282(   ClientHello and then immediately send their flight of messages,),
    CONTENT#3283(   rather than waiting for the client's EndOfEarlyData message before),
    CONTENT#3284(   sending its ServerHello.),
      BREAK#3285,
    SECTION#3286(id=4.3, title=Server Parameters),
      BREAK#3287,
    CONTENT#3288(   The next two messages from the server, EncryptedExtensions and),
    CONTENT#3289(   CertificateRequest, contain information from the server that),
    CONTENT#3290(   determines the rest of the handshake.  These messages are encrypted),
    CONTENT#3291(   with keys derived from the server_handshake_traffic_secret.),
      BREAK#3292,
      BREAK#3293,
      BREAK#3294,
      BREAK#3295,
      BREAK#3296,
      BREAK#3297,
      BREAK#3298,
      BREAK#3299,
      BREAK#3300,
      BREAK#3301,
      BREAK#3302,
      BREAK#3303,
      BREAK#3304,
      BREAK#3306,
      BREAK#3308,
      BREAK#3309,
    SECTION#3310(id=4.3.1, title=Encrypted Extensions),
      BREAK#3311,
    CONTENT#3312(   In all handshakes, the server MUST send the EncryptedExtensions),
    CONTENT#3313(   message immediately after the ServerHello message.  This is the first),
    CONTENT#3314(   message that is encrypted under keys derived from the),
    CONTENT#3315(   server_handshake_traffic_secret.),
      BREAK#3316,
    CONTENT#3317(   The EncryptedExtensions message contains extensions that can be),
    CONTENT#3318(   protected, i.e., any which are not needed to establish the),
    CONTENT#3319(   cryptographic context but which are not associated with individual),
    CONTENT#3320(   certificates.  The client MUST check EncryptedExtensions for the),
    CONTENT#3321(   presence of any forbidden extensions and if any are found MUST abort),
    CONTENT#3322(   the handshake with an "illegal_parameter" alert.),
      BREAK#3323,
    CONTENT#3324(   Structure of this message:),
      BREAK#3325,
    CONTENT#3326(      struct {),
    CONTENT#3327(          Extension extensions<0..2^16-1>;),
    CONTENT#3328(      } EncryptedExtensions;),
      BREAK#3329,
    CONTENT#3330(   extensions:  A list of extensions.  For more information, see the),
    CONTENT#3331(      table in Section 4.2.),
      BREAK#3332,
    SECTION#3333(id=4.3.2, title=Certificate Request),
      BREAK#3334,
    CONTENT#3335(   A server which is authenticating with a certificate MAY optionally),
    CONTENT#3336(   request a certificate from the client.  This message, if sent, MUST),
    CONTENT#3337(   follow EncryptedExtensions.),
      BREAK#3338,
    CONTENT#3339(   Structure of this message:),
      BREAK#3340,
    CONTENT#3341(      struct {),
    CONTENT#3342(          opaque certificate_request_context<0..2^8-1>;),
    CONTENT#3343(          Extension extensions<2..2^16-1>;),
    CONTENT#3344(      } CertificateRequest;),
      BREAK#3345,
      BREAK#3346,
      BREAK#3347,
      BREAK#3348,
      BREAK#3349,
      BREAK#3350,
      BREAK#3351,
      BREAK#3352,
      BREAK#3353,
      BREAK#3354,
      BREAK#3355,
      BREAK#3356,
      BREAK#3357,
      BREAK#3358,
      BREAK#3359,
      BREAK#3360,
      BREAK#3362,
      BREAK#3364,
      BREAK#3365,
    CONTENT#3366(   certificate_request_context:  An opaque string which identifies the),
    CONTENT#3367(      certificate request and which will be echoed in the client's),
    CONTENT#3368(      Certificate message.  The certificate_request_context MUST be),
    CONTENT#3369(      unique within the scope of this connection (thus preventing replay),
    CONTENT#3370(      of client CertificateVerify messages).  This field SHALL be zero),
    CONTENT#3371(      length unless used for the post-handshake authentication exchanges),
    CONTENT#3372(      described in Section 4.6.2.  When requesting post-handshake),
    CONTENT#3373(      authentication, the server SHOULD make the context unpredictable),
    CONTENT#3374(      to the client (e.g., by randomly generating it) in order to),
    CONTENT#3375(      prevent an attacker who has temporary access to the client's),
    CONTENT#3376(      private key from pre-computing valid CertificateVerify messages.),
      BREAK#3377,
    CONTENT#3378(   extensions:  A set of extensions describing the parameters of the),
    CONTENT#3379(      certificate being requested.  The "signature_algorithms" extension),
    CONTENT#3380(      MUST be specified, and other extensions may optionally be included),
    CONTENT#3381(      if defined for this message.  Clients MUST ignore unrecognized),
    CONTENT#3382(      extensions.),
      BREAK#3383,
    CONTENT#3384(   In prior versions of TLS, the CertificateRequest message carried a),
    CONTENT#3385(   list of signature algorithms and certificate authorities which the),
    CONTENT#3386(   server would accept.  In TLS 1.3, the former is expressed by sending),
    CONTENT#3387(   the "signature_algorithms" and optionally "signature_algorithms_cert"),
    CONTENT#3388(   extensions.  The latter is expressed by sending the),
    CONTENT#3389(   "certificate_authorities" extension (see Section 4.2.4).),
      BREAK#3390,
    CONTENT#3391(   Servers which are authenticating with a PSK MUST NOT send the),
    CONTENT#3392(   CertificateRequest message in the main handshake, though they MAY),
    CONTENT#3393(   send it in post-handshake authentication (see Section 4.6.2) provided),
    CONTENT#3394(   that the client has sent the "post_handshake_auth" extension (see),
    CONTENT#3395(   Section 4.2.6).),
      BREAK#3396,
    SECTION#3397(id=4.4, title=Authentication Messages),
      BREAK#3398,
    CONTENT#3399(   As discussed in Section 2, TLS generally uses a common set of),
    CONTENT#3400(   messages for authentication, key confirmation, and handshake),
    CONTENT#3401(   integrity: Certificate, CertificateVerify, and Finished.  (The PSK),
    CONTENT#3402(   binders also perform key confirmation, in a similar fashion.)  These),
    CONTENT#3403(   three messages are always sent as the last messages in their),
    CONTENT#3404(   handshake flight.  The Certificate and CertificateVerify messages are),
    CONTENT#3405(   only sent under certain circumstances, as defined below.  The),
    CONTENT#3406(   Finished message is always sent as part of the Authentication Block.),
    CONTENT#3407(   These messages are encrypted under keys derived from the),
    CONTENT#3408(   [sender]_handshake_traffic_secret.),
      BREAK#3409,
      BREAK#3410,
      BREAK#3411,
      BREAK#3412,
      BREAK#3413,
      BREAK#3414,
      BREAK#3415,
      BREAK#3416,
      BREAK#3418,
      BREAK#3420,
      BREAK#3421,
    CONTENT#3422(   The computations for the Authentication messages all uniformly take),
    CONTENT#3423(   the following inputs:),
      BREAK#3424,
    CONTENT#3425(   -  The certificate and signing key to be used.),
      BREAK#3426,
    CONTENT#3427(   -  A Handshake Context consisting of the set of messages to be),
    CONTENT#3428(      included in the transcript hash.),
      BREAK#3429,
    CONTENT#3430(   -  A Base Key to be used to compute a MAC key.),
      BREAK#3431,
    CONTENT#3432(   Based on these inputs, the messages then contain:),
      BREAK#3433,
    CONTENT#3434(   Certificate:  The certificate to be used for authentication, and any),
    CONTENT#3435(      supporting certificates in the chain.  Note that certificate-based),
    CONTENT#3436(      client authentication is not available in PSK handshake flows),
    CONTENT#3437(      (including 0-RTT).),
      BREAK#3438,
    CONTENT#3439(   CertificateVerify:  A signature over the value),
    CONTENT#3440(      Transcript-Hash(Handshake Context, Certificate).),
      BREAK#3441,
    CONTENT#3442(   Finished:  A MAC over the value Transcript-Hash(Handshake Context,),
    CONTENT#3443(      Certificate, CertificateVerify) using a MAC key derived from the),
    CONTENT#3444(      Base Key.),
      BREAK#3445,
    CONTENT#3446(   The following table defines the Handshake Context and MAC Base Key),
    CONTENT#3447(   for each scenario:),
      BREAK#3448,
    CONTENT#3449(   +-----------+-------------------------+-----------------------------+),
    CONTENT#3450(   | Mode      | Handshake Context       | Base Key                    |),
    CONTENT#3451(   +-----------+-------------------------+-----------------------------+),
    CONTENT#3452(   | Server    | ClientHello ... later   | server_handshake_traffic_   |),
    CONTENT#3453(   |           | of EncryptedExtensions/ | secret                      |),
    CONTENT#3454(   |           | CertificateRequest      |                             |),
    CONTENT#3455(   |           |                         |                             |),
    CONTENT#3456(   | Client    | ClientHello ... later   | client_handshake_traffic_   |),
    CONTENT#3457(   |           | of server               | secret                      |),
    CONTENT#3458(   |           | Finished/EndOfEarlyData |                             |),
    CONTENT#3459(   |           |                         |                             |),
    CONTENT#3460(   | Post-     | ClientHello ... client  | client_application_traffic_ |),
    CONTENT#3461(   | Handshake | Finished +              | secret_N                    |),
    CONTENT#3462(   |           | CertificateRequest      |                             |),
    CONTENT#3463(   +-----------+-------------------------+-----------------------------+),
      BREAK#3464,
      BREAK#3465,
      BREAK#3466,
      BREAK#3467,
      BREAK#3468,
      BREAK#3469,
      BREAK#3470,
      BREAK#3471,
      BREAK#3472,
      BREAK#3474,
      BREAK#3476,
      BREAK#3477,
    SECTION#3478(id=4.4.1, title=The Transcript Hash),
      BREAK#3479,
    CONTENT#3480(   Many of the cryptographic computations in TLS make use of a),
    CONTENT#3481(   transcript hash.  This value is computed by hashing the concatenation),
    CONTENT#3482(   of each included handshake message, including the handshake message),
    CONTENT#3483(   header carrying the handshake message type and length fields, but not),
    CONTENT#3484(   including record layer headers.  I.e.,),
      BREAK#3485,
    CONTENT#3486(    Transcript-Hash(M1, M2, ... Mn) = Hash(M1 || M2 || ... || Mn)),
      BREAK#3487,
    CONTENT#3488(   As an exception to this general rule, when the server responds to a),
    CONTENT#3489(   ClientHello with a HelloRetryRequest, the value of ClientHello1 is),
    CONTENT#3490(   replaced with a special synthetic handshake message of handshake type),
    CONTENT#3491(   "message_hash" containing Hash(ClientHello1).  I.e.,),
      BREAK#3492,
    CONTENT#3493(  Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =),
    CONTENT#3494(      Hash(message_hash ||        /* Handshake type */),
    CONTENT#3495(           00 00 Hash.length  ||  /* Handshake message length (bytes) */),
    CONTENT#3496(           Hash(ClientHello1) ||  /* Hash of ClientHello1 */),
    CONTENT#3497(           HelloRetryRequest  || ... || Mn)),
      BREAK#3498,
    CONTENT#3499(   The reason for this construction is to allow the server to do a),
    CONTENT#3500(   stateless HelloRetryRequest by storing just the hash of ClientHello1),
    CONTENT#3501(   in the cookie, rather than requiring it to export the entire),
    CONTENT#3502(   intermediate hash state (see Section 4.2.2).),
      BREAK#3503,
    CONTENT#3504(   For concreteness, the transcript hash is always taken from the),
    CONTENT#3505(   following sequence of handshake messages, starting at the first),
    CONTENT#3506(   ClientHello and including only those messages that were sent:),
    CONTENT#3507(   ClientHello, HelloRetryRequest, ClientHello, ServerHello,),
    CONTENT#3508(   EncryptedExtensions, server CertificateRequest, server Certificate,),
    CONTENT#3509(   server CertificateVerify, server Finished, EndOfEarlyData, client),
    CONTENT#3510(   Certificate, client CertificateVerify, client Finished.),
      BREAK#3511,
    CONTENT#3512(   In general, implementations can implement the transcript by keeping a),
    CONTENT#3513(   running transcript hash value based on the negotiated hash.  Note,),
    CONTENT#3514(   however, that subsequent post-handshake authentications do not),
    CONTENT#3515(   include each other, just the messages through the end of the main),
    CONTENT#3516(   handshake.),
      BREAK#3517,
      BREAK#3518,
      BREAK#3519,
      BREAK#3520,
      BREAK#3521,
      BREAK#3522,
      BREAK#3523,
      BREAK#3524,
      BREAK#3525,
      BREAK#3526,
      BREAK#3527,
      BREAK#3528,
      BREAK#3530,
      BREAK#3532,
      BREAK#3533,
    SECTION#3534(id=4.4.2, title=Certificate),
      BREAK#3535,
    CONTENT#3536(   This message conveys the endpoint's certificate chain to the peer.),
      BREAK#3537,
    CONTENT#3538(   The server MUST send a Certificate message whenever the agreed-upon),
    CONTENT#3539(   key exchange method uses certificates for authentication (this),
    CONTENT#3540(   includes all key exchange methods defined in this document),
    CONTENT#3541(   except PSK).),
      BREAK#3542,
    CONTENT#3543(   The client MUST send a Certificate message if and only if the server),
    CONTENT#3544(   has requested client authentication via a CertificateRequest message),
    CONTENT#3545(   (Section 4.3.2).  If the server requests client authentication but no),
    CONTENT#3546(   suitable certificate is available, the client MUST send a Certificate),
    CONTENT#3547(   message containing no certificates (i.e., with the "certificate_list"),
    CONTENT#3548(   field having length 0).  A Finished message MUST be sent regardless),
    CONTENT#3549(   of whether the Certificate message is empty.),
      BREAK#3550,
    CONTENT#3551(   Structure of this message:),
      BREAK#3552,
    CONTENT#3553(      enum {),
    CONTENT#3554(          X509(0),),
    CONTENT#3555(          RawPublicKey(2),),
    CONTENT#3556(          (255)),
    CONTENT#3557(      } CertificateType;),
      BREAK#3558,
    CONTENT#3559(      struct {),
    CONTENT#3560(          select (certificate_type) {),
    CONTENT#3561(              case RawPublicKey:),
    CONTENT#3562(                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */),
    CONTENT#3563(                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;),
      BREAK#3564,
    CONTENT#3565(              case X509:),
    CONTENT#3566(                opaque cert_data<1..2^24-1>;),
    CONTENT#3567(          };),
    CONTENT#3568(          Extension extensions<0..2^16-1>;),
    CONTENT#3569(      } CertificateEntry;),
      BREAK#3570,
    CONTENT#3571(      struct {),
    CONTENT#3572(          opaque certificate_request_context<0..2^8-1>;),
    CONTENT#3573(          CertificateEntry certificate_list<0..2^24-1>;),
    CONTENT#3574(      } Certificate;),
      BREAK#3575,
      BREAK#3576,
      BREAK#3577,
      BREAK#3578,
      BREAK#3579,
      BREAK#3580,
      BREAK#3581,
      BREAK#3582,
      BREAK#3583,
      BREAK#3584,
      BREAK#3586,
      BREAK#3588,
      BREAK#3589,
    CONTENT#3590(   certificate_request_context:  If this message is in response to a),
    CONTENT#3591(      CertificateRequest, the value of certificate_request_context in),
    CONTENT#3592(      that message.  Otherwise (in the case of server authentication),),
    CONTENT#3593(      this field SHALL be zero length.),
      BREAK#3594,
    CONTENT#3595(   certificate_list:  A sequence (chain) of CertificateEntry structures,),
    CONTENT#3596(      each containing a single certificate and set of extensions.),
      BREAK#3597,
    CONTENT#3598(   extensions:  A set of extension values for the CertificateEntry.  The),
    CONTENT#3599(      "Extension" format is defined in Section 4.2.  Valid extensions),
    CONTENT#3600(      for server certificates at present include the OCSP Status),
    CONTENT#3601(      extension [RFC6066] and the SignedCertificateTimestamp extension),
    CONTENT#3602(      [RFC6962]; future extensions may be defined for this message as),
    CONTENT#3603(      well.  Extensions in the Certificate message from the server MUST),
    CONTENT#3604(      correspond to ones from the ClientHello message.  Extensions in),
    CONTENT#3605(      the Certificate message from the client MUST correspond to),
    CONTENT#3606(      extensions in the CertificateRequest message from the server.  If),
    CONTENT#3607(      an extension applies to the entire chain, it SHOULD be included in),
    CONTENT#3608(      the first CertificateEntry.),
      BREAK#3609,
    CONTENT#3610(   If the corresponding certificate type extension),
    CONTENT#3611(   ("server_certificate_type" or "client_certificate_type") was not),
    CONTENT#3612(   negotiated in EncryptedExtensions, or the X.509 certificate type was),
    CONTENT#3613(   negotiated, then each CertificateEntry contains a DER-encoded X.509),
    CONTENT#3614(   certificate.  The sender's certificate MUST come in the first),
    CONTENT#3615(   CertificateEntry in the list.  Each following certificate SHOULD),
    CONTENT#3616(   directly certify the one immediately preceding it.  Because),
    CONTENT#3617(   certificate validation requires that trust anchors be distributed),
    CONTENT#3618(   independently, a certificate that specifies a trust anchor MAY be),
    CONTENT#3619(   omitted from the chain, provided that supported peers are known to),
    CONTENT#3620(   possess any omitted certificates.),
      BREAK#3621,
    CONTENT#3622(   Note: Prior to TLS 1.3, "certificate_list" ordering required each),
    CONTENT#3623(   certificate to certify the one immediately preceding it; however,),
    CONTENT#3624(   some implementations allowed some flexibility.  Servers sometimes),
    CONTENT#3625(   send both a current and deprecated intermediate for transitional),
    CONTENT#3626(   purposes, and others are simply configured incorrectly, but these),
    CONTENT#3627(   cases can nonetheless be validated properly.  For maximum),
    CONTENT#3628(   compatibility, all implementations SHOULD be prepared to handle),
    CONTENT#3629(   potentially extraneous certificates and arbitrary orderings from any),
    CONTENT#3630(   TLS version, with the exception of the end-entity certificate which),
    CONTENT#3631(   MUST be first.),
      BREAK#3632,
    CONTENT#3633(   If the RawPublicKey certificate type was negotiated, then the),
    CONTENT#3634(   certificate_list MUST contain no more than one CertificateEntry,),
    CONTENT#3635(   which contains an ASN1_subjectPublicKeyInfo value as defined in),
    CONTENT#3636(   [RFC7250], Section 3.),
      BREAK#3637,
      BREAK#3638,
      BREAK#3639,
      BREAK#3640,
      BREAK#3642,
      BREAK#3644,
      BREAK#3645,
    CONTENT#3646(   The OpenPGP certificate type [RFC6091] MUST NOT be used with TLS 1.3.),
      BREAK#3647,
    CONTENT#3648(   The server's certificate_list MUST always be non-empty.  A client),
    CONTENT#3649(   will send an empty certificate_list if it does not have an),
    CONTENT#3650(   appropriate certificate to send in response to the server's),
    CONTENT#3651(   authentication request.),
      BREAK#3652,
    SECTION#3653(id=4.4.2.1, title=OCSP Status and SCT Extensions),
      BREAK#3654,
    CONTENT#3655(   [RFC6066] and [RFC6961] provide extensions to negotiate the server),
    CONTENT#3656(   sending OCSP responses to the client.  In TLS 1.2 and below, the),
    CONTENT#3657(   server replies with an empty extension to indicate negotiation of),
    CONTENT#3658(   this extension and the OCSP information is carried in a),
    CONTENT#3659(   CertificateStatus message.  In TLS 1.3, the server's OCSP information),
    CONTENT#3660(   is carried in an extension in the CertificateEntry containing the),
    CONTENT#3661(   associated certificate.  Specifically, the body of the),
    CONTENT#3662(   "status_request" extension from the server MUST be a),
    CONTENT#3663(   CertificateStatus structure as defined in [RFC6066], which is),
    CONTENT#3664(   interpreted as defined in [RFC6960].),
      BREAK#3665,
    CONTENT#3666(   Note: The status_request_v2 extension [RFC6961] is deprecated.),
    CONTENT#3667(   TLS 1.3 servers MUST NOT act upon its presence or information in it),
    CONTENT#3668(   when processing ClientHello messages; in particular, they MUST NOT),
    CONTENT#3669(   send the status_request_v2 extension in the EncryptedExtensions,),
    CONTENT#3670(   CertificateRequest, or Certificate messages.  TLS 1.3 servers MUST be),
    CONTENT#3671(   able to process ClientHello messages that include it, as it MAY be),
    CONTENT#3672(   sent by clients that wish to use it in earlier protocol versions.),
      BREAK#3673,
    CONTENT#3674(   A server MAY request that a client present an OCSP response with its),
    CONTENT#3675(   certificate by sending an empty "status_request" extension in its),
    CONTENT#3676(   CertificateRequest message.  If the client opts to send an OCSP),
    CONTENT#3677(   response, the body of its "status_request" extension MUST be a),
    CONTENT#3678(   CertificateStatus structure as defined in [RFC6066].),
      BREAK#3679,
    CONTENT#3680(   Similarly, [RFC6962] provides a mechanism for a server to send a),
    CONTENT#3681(   Signed Certificate Timestamp (SCT) as an extension in the ServerHello),
    CONTENT#3682(   in TLS 1.2 and below.  In TLS 1.3, the server's SCT information is),
    CONTENT#3683(   carried in an extension in the CertificateEntry.),
      BREAK#3684,
      BREAK#3685,
      BREAK#3686,
      BREAK#3687,
      BREAK#3688,
      BREAK#3689,
      BREAK#3690,
      BREAK#3691,
      BREAK#3692,
      BREAK#3693,
      BREAK#3694,
      BREAK#3695,
      BREAK#3696,
      BREAK#3698,
      BREAK#3700,
      BREAK#3701,
    SECTION#3702(id=4.4.2.2, title=Server Certificate Selection),
      BREAK#3703,
    CONTENT#3704(   The following rules apply to the certificates sent by the server:),
      BREAK#3705,
    CONTENT#3706(   -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly),
    CONTENT#3707(      negotiated otherwise (e.g., [RFC7250]).),
      BREAK#3708,
    CONTENT#3709(   -  The server's end-entity certificate's public key (and associated),
    CONTENT#3710(      restrictions) MUST be compatible with the selected authentication),
    CONTENT#3711(      algorithm from the client's "signature_algorithms" extension),
    CONTENT#3712(      (currently RSA, ECDSA, or EdDSA).),
      BREAK#3713,
    CONTENT#3714(   -  The certificate MUST allow the key to be used for signing (i.e.,),
    CONTENT#3715(      the digitalSignature bit MUST be set if the Key Usage extension is),
    CONTENT#3716(      present) with a signature scheme indicated in the client's),
    CONTENT#3717(      "signature_algorithms"/"signature_algorithms_cert" extensions (see),
    CONTENT#3718(      Section 4.2.3).),
      BREAK#3719,
    CONTENT#3720(   -  The "server_name" [RFC6066] and "certificate_authorities"),
    CONTENT#3721(      extensions are used to guide certificate selection.  As servers),
    CONTENT#3722(      MAY require the presence of the "server_name" extension, clients),
    CONTENT#3723(      SHOULD send this extension, when applicable.),
      BREAK#3724,
    CONTENT#3725(   All certificates provided by the server MUST be signed by a signature),
    CONTENT#3726(   algorithm advertised by the client if it is able to provide such a),
    CONTENT#3727(   chain (see Section 4.2.3).  Certificates that are self-signed or),
    CONTENT#3728(   certificates that are expected to be trust anchors are not validated),
    CONTENT#3729(   as part of the chain and therefore MAY be signed with any algorithm.),
      BREAK#3730,
    CONTENT#3731(   If the server cannot produce a certificate chain that is signed only),
    CONTENT#3732(   via the indicated supported algorithms, then it SHOULD continue the),
    CONTENT#3733(   handshake by sending the client a certificate chain of its choice),
    CONTENT#3734(   that may include algorithms that are not known to be supported by the),
    CONTENT#3735(   client.  This fallback chain SHOULD NOT use the deprecated SHA-1 hash),
    CONTENT#3736(   algorithm in general, but MAY do so if the client's advertisement),
    CONTENT#3737(   permits it, and MUST NOT do so otherwise.),
      BREAK#3738,
    CONTENT#3739(   If the client cannot construct an acceptable chain using the provided),
    CONTENT#3740(   certificates and decides to abort the handshake, then it MUST abort),
    CONTENT#3741(   the handshake with an appropriate certificate-related alert (by),
    CONTENT#3742(   default, "unsupported_certificate"; see Section 6.2 for more),
    CONTENT#3743(   information).),
      BREAK#3744,
    CONTENT#3745(   If the server has multiple certificates, it chooses one of them based),
    CONTENT#3746(   on the above-mentioned criteria (in addition to other criteria, such),
    CONTENT#3747(   as transport-layer endpoint, local configuration, and preferences).),
      BREAK#3748,
      BREAK#3749,
      BREAK#3750,
      BREAK#3751,
      BREAK#3752,
      BREAK#3754,
      BREAK#3756,
      BREAK#3757,
    SECTION#3758(id=4.4.2.3, title=Client Certificate Selection),
      BREAK#3759,
    CONTENT#3760(   The following rules apply to certificates sent by the client:),
      BREAK#3761,
    CONTENT#3762(   -  The certificate type MUST be X.509v3 [RFC5280], unless explicitly),
    CONTENT#3763(      negotiated otherwise (e.g., [RFC7250]).),
      BREAK#3764,
    CONTENT#3765(   -  If the "certificate_authorities" extension in the),
    CONTENT#3766(      CertificateRequest message was present, at least one of the),
    CONTENT#3767(      certificates in the certificate chain SHOULD be issued by one of),
    CONTENT#3768(      the listed CAs.),
      BREAK#3769,
    CONTENT#3770(   -  The certificates MUST be signed using an acceptable signature),
    CONTENT#3771(      algorithm, as described in Section 4.3.2.  Note that this relaxes),
    CONTENT#3772(      the constraints on certificate-signing algorithms found in prior),
    CONTENT#3773(      versions of TLS.),
      BREAK#3774,
    CONTENT#3775(   -  If the CertificateRequest message contained a non-empty),
    CONTENT#3776(      "oid_filters" extension, the end-entity certificate MUST match the),
    CONTENT#3777(      extension OIDs that are recognized by the client, as described in),
    CONTENT#3778(      Section 4.2.5.),
      BREAK#3779,
    SECTION#3780(id=4.4.2.4, title=Receiving a Certificate Message),
      BREAK#3781,
    CONTENT#3782(   In general, detailed certificate validation procedures are out of),
    CONTENT#3783(   scope for TLS (see [RFC5280]).  This section provides TLS-specific),
    CONTENT#3784(   requirements.),
      BREAK#3785,
    CONTENT#3786(   If the server supplies an empty Certificate message, the client MUST),
    CONTENT#3787(   abort the handshake with a "decode_error" alert.),
      BREAK#3788,
    CONTENT#3789(   If the client does not send any certificates (i.e., it sends an empty),
    CONTENT#3790(   Certificate message), the server MAY at its discretion either),
    CONTENT#3791(   continue the handshake without client authentication or abort the),
    CONTENT#3792(   handshake with a "certificate_required" alert.  Also, if some aspect),
    CONTENT#3793(   of the certificate chain was unacceptable (e.g., it was not signed by),
    CONTENT#3794(   a known, trusted CA), the server MAY at its discretion either),
    CONTENT#3795(   continue the handshake (considering the client unauthenticated) or),
    CONTENT#3796(   abort the handshake.),
      BREAK#3797,
    CONTENT#3798(   Any endpoint receiving any certificate which it would need to),
    CONTENT#3799(   validate using any signature algorithm using an MD5 hash MUST abort),
    CONTENT#3800(   the handshake with a "bad_certificate" alert.  SHA-1 is deprecated,),
    CONTENT#3801(   and it is RECOMMENDED that any endpoint receiving any certificate),
    CONTENT#3802(   which it would need to validate using any signature algorithm using a),
    CONTENT#3803(   SHA-1 hash abort the handshake with a "bad_certificate" alert.  For),
    CONTENT#3804(   clarity, this means that endpoints can accept these algorithms for),
    CONTENT#3805(   certificates that are self-signed or are trust anchors.),
      BREAK#3806,
      BREAK#3807,
      BREAK#3808,
      BREAK#3810,
      BREAK#3812,
      BREAK#3813,
    CONTENT#3814(   All endpoints are RECOMMENDED to transition to SHA-256 or better as),
    CONTENT#3815(   soon as possible to maintain interoperability with implementations),
    CONTENT#3816(   currently in the process of phasing out SHA-1 support.),
      BREAK#3817,
    CONTENT#3818(   Note that a certificate containing a key for one signature algorithm),
    CONTENT#3819(   MAY be signed using a different signature algorithm (for instance, an),
    CONTENT#3820(   RSA key signed with an ECDSA key).),
      BREAK#3821,
    SECTION#3822(id=4.4.3, title=Certificate Verify),
      BREAK#3823,
    CONTENT#3824(   This message is used to provide explicit proof that an endpoint),
    CONTENT#3825(   possesses the private key corresponding to its certificate.  The),
    CONTENT#3826(   CertificateVerify message also provides integrity for the handshake),
    CONTENT#3827(   up to this point.  Servers MUST send this message when authenticating),
    CONTENT#3828(   via a certificate.  Clients MUST send this message whenever),
    CONTENT#3829(   authenticating via a certificate (i.e., when the Certificate message),
    CONTENT#3830(   is non-empty).  When sent, this message MUST appear immediately after),
    CONTENT#3831(   the Certificate message and immediately prior to the Finished),
    CONTENT#3832(   message.),
      BREAK#3833,
    CONTENT#3834(   Structure of this message:),
      BREAK#3835,
    CONTENT#3836(      struct {),
    CONTENT#3837(          SignatureScheme algorithm;),
    CONTENT#3838(          opaque signature<0..2^16-1>;),
    CONTENT#3839(      } CertificateVerify;),
      BREAK#3840,
    CONTENT#3841(   The algorithm field specifies the signature algorithm used (see),
    CONTENT#3842(   Section 4.2.3 for the definition of this type).  The signature is a),
    CONTENT#3843(   digital signature using that algorithm.  The content that is covered),
    CONTENT#3844(   under the signature is the hash output as described in Section 4.4.1,),
    CONTENT#3845(   namely:),
      BREAK#3846,
    CONTENT#3847(      Transcript-Hash(Handshake Context, Certificate)),
      BREAK#3848,
    CONTENT#3849(   The digital signature is then computed over the concatenation of:),
      BREAK#3850,
    CONTENT#3851(   -  A string that consists of octet 32 (0x20) repeated 64 times),
      BREAK#3852,
    CONTENT#3853(   -  The context string),
      BREAK#3854,
    CONTENT#3855(   -  A single 0 byte which serves as the separator),
      BREAK#3856,
    CONTENT#3857(   -  The content to be signed),
      BREAK#3858,
      BREAK#3859,
      BREAK#3860,
      BREAK#3861,
      BREAK#3862,
      BREAK#3863,
      BREAK#3864,
      BREAK#3866,
      BREAK#3868,
      BREAK#3869,
    CONTENT#3870(   This structure is intended to prevent an attack on previous versions),
    CONTENT#3871(   of TLS in which the ServerKeyExchange format meant that attackers),
    CONTENT#3872(   could obtain a signature of a message with a chosen 32-byte prefix),
    CONTENT#3873(   (ClientHello.random).  The initial 64-byte pad clears that prefix),
    CONTENT#3874(   along with the server-controlled ServerHello.random.),
      BREAK#3875,
    CONTENT#3876(   The context string for a server signature is),
    CONTENT#3877(   "TLS 1.3, server CertificateVerify".  The context string for a),
    CONTENT#3878(   client signature is "TLS 1.3, client CertificateVerify".  It is),
    CONTENT#3879(   used to provide separation between signatures made in different),
    CONTENT#3880(   contexts, helping against potential cross-protocol attacks.),
      BREAK#3881,
    CONTENT#3882(   For example, if the transcript hash was 32 bytes of 01 (this length),
    CONTENT#3883(   would make sense for SHA-256), the content covered by the digital),
    CONTENT#3884(   signature for a server CertificateVerify would be:),
      BREAK#3885,
    CONTENT#3886(      2020202020202020202020202020202020202020202020202020202020202020),
    CONTENT#3887(      2020202020202020202020202020202020202020202020202020202020202020),
    CONTENT#3888(      544c5320312e332c207365727665722043657274696669636174655665726966),
    CONTENT#3889(      79),
    CONTENT#3890(      00),
    CONTENT#3891(      0101010101010101010101010101010101010101010101010101010101010101),
      BREAK#3892,
    CONTENT#3893(   On the sender side, the process for computing the signature field of),
    CONTENT#3894(   the CertificateVerify message takes as input:),
      BREAK#3895,
    CONTENT#3896(   -  The content covered by the digital signature),
      BREAK#3897,
    CONTENT#3898(   -  The private signing key corresponding to the certificate sent in),
    CONTENT#3899(      the previous message),
      BREAK#3900,
    CONTENT#3901(   If the CertificateVerify message is sent by a server, the signature),
    CONTENT#3902(   algorithm MUST be one offered in the client's "signature_algorithms"),
    CONTENT#3903(   extension unless no valid certificate chain can be produced without),
    CONTENT#3904(   unsupported algorithms (see Section 4.2.3).),
      BREAK#3905,
    CONTENT#3906(   If sent by a client, the signature algorithm used in the signature),
    CONTENT#3907(   MUST be one of those present in the supported_signature_algorithms),
    CONTENT#3908(   field of the "signature_algorithms" extension in the),
    CONTENT#3909(   CertificateRequest message.),
      BREAK#3910,
    CONTENT#3911(   In addition, the signature algorithm MUST be compatible with the key),
    CONTENT#3912(   in the sender's end-entity certificate.  RSA signatures MUST use an),
    CONTENT#3913(   RSASSA-PSS algorithm, regardless of whether RSASSA-PKCS1-v1_5),
    CONTENT#3914(   algorithms appear in "signature_algorithms".  The SHA-1 algorithm),
    CONTENT#3915(   MUST NOT be used in any signatures of CertificateVerify messages.),
      BREAK#3916,
      BREAK#3917,
      BREAK#3918,
      BREAK#3919,
      BREAK#3920,
      BREAK#3922,
      BREAK#3924,
      BREAK#3925,
    CONTENT#3926(   All SHA-1 signature algorithms in this specification are defined),
    CONTENT#3927(   solely for use in legacy certificates and are not valid for),
    CONTENT#3928(   CertificateVerify signatures.),
      BREAK#3929,
    CONTENT#3930(   The receiver of a CertificateVerify message MUST verify the signature),
    CONTENT#3931(   field.  The verification process takes as input:),
      BREAK#3932,
    CONTENT#3933(   -  The content covered by the digital signature),
      BREAK#3934,
    CONTENT#3935(   -  The public key contained in the end-entity certificate found in),
    CONTENT#3936(      the associated Certificate message),
      BREAK#3937,
    CONTENT#3938(   -  The digital signature received in the signature field of the),
    CONTENT#3939(      CertificateVerify message),
      BREAK#3940,
    CONTENT#3941(   If the verification fails, the receiver MUST terminate the handshake),
    CONTENT#3942(   with a "decrypt_error" alert.),
      BREAK#3943,
    SECTION#3944(id=4.4.4, title=Finished),
      BREAK#3945,
    CONTENT#3946(   The Finished message is the final message in the Authentication),
    CONTENT#3947(   Block.  It is essential for providing authentication of the handshake),
    CONTENT#3948(   and of the computed keys.),
      BREAK#3949,
    CONTENT#3950(   Recipients of Finished messages MUST verify that the contents are),
    CONTENT#3951(   correct and if incorrect MUST terminate the connection with a),
    CONTENT#3952(   "decrypt_error" alert.),
      BREAK#3953,
    CONTENT#3954(   Once a side has sent its Finished message and has received and),
    CONTENT#3955(   validated the Finished message from its peer, it may begin to send),
    CONTENT#3956(   and receive Application Data over the connection.  There are two),
    CONTENT#3957(   settings in which it is permitted to send data prior to receiving the),
    CONTENT#3958(   peer's Finished:),
      BREAK#3959,
    CONTENT#3960(   1.  Clients sending 0-RTT data as described in Section 4.2.10.),
      BREAK#3961,
    CONTENT#3962(   2.  Servers MAY send data after sending their first flight, but),
    CONTENT#3963(       because the handshake is not yet complete, they have no assurance),
    CONTENT#3964(       of either the peer's identity or its liveness (i.e., the),
    CONTENT#3965(       ClientHello might have been replayed).),
      BREAK#3966,
      BREAK#3967,
      BREAK#3968,
      BREAK#3969,
      BREAK#3970,
      BREAK#3971,
      BREAK#3972,
      BREAK#3973,
      BREAK#3974,
      BREAK#3975,
      BREAK#3976,
      BREAK#3978,
      BREAK#3980,
      BREAK#3981,
    CONTENT#3982(   The key used to compute the Finished message is computed from the),
    CONTENT#3983(   Base Key defined in Section 4.4 using HKDF (see Section 7.1).),
    CONTENT#3984(   Specifically:),
      BREAK#3985,
    CONTENT#3986(   finished_key =),
    CONTENT#3987(       HKDF-Expand-Label(BaseKey, "finished", "", Hash.length)),
      BREAK#3988,
    CONTENT#3989(   Structure of this message:),
      BREAK#3990,
    CONTENT#3991(      struct {),
    CONTENT#3992(          opaque verify_data[Hash.length];),
    CONTENT#3993(      } Finished;),
      BREAK#3994,
    CONTENT#3995(   The verify_data value is computed as follows:),
      BREAK#3996,
    CONTENT#3997(      verify_data =),
    CONTENT#3998(          HMAC(finished_key,),
    CONTENT#3999(               Transcript-Hash(Handshake Context,),
    CONTENT#4000(                               Certificate*, CertificateVerify*))),
      BREAK#4001,
    CONTENT#4002(      * Only included if present.),
      BREAK#4003,
    CONTENT#4004(   HMAC [RFC2104] uses the Hash algorithm for the handshake.  As noted),
    CONTENT#4005(   above, the HMAC input can generally be implemented by a running hash,),
    CONTENT#4006(   i.e., just the handshake hash at this point.),
      BREAK#4007,
    CONTENT#4008(   In previous versions of TLS, the verify_data was always 12 octets),
    CONTENT#4009(   long.  In TLS 1.3, it is the size of the HMAC output for the Hash),
    CONTENT#4010(   used for the handshake.),
      BREAK#4011,
    CONTENT#4012(   Note: Alerts and any other non-handshake record types are not),
    CONTENT#4013(   handshake messages and are not included in the hash computations.),
      BREAK#4014,
    CONTENT#4015(   Any records following a Finished message MUST be encrypted under the),
    CONTENT#4016(   appropriate application traffic key as described in Section 7.2.  In),
    CONTENT#4017(   particular, this includes any alerts sent by the server in response),
    CONTENT#4018(   to client Certificate and CertificateVerify messages.),
      BREAK#4019,
    SECTION#4020(id=4.5, title=End of Early Data),
      BREAK#4021,
    CONTENT#4022(      struct {} EndOfEarlyData;),
      BREAK#4023,
    CONTENT#4024(   If the server sent an "early_data" extension in EncryptedExtensions,),
    CONTENT#4025(   the client MUST send an EndOfEarlyData message after receiving the),
    CONTENT#4026(   server Finished.  If the server does not send an "early_data"),
    CONTENT#4027(   extension in EncryptedExtensions, then the client MUST NOT send an),
    CONTENT#4028(   EndOfEarlyData message.  This message indicates that all 0-RTT),
    CONTENT#4029(   application_data messages, if any, have been transmitted and that the),
      BREAK#4030,
      BREAK#4031,
      BREAK#4032,
      BREAK#4034,
      BREAK#4036,
      BREAK#4037,
    CONTENT#4038(   following records are protected under handshake traffic keys.),
    CONTENT#4039(   Servers MUST NOT send this message, and clients receiving it MUST),
    CONTENT#4040(   terminate the connection with an "unexpected_message" alert.  This),
    CONTENT#4041(   message is encrypted under keys derived from the),
    CONTENT#4042(   client_early_traffic_secret.),
      BREAK#4043,
    SECTION#4044(id=4.6, title=Post-Handshake Messages),
      BREAK#4045,
    CONTENT#4046(   TLS also allows other messages to be sent after the main handshake.),
    CONTENT#4047(   These messages use a handshake content type and are encrypted under),
    CONTENT#4048(   the appropriate application traffic key.),
      BREAK#4049,
    SECTION#4050(id=4.6.1, title=New Session Ticket Message),
      BREAK#4051,
    CONTENT#4052(   At any time after the server has received the client Finished),
    CONTENT#4053(   message, it MAY send a NewSessionTicket message.  This message),
    CONTENT#4054(   creates a unique association between the ticket value and a secret),
    CONTENT#4055(   PSK derived from the resumption master secret (see Section 7).),
      BREAK#4056,
    CONTENT#4057(   The client MAY use this PSK for future handshakes by including the),
    CONTENT#4058(   ticket value in the "pre_shared_key" extension in its ClientHello),
    CONTENT#4059(   (Section 4.2.11).  Servers MAY send multiple tickets on a single),
    CONTENT#4060(   connection, either immediately after each other or after specific),
    CONTENT#4061(   events (see Appendix C.4).  For instance, the server might send a new),
    CONTENT#4062(   ticket after post-handshake authentication in order to encapsulate),
    CONTENT#4063(   the additional client authentication state.  Multiple tickets are),
    CONTENT#4064(   useful for clients for a variety of purposes, including:),
      BREAK#4065,
    CONTENT#4066(   -  Opening multiple parallel HTTP connections.),
      BREAK#4067,
    CONTENT#4068(   -  Performing connection racing across interfaces and address),
    CONTENT#4069(      families via (for example) Happy Eyeballs [RFC8305] or related),
    CONTENT#4070(      techniques.),
      BREAK#4071,
    CONTENT#4072(   Any ticket MUST only be resumed with a cipher suite that has the same),
    CONTENT#4073(   KDF hash algorithm as that used to establish the original connection.),
      BREAK#4074,
    CONTENT#4075(   Clients MUST only resume if the new SNI value is valid for the server),
    CONTENT#4076(   certificate presented in the original session and SHOULD only resume),
    CONTENT#4077(   if the SNI value matches the one used in the original session.  The),
    CONTENT#4078(   latter is a performance optimization: normally, there is no reason to),
    CONTENT#4079(   expect that different servers covered by a single certificate would),
    CONTENT#4080(   be able to accept each other's tickets; hence, attempting resumption),
    CONTENT#4081(   in that case would waste a single-use ticket.  If such an indication),
    CONTENT#4082(   is provided (externally or by any other means), clients MAY resume),
    CONTENT#4083(   with a different SNI value.),
      BREAK#4084,
      BREAK#4085,
      BREAK#4086,
      BREAK#4087,
      BREAK#4088,
      BREAK#4090,
      BREAK#4092,
      BREAK#4093,
    CONTENT#4094(   On resumption, if reporting an SNI value to the calling application,),
    CONTENT#4095(   implementations MUST use the value sent in the resumption ClientHello),
    CONTENT#4096(   rather than the value sent in the previous session.  Note that if a),
    CONTENT#4097(   server implementation declines all PSK identities with different SNI),
    CONTENT#4098(   values, these two values are always the same.),
      BREAK#4099,
    CONTENT#4100(   Note: Although the resumption master secret depends on the client's),
    CONTENT#4101(   second flight, a server which does not request client authentication),
    CONTENT#4102(   MAY compute the remainder of the transcript independently and then),
    CONTENT#4103(   send a NewSessionTicket immediately upon sending its Finished rather),
    CONTENT#4104(   than waiting for the client Finished.  This might be appropriate in),
    CONTENT#4105(   cases where the client is expected to open multiple TLS connections),
    CONTENT#4106(   in parallel and would benefit from the reduced overhead of a),
    CONTENT#4107(   resumption handshake, for example.),
      BREAK#4108,
    CONTENT#4109(      struct {),
    CONTENT#4110(          uint32 ticket_lifetime;),
    CONTENT#4111(          uint32 ticket_age_add;),
    CONTENT#4112(          opaque ticket_nonce<0..255>;),
    CONTENT#4113(          opaque ticket<1..2^16-1>;),
    CONTENT#4114(          Extension extensions<0..2^16-2>;),
    CONTENT#4115(      } NewSessionTicket;),
      BREAK#4116,
    CONTENT#4117(   ticket_lifetime:  Indicates the lifetime in seconds as a 32-bit),
    CONTENT#4118(      unsigned integer in network byte order from the time of ticket),
    CONTENT#4119(      issuance.  Servers MUST NOT use any value greater than),
    CONTENT#4120(      604800 seconds (7 days).  The value of zero indicates that the),
    CONTENT#4121(      ticket should be discarded immediately.  Clients MUST NOT cache),
    CONTENT#4122(      tickets for longer than 7 days, regardless of the ticket_lifetime,),
    CONTENT#4123(      and MAY delete tickets earlier based on local policy.  A server),
    CONTENT#4124(      MAY treat a ticket as valid for a shorter period of time than what),
    CONTENT#4125(      is stated in the ticket_lifetime.),
      BREAK#4126,
    CONTENT#4127(   ticket_age_add:  A securely generated, random 32-bit value that is),
    CONTENT#4128(      used to obscure the age of the ticket that the client includes in),
    CONTENT#4129(      the "pre_shared_key" extension.  The client-side ticket age is),
    CONTENT#4130(      added to this value modulo 2^32 to obtain the value that is),
    CONTENT#4131(      transmitted by the client.  The server MUST generate a fresh value),
    CONTENT#4132(      for each ticket it sends.),
      BREAK#4133,
    CONTENT#4134(   ticket_nonce:  A per-ticket value that is unique across all tickets),
    CONTENT#4135(      issued on this connection.),
      BREAK#4136,
      BREAK#4137,
      BREAK#4138,
      BREAK#4139,
      BREAK#4140,
      BREAK#4141,
      BREAK#4142,
      BREAK#4143,
      BREAK#4144,
      BREAK#4146,
      BREAK#4148,
      BREAK#4149,
    CONTENT#4150(   ticket:  The value of the ticket to be used as the PSK identity.  The),
    CONTENT#4151(      ticket itself is an opaque label.  It MAY be either a database),
    CONTENT#4152(      lookup key or a self-encrypted and self-authenticated value.),
      BREAK#4153,
    CONTENT#4154(   extensions:  A set of extension values for the ticket.  The),
    CONTENT#4155(      "Extension" format is defined in Section 4.2.  Clients MUST ignore),
    CONTENT#4156(      unrecognized extensions.),
      BREAK#4157,
    CONTENT#4158(   The sole extension currently defined for NewSessionTicket is),
    CONTENT#4159(   "early_data", indicating that the ticket may be used to send 0-RTT),
    CONTENT#4160(   data (Section 4.2.10).  It contains the following value:),
      BREAK#4161,
    CONTENT#4162(   max_early_data_size:  The maximum amount of 0-RTT data that the),
    CONTENT#4163(      client is allowed to send when using this ticket, in bytes.  Only),
    CONTENT#4164(      Application Data payload (i.e., plaintext but not padding or the),
    CONTENT#4165(      inner content type byte) is counted.  A server receiving more than),
    CONTENT#4166(      max_early_data_size bytes of 0-RTT data SHOULD terminate the),
    CONTENT#4167(      connection with an "unexpected_message" alert.  Note that servers),
    CONTENT#4168(      that reject early data due to lack of cryptographic material will),
    CONTENT#4169(      be unable to differentiate padding from content, so clients),
    CONTENT#4170(      SHOULD NOT depend on being able to send large quantities of),
    CONTENT#4171(      padding in early data records.),
      BREAK#4172,
    CONTENT#4173(   The PSK associated with the ticket is computed as:),
      BREAK#4174,
    CONTENT#4175(       HKDF-Expand-Label(resumption_master_secret,),
    CONTENT#4176(                        "resumption", ticket_nonce, Hash.length)),
      BREAK#4177,
    CONTENT#4178(   Because the ticket_nonce value is distinct for each NewSessionTicket),
    CONTENT#4179(   message, a different PSK will be derived for each ticket.),
      BREAK#4180,
    CONTENT#4181(   Note that in principle it is possible to continue issuing new tickets),
    CONTENT#4182(   which indefinitely extend the lifetime of the keying material),
    CONTENT#4183(   originally derived from an initial non-PSK handshake (which was most),
    CONTENT#4184(   likely tied to the peer's certificate).  It is RECOMMENDED that),
    CONTENT#4185(   implementations place limits on the total lifetime of such keying),
    CONTENT#4186(   material; these limits should take into account the lifetime of the),
    CONTENT#4187(   peer's certificate, the likelihood of intervening revocation, and the),
    CONTENT#4188(   time since the peer's online CertificateVerify signature.),
      BREAK#4189,
    SECTION#4190(id=4.6.2, title=Post-Handshake Authentication),
      BREAK#4191,
    CONTENT#4192(   When the client has sent the "post_handshake_auth" extension (see),
    CONTENT#4193(   Section 4.2.6), a server MAY request client authentication at any),
    CONTENT#4194(   time after the handshake has completed by sending a),
    CONTENT#4195(   CertificateRequest message.  The client MUST respond with the),
    CONTENT#4196(   appropriate Authentication messages (see Section 4.4).  If the client),
    CONTENT#4197(   chooses to authenticate, it MUST send Certificate, CertificateVerify,),
      BREAK#4198,
      BREAK#4199,
      BREAK#4200,
      BREAK#4202,
      BREAK#4204,
      BREAK#4205,
    CONTENT#4206(   and Finished.  If it declines, it MUST send a Certificate message),
    CONTENT#4207(   containing no certificates followed by Finished.  All of the client's),
    CONTENT#4208(   messages for a given response MUST appear consecutively on the wire),
    CONTENT#4209(   with no intervening messages of other types.),
      BREAK#4210,
    CONTENT#4211(   A client that receives a CertificateRequest message without having),
    CONTENT#4212(   sent the "post_handshake_auth" extension MUST send an),
    CONTENT#4213(   "unexpected_message" fatal alert.),
      BREAK#4214,
    CONTENT#4215(   Note: Because client authentication could involve prompting the user,),
    CONTENT#4216(   servers MUST be prepared for some delay, including receiving an),
    CONTENT#4217(   arbitrary number of other messages between sending the),
    CONTENT#4218(   CertificateRequest and receiving a response.  In addition, clients),
    CONTENT#4219(   which receive multiple CertificateRequests in close succession MAY),
    CONTENT#4220(   respond to them in a different order than they were received (the),
    CONTENT#4221(   certificate_request_context value allows the server to disambiguate),
    CONTENT#4222(   the responses).),
      BREAK#4223,
    SECTION#4224(id=4.6.3, title=Key and Initialization Vector Update),
      BREAK#4225,
    CONTENT#4226(   The KeyUpdate handshake message is used to indicate that the sender),
    CONTENT#4227(   is updating its sending cryptographic keys.  This message can be sent),
    CONTENT#4228(   by either peer after it has sent a Finished message.  Implementations),
    CONTENT#4229(   that receive a KeyUpdate message prior to receiving a Finished),
    CONTENT#4230(   message MUST terminate the connection with an "unexpected_message"),
    CONTENT#4231(   alert.  After sending a KeyUpdate message, the sender SHALL send all),
    CONTENT#4232(   its traffic using the next generation of keys, computed as described),
    CONTENT#4233(   in Section 7.2.  Upon receiving a KeyUpdate, the receiver MUST update),
    CONTENT#4234(   its receiving keys.),
      BREAK#4235,
    CONTENT#4236(      enum {),
    CONTENT#4237(          update_not_requested(0), update_requested(1), (255)),
    CONTENT#4238(      } KeyUpdateRequest;),
      BREAK#4239,
    CONTENT#4240(      struct {),
    CONTENT#4241(          KeyUpdateRequest request_update;),
    CONTENT#4242(      } KeyUpdate;),
      BREAK#4243,
    CONTENT#4244(   request_update:  Indicates whether the recipient of the KeyUpdate),
    CONTENT#4245(      should respond with its own KeyUpdate.  If an implementation),
    CONTENT#4246(      receives any other value, it MUST terminate the connection with an),
    CONTENT#4247(      "illegal_parameter" alert.),
      BREAK#4248,
    CONTENT#4249(   If the request_update field is set to "update_requested", then the),
    CONTENT#4250(   receiver MUST send a KeyUpdate of its own with request_update set to),
    CONTENT#4251(   "update_not_requested" prior to sending its next Application Data),
    CONTENT#4252(   record.  This mechanism allows either side to force an update to the),
    CONTENT#4253(   entire connection, but causes an implementation which receives),
      BREAK#4254,
      BREAK#4255,
      BREAK#4256,
      BREAK#4258,
      BREAK#4260,
      BREAK#4261,
    CONTENT#4262(   multiple KeyUpdates while it is silent to respond with a single),
    CONTENT#4263(   update.  Note that implementations may receive an arbitrary number of),
    CONTENT#4264(   messages between sending a KeyUpdate with request_update set to),
    CONTENT#4265(   "update_requested" and receiving the peer's KeyUpdate, because those),
    CONTENT#4266(   messages may already be in flight.  However, because send and receive),
    CONTENT#4267(   keys are derived from independent traffic secrets, retaining the),
    CONTENT#4268(   receive traffic secret does not threaten the forward secrecy of data),
    CONTENT#4269(   sent before the sender changed keys.),
      BREAK#4270,
    CONTENT#4271(   If implementations independently send their own KeyUpdates with),
    CONTENT#4272(   request_update set to "update_requested" and they cross in flight,),
    CONTENT#4273(   then each side will also send a response, with the result that each),
    CONTENT#4274(   side increments by two generations.),
      BREAK#4275,
    CONTENT#4276(   Both sender and receiver MUST encrypt their KeyUpdate messages with),
    CONTENT#4277(   the old keys.  Additionally, both sides MUST enforce that a KeyUpdate),
    CONTENT#4278(   with the old key is received before accepting any messages encrypted),
    CONTENT#4279(   with the new key.  Failure to do so may allow message truncation),
    CONTENT#4280(   attacks.),
      BREAK#4281,
    SECTION#4282(id=5, title=Record Protocol),
      BREAK#4283,
    CONTENT#4284(   The TLS record protocol takes messages to be transmitted, fragments),
    CONTENT#4285(   the data into manageable blocks, protects the records, and transmits),
    CONTENT#4286(   the result.  Received data is verified, decrypted, reassembled, and),
    CONTENT#4287(   then delivered to higher-level clients.),
      BREAK#4288,
    CONTENT#4289(   TLS records are typed, which allows multiple higher-level protocols),
    CONTENT#4290(   to be multiplexed over the same record layer.  This document),
    CONTENT#4291(   specifies four content types: handshake, application_data, alert, and),
    CONTENT#4292(   change_cipher_spec.  The change_cipher_spec record is used only for),
    CONTENT#4293(   compatibility purposes (see Appendix D.4).),
      BREAK#4294,
    CONTENT#4295(   An implementation may receive an unencrypted record of type),
    CONTENT#4296(   change_cipher_spec consisting of the single byte value 0x01 at any),
    CONTENT#4297(   time after the first ClientHello message has been sent or received),
    CONTENT#4298(   and before the peer's Finished message has been received and MUST),
    CONTENT#4299(   simply drop it without further processing.  Note that this record may),
    CONTENT#4300(   appear at a point at the handshake where the implementation is),
    CONTENT#4301(   expecting protected records, and so it is necessary to detect this),
    CONTENT#4302(   condition prior to attempting to deprotect the record.  An),
    CONTENT#4303(   implementation which receives any other change_cipher_spec value or),
    CONTENT#4304(   which receives a protected change_cipher_spec record MUST abort the),
    CONTENT#4305(   handshake with an "unexpected_message" alert.  If an implementation),
    CONTENT#4306(   detects a change_cipher_spec record received before the first),
    CONTENT#4307(   ClientHello message or after the peer's Finished message, it MUST be),
    CONTENT#4308(   treated as an unexpected record type (though stateless servers may),
    CONTENT#4309(   not be able to distinguish these cases from allowed cases).),
      BREAK#4310,
      BREAK#4311,
      BREAK#4312,
      BREAK#4314,
      BREAK#4316,
      BREAK#4317,
    CONTENT#4318(   Implementations MUST NOT send record types not defined in this),
    CONTENT#4319(   document unless negotiated by some extension.  If a TLS),
    CONTENT#4320(   implementation receives an unexpected record type, it MUST terminate),
    CONTENT#4321(   the connection with an "unexpected_message" alert.  New record),
    CONTENT#4322(   content type values are assigned by IANA in the TLS ContentType),
    CONTENT#4323(   registry as described in Section 11.),
      BREAK#4324,
    SECTION#4325(id=5.1, title=Record Layer),
      BREAK#4326,
    CONTENT#4327(   The record layer fragments information blocks into TLSPlaintext),
    CONTENT#4328(   records carrying data in chunks of 2^14 bytes or less.  Message),
    CONTENT#4329(   boundaries are handled differently depending on the underlying),
    CONTENT#4330(   ContentType.  Any future content types MUST specify appropriate),
    CONTENT#4331(   rules.  Note that these rules are stricter than what was enforced in),
    CONTENT#4332(   TLS 1.2.),
      BREAK#4333,
    CONTENT#4334(   Handshake messages MAY be coalesced into a single TLSPlaintext record),
    CONTENT#4335(   or fragmented across several records, provided that:),
      BREAK#4336,
    CONTENT#4337(   -  Handshake messages MUST NOT be interleaved with other record),
    CONTENT#4338(      types.  That is, if a handshake message is split over two or more),
    CONTENT#4339(      records, there MUST NOT be any other records between them.),
      BREAK#4340,
    CONTENT#4341(   -  Handshake messages MUST NOT span key changes.  Implementations),
    CONTENT#4342(      MUST verify that all messages immediately preceding a key change),
    CONTENT#4343(      align with a record boundary; if not, then they MUST terminate the),
    CONTENT#4344(      connection with an "unexpected_message" alert.  Because the),
    CONTENT#4345(      ClientHello, EndOfEarlyData, ServerHello, Finished, and KeyUpdate),
    CONTENT#4346(      messages can immediately precede a key change, implementations),
    CONTENT#4347(      MUST send these messages in alignment with a record boundary.),
      BREAK#4348,
    CONTENT#4349(   Implementations MUST NOT send zero-length fragments of Handshake),
    CONTENT#4350(   types, even if those fragments contain padding.),
      BREAK#4351,
    CONTENT#4352(   Alert messages (Section 6) MUST NOT be fragmented across records, and),
    CONTENT#4353(   multiple alert messages MUST NOT be coalesced into a single),
    CONTENT#4354(   TLSPlaintext record.  In other words, a record with an Alert type),
    CONTENT#4355(   MUST contain exactly one message.),
      BREAK#4356,
    CONTENT#4357(   Application Data messages contain data that is opaque to TLS.),
    CONTENT#4358(   Application Data messages are always protected.  Zero-length),
    CONTENT#4359(   fragments of Application Data MAY be sent, as they are potentially),
    CONTENT#4360(   useful as a traffic analysis countermeasure.  Application Data),
    CONTENT#4361(   fragments MAY be split across multiple records or coalesced into a),
    CONTENT#4362(   single record.),
      BREAK#4363,
      BREAK#4364,
      BREAK#4365,
      BREAK#4366,
      BREAK#4367,
      BREAK#4368,
      BREAK#4370,
      BREAK#4372,
      BREAK#4373,
    CONTENT#4374(      enum {),
    CONTENT#4375(          invalid(0),),
    CONTENT#4376(          change_cipher_spec(20),),
    CONTENT#4377(          alert(21),),
    CONTENT#4378(          handshake(22),),
    CONTENT#4379(          application_data(23),),
    CONTENT#4380(          (255)),
    CONTENT#4381(      } ContentType;),
      BREAK#4382,
    CONTENT#4383(      struct {),
    CONTENT#4384(          ContentType type;),
    CONTENT#4385(          ProtocolVersion legacy_record_version;),
    CONTENT#4386(          uint16 length;),
    CONTENT#4387(          opaque fragment[TLSPlaintext.length];),
    CONTENT#4388(      } TLSPlaintext;),
      BREAK#4389,
    CONTENT#4390(   type:  The higher-level protocol used to process the enclosed),
    CONTENT#4391(      fragment.),
      BREAK#4392,
    CONTENT#4393(   legacy_record_version:  MUST be set to 0x0303 for all records),
    CONTENT#4394(      generated by a TLS 1.3 implementation other than an initial),
    CONTENT#4395(      ClientHello (i.e., one not generated after a HelloRetryRequest),),
    CONTENT#4396(      where it MAY also be 0x0301 for compatibility purposes.  This),
    CONTENT#4397(      field is deprecated and MUST be ignored for all purposes.),
    CONTENT#4398(      Previous versions of TLS would use other values in this field),
    CONTENT#4399(      under some circumstances.),
      BREAK#4400,
    CONTENT#4401(   length:  The length (in bytes) of the following),
    CONTENT#4402(      TLSPlaintext.fragment.  The length MUST NOT exceed 2^14 bytes.  An),
    CONTENT#4403(      endpoint that receives a record that exceeds this length MUST),
    CONTENT#4404(      terminate the connection with a "record_overflow" alert.),
      BREAK#4405,
    CONTENT#4406(   fragment:  The data being transmitted.  This value is transparent and),
    CONTENT#4407(      is treated as an independent block to be dealt with by the higher-),
    CONTENT#4408(      level protocol specified by the type field.),
      BREAK#4409,
    CONTENT#4410(   This document describes TLS 1.3, which uses the version 0x0304.  This),
    CONTENT#4411(   version value is historical, deriving from the use of 0x0301 for),
    CONTENT#4412(   TLS 1.0 and 0x0300 for SSL 3.0.  In order to maximize backward),
    CONTENT#4413(   compatibility, a record containing an initial ClientHello SHOULD have),
    CONTENT#4414(   version 0x0301 (reflecting TLS 1.0) and a record containing a second),
    CONTENT#4415(   ClientHello or a ServerHello MUST have version 0x0303 (reflecting),
    CONTENT#4416(   TLS 1.2).  When negotiating prior versions of TLS, endpoints follow),
    CONTENT#4417(   the procedure and requirements provided in Appendix D.),
      BREAK#4418,
      BREAK#4419,
      BREAK#4420,
      BREAK#4421,
      BREAK#4422,
      BREAK#4423,
      BREAK#4424,
      BREAK#4426,
      BREAK#4428,
      BREAK#4429,
    CONTENT#4430(   When record protection has not yet been engaged, TLSPlaintext),
    CONTENT#4431(   structures are written directly onto the wire.  Once record),
    CONTENT#4432(   protection has started, TLSPlaintext records are protected and sent),
    CONTENT#4433(   as described in the following section.  Note that Application Data),
    CONTENT#4434(   records MUST NOT be written to the wire unprotected (see Section 2),
    CONTENT#4435(   for details).),
      BREAK#4436,
    SECTION#4437(id=5.2, title=Record Payload Protection),
      BREAK#4438,
    CONTENT#4439(   The record protection functions translate a TLSPlaintext structure),
    CONTENT#4440(   into a TLSCiphertext structure.  The deprotection functions reverse),
    CONTENT#4441(   the process.  In TLS 1.3, as opposed to previous versions of TLS, all),
    CONTENT#4442(   ciphers are modeled as "Authenticated Encryption with Associated),
    CONTENT#4443(   Data" (AEAD) [RFC5116].  AEAD functions provide a unified encryption),
    CONTENT#4444(   and authentication operation which turns plaintext into authenticated),
    CONTENT#4445(   ciphertext and back again.  Each encrypted record consists of a),
    CONTENT#4446(   plaintext header followed by an encrypted body, which itself contains),
    CONTENT#4447(   a type and optional padding.),
      BREAK#4448,
    CONTENT#4449(      struct {),
    CONTENT#4450(          opaque content[TLSPlaintext.length];),
    CONTENT#4451(          ContentType type;),
    CONTENT#4452(          uint8 zeros[length_of_padding];),
    CONTENT#4453(      } TLSInnerPlaintext;),
      BREAK#4454,
    CONTENT#4455(      struct {),
    CONTENT#4456(          ContentType opaque_type = application_data; /* 23 */),
    CONTENT#4457(          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */),
    CONTENT#4458(          uint16 length;),
    CONTENT#4459(          opaque encrypted_record[TLSCiphertext.length];),
    CONTENT#4460(      } TLSCiphertext;),
      BREAK#4461,
    CONTENT#4462(   content:  The TLSPlaintext.fragment value, containing the byte),
    CONTENT#4463(      encoding of a handshake or an alert message, or the raw bytes of),
    CONTENT#4464(      the application's data to send.),
      BREAK#4465,
    CONTENT#4466(   type:  The TLSPlaintext.type value containing the content type of the),
    CONTENT#4467(      record.),
      BREAK#4468,
    CONTENT#4469(   zeros:  An arbitrary-length run of zero-valued bytes may appear in),
    CONTENT#4470(      the cleartext after the type field.  This provides an opportunity),
    CONTENT#4471(      for senders to pad any TLS record by a chosen amount as long as),
    CONTENT#4472(      the total stays within record size limits.  See Section 5.4 for),
    CONTENT#4473(      more details.),
      BREAK#4474,
      BREAK#4475,
      BREAK#4476,
      BREAK#4477,
      BREAK#4478,
      BREAK#4479,
      BREAK#4480,
      BREAK#4482,
      BREAK#4484,
      BREAK#4485,
    CONTENT#4486(   opaque_type:  The outer opaque_type field of a TLSCiphertext record),
    CONTENT#4487(      is always set to the value 23 (application_data) for outward),
    CONTENT#4488(      compatibility with middleboxes accustomed to parsing previous),
    CONTENT#4489(      versions of TLS.  The actual content type of the record is found),
    CONTENT#4490(      in TLSInnerPlaintext.type after decryption.),
      BREAK#4491,
    CONTENT#4492(   legacy_record_version:  The legacy_record_version field is always),
    CONTENT#4493(      0x0303.  TLS 1.3 TLSCiphertexts are not generated until after),
    CONTENT#4494(      TLS 1.3 has been negotiated, so there are no historical),
    CONTENT#4495(      compatibility concerns where other values might be received.  Note),
    CONTENT#4496(      that the handshake protocol, including the ClientHello and),
    CONTENT#4497(      ServerHello messages, authenticates the protocol version, so this),
    CONTENT#4498(      value is redundant.),
      BREAK#4499,
    CONTENT#4500(   length:  The length (in bytes) of the following),
    CONTENT#4501(      TLSCiphertext.encrypted_record, which is the sum of the lengths of),
    CONTENT#4502(      the content and the padding, plus one for the inner content type,),
    CONTENT#4503(      plus any expansion added by the AEAD algorithm.  The length),
    CONTENT#4504(      MUST NOT exceed 2^14 + 256 bytes.  An endpoint that receives a),
    CONTENT#4505(      record that exceeds this length MUST terminate the connection with),
    CONTENT#4506(      a "record_overflow" alert.),
      BREAK#4507,
    CONTENT#4508(   encrypted_record:  The AEAD-encrypted form of the serialized),
    CONTENT#4509(      TLSInnerPlaintext structure.),
      BREAK#4510,
    CONTENT#4511(   AEAD algorithms take as input a single key, a nonce, a plaintext, and),
    CONTENT#4512(   "additional data" to be included in the authentication check, as),
    CONTENT#4513(   described in Section 2.1 of [RFC5116].  The key is either the),
    CONTENT#4514(   client_write_key or the server_write_key, the nonce is derived from),
    CONTENT#4515(   the sequence number and the client_write_iv or server_write_iv (see),
    CONTENT#4516(   Section 5.3), and the additional data input is the record header.),
      BREAK#4517,
    CONTENT#4518(   I.e.,),
      BREAK#4519,
    CONTENT#4520(      additional_data = TLSCiphertext.opaque_type ||),
    CONTENT#4521(                        TLSCiphertext.legacy_record_version ||),
    CONTENT#4522(                        TLSCiphertext.length),
      BREAK#4523,
    CONTENT#4524(   The plaintext input to the AEAD algorithm is the encoded),
    CONTENT#4525(   TLSInnerPlaintext structure.  Derivation of traffic keys is defined),
    CONTENT#4526(   in Section 7.3.),
      BREAK#4527,
    CONTENT#4528(   The AEAD output consists of the ciphertext output from the AEAD),
    CONTENT#4529(   encryption operation.  The length of the plaintext is greater than),
    CONTENT#4530(   the corresponding TLSPlaintext.length due to the inclusion of),
    CONTENT#4531(   TLSInnerPlaintext.type and any padding supplied by the sender.  The),
    CONTENT#4532(   length of the AEAD output will generally be larger than the),
    CONTENT#4533(   plaintext, but by an amount that varies with the AEAD algorithm.),
      BREAK#4534,
      BREAK#4535,
      BREAK#4536,
      BREAK#4538,
      BREAK#4540,
      BREAK#4541,
    CONTENT#4542(   Since the ciphers might incorporate padding, the amount of overhead),
    CONTENT#4543(   could vary with different lengths of plaintext.  Symbolically,),
      BREAK#4544,
    CONTENT#4545(      AEADEncrypted =),
    CONTENT#4546(          AEAD-Encrypt(write_key, nonce, additional_data, plaintext)),
      BREAK#4547,
    CONTENT#4548(   The encrypted_record field of TLSCiphertext is set to AEADEncrypted.),
      BREAK#4549,
    CONTENT#4550(   In order to decrypt and verify, the cipher takes as input the key,),
    CONTENT#4551(   nonce, additional data, and the AEADEncrypted value.  The output is),
    CONTENT#4552(   either the plaintext or an error indicating that the decryption),
    CONTENT#4553(   failed.  There is no separate integrity check.  Symbolically,),
      BREAK#4554,
    CONTENT#4555(      plaintext of encrypted_record =),
    CONTENT#4556(          AEAD-Decrypt(peer_write_key, nonce,),
    CONTENT#4557(                       additional_data, AEADEncrypted)),
      BREAK#4558,
    CONTENT#4559(   If the decryption fails, the receiver MUST terminate the connection),
    CONTENT#4560(   with a "bad_record_mac" alert.),
      BREAK#4561,
    CONTENT#4562(   An AEAD algorithm used in TLS 1.3 MUST NOT produce an expansion),
    CONTENT#4563(   greater than 255 octets.  An endpoint that receives a record from its),
    CONTENT#4564(   peer with TLSCiphertext.length larger than 2^14 + 256 octets MUST),
    CONTENT#4565(   terminate the connection with a "record_overflow" alert.  This limit),
    CONTENT#4566(   is derived from the maximum TLSInnerPlaintext length of 2^14 octets +),
    CONTENT#4567(   1 octet for ContentType + the maximum AEAD expansion of 255 octets.),
      BREAK#4568,
    SECTION#4569(id=5.3, title=Per-Record Nonce),
      BREAK#4570,
    CONTENT#4571(   A 64-bit sequence number is maintained separately for reading and),
    CONTENT#4572(   writing records.  The appropriate sequence number is incremented by),
    CONTENT#4573(   one after reading or writing each record.  Each sequence number is),
    CONTENT#4574(   set to zero at the beginning of a connection and whenever the key is),
    CONTENT#4575(   changed; the first record transmitted under a particular traffic key),
    CONTENT#4576(   MUST use sequence number 0.),
      BREAK#4577,
    CONTENT#4578(   Because the size of sequence numbers is 64-bit, they should not wrap.),
    CONTENT#4579(   If a TLS implementation would need to wrap a sequence number, it MUST),
    CONTENT#4580(   either rekey (Section 4.6.3) or terminate the connection.),
      BREAK#4581,
      BREAK#4582,
      BREAK#4583,
      BREAK#4584,
      BREAK#4585,
      BREAK#4586,
      BREAK#4587,
      BREAK#4588,
      BREAK#4589,
      BREAK#4590,
      BREAK#4591,
      BREAK#4592,
      BREAK#4594,
      BREAK#4596,
      BREAK#4597,
    CONTENT#4598(   Each AEAD algorithm will specify a range of possible lengths for the),
    CONTENT#4599(   per-record nonce, from N_MIN bytes to N_MAX bytes of input [RFC5116].),
    CONTENT#4600(   The length of the TLS per-record nonce (iv_length) is set to the),
    CONTENT#4601(   larger of 8 bytes and N_MIN for the AEAD algorithm (see [RFC5116],),
    CONTENT#4602(   Section 4).  An AEAD algorithm where N_MAX is less than 8 bytes),
    CONTENT#4603(   MUST NOT be used with TLS.  The per-record nonce for the AEAD),
    CONTENT#4604(   construction is formed as follows:),
      BREAK#4605,
    CONTENT#4606(   1.  The 64-bit record sequence number is encoded in network byte),
    CONTENT#4607(       order and padded to the left with zeros to iv_length.),
      BREAK#4608,
    CONTENT#4609(   2.  The padded sequence number is XORed with either the static),
    CONTENT#4610(       client_write_iv or server_write_iv (depending on the role).),
      BREAK#4611,
    CONTENT#4612(   The resulting quantity (of length iv_length) is used as the),
    CONTENT#4613(   per-record nonce.),
      BREAK#4614,
    CONTENT#4615(   Note: This is a different construction from that in TLS 1.2, which),
    CONTENT#4616(   specified a partially explicit nonce.),
      BREAK#4617,
    SECTION#4618(id=5.4, title=Record Padding),
      BREAK#4619,
    CONTENT#4620(   All encrypted TLS records can be padded to inflate the size of the),
    CONTENT#4621(   TLSCiphertext.  This allows the sender to hide the size of the),
    CONTENT#4622(   traffic from an observer.),
      BREAK#4623,
    CONTENT#4624(   When generating a TLSCiphertext record, implementations MAY choose to),
    CONTENT#4625(   pad.  An unpadded record is just a record with a padding length of),
    CONTENT#4626(   zero.  Padding is a string of zero-valued bytes appended to the),
    CONTENT#4627(   ContentType field before encryption.  Implementations MUST set the),
    CONTENT#4628(   padding octets to all zeros before encrypting.),
      BREAK#4629,
    CONTENT#4630(   Application Data records may contain a zero-length),
    CONTENT#4631(   TLSInnerPlaintext.content if the sender desires.  This permits),
    CONTENT#4632(   generation of plausibly sized cover traffic in contexts where the),
    CONTENT#4633(   presence or absence of activity may be sensitive.  Implementations),
    CONTENT#4634(   MUST NOT send Handshake and Alert records that have a zero-length),
    CONTENT#4635(   TLSInnerPlaintext.content; if such a message is received, the),
    CONTENT#4636(   receiving implementation MUST terminate the connection with an),
    CONTENT#4637(   "unexpected_message" alert.),
      BREAK#4638,
      BREAK#4639,
      BREAK#4640,
      BREAK#4641,
      BREAK#4642,
      BREAK#4643,
      BREAK#4644,
      BREAK#4645,
      BREAK#4646,
      BREAK#4647,
      BREAK#4648,
      BREAK#4650,
      BREAK#4652,
      BREAK#4653,
    CONTENT#4654(   The padding sent is automatically verified by the record protection),
    CONTENT#4655(   mechanism; upon successful decryption of a),
    CONTENT#4656(   TLSCiphertext.encrypted_record, the receiving implementation scans),
    CONTENT#4657(   the field from the end toward the beginning until it finds a non-zero),
    CONTENT#4658(   octet.  This non-zero octet is the content type of the message.  This),
    CONTENT#4659(   padding scheme was selected because it allows padding of any),
    CONTENT#4660(   encrypted TLS record by an arbitrary size (from zero up to TLS record),
    CONTENT#4661(   size limits) without introducing new content types.  The design also),
    CONTENT#4662(   enforces all-zero padding octets, which allows for quick detection of),
    CONTENT#4663(   padding errors.),
      BREAK#4664,
    CONTENT#4665(   Implementations MUST limit their scanning to the cleartext returned),
    CONTENT#4666(   from the AEAD decryption.  If a receiving implementation does not),
    CONTENT#4667(   find a non-zero octet in the cleartext, it MUST terminate the),
    CONTENT#4668(   connection with an "unexpected_message" alert.),
      BREAK#4669,
    CONTENT#4670(   The presence of padding does not change the overall record size),
    CONTENT#4671(   limitations: the full encoded TLSInnerPlaintext MUST NOT exceed 2^14),
    CONTENT#4672(   + 1 octets.  If the maximum fragment length is reduced -- as, for),
    CONTENT#4673(   example, by the record_size_limit extension from [RFC8449] -- then),
    CONTENT#4674(   the reduced limit applies to the full plaintext, including the),
    CONTENT#4675(   content type and padding.),
      BREAK#4676,
    CONTENT#4677(   Selecting a padding policy that suggests when and how much to pad is),
    CONTENT#4678(   a complex topic and is beyond the scope of this specification.  If),
    CONTENT#4679(   the application-layer protocol on top of TLS has its own padding, it),
    CONTENT#4680(   may be preferable to pad Application Data TLS records within the),
    CONTENT#4681(   application layer.  Padding for encrypted Handshake or Alert records),
    CONTENT#4682(   must still be handled at the TLS layer, though.  Later documents may),
    CONTENT#4683(   define padding selection algorithms or define a padding policy),
    CONTENT#4684(   request mechanism through TLS extensions or some other means.),
      BREAK#4685,
    SECTION#4686(id=5.5, title=Limits on Key Usage),
      BREAK#4687,
    CONTENT#4688(   There are cryptographic limits on the amount of plaintext which can),
    CONTENT#4689(   be safely encrypted under a given set of keys.  [AEAD-LIMITS]),
    CONTENT#4690(   provides an analysis of these limits under the assumption that the),
    CONTENT#4691(   underlying primitive (AES or ChaCha20) has no weaknesses.),
    CONTENT#4692(   Implementations SHOULD do a key update as described in Section 4.6.3),
    CONTENT#4693(   prior to reaching these limits.),
      BREAK#4694,
    CONTENT#4695(   For AES-GCM, up to 2^24.5 full-size records (about 24 million) may be),
    CONTENT#4696(   encrypted on a given connection while keeping a safety margin of),
    CONTENT#4697(   approximately 2^-57 for Authenticated Encryption (AE) security.  For),
    CONTENT#4698(   ChaCha20/Poly1305, the record sequence number would wrap before the),
    CONTENT#4699(   safety limit is reached.),
      BREAK#4700,
      BREAK#4701,
      BREAK#4702,
      BREAK#4703,
      BREAK#4704,
      BREAK#4706,
      BREAK#4708,
      BREAK#4709,
    SECTION#4710(id=6, title=Alert Protocol),
      BREAK#4711,
    CONTENT#4712(   TLS provides an Alert content type to indicate closure information),
    CONTENT#4713(   and errors.  Like other messages, alert messages are encrypted as),
    CONTENT#4714(   specified by the current connection state.),
      BREAK#4715,
    CONTENT#4716(   Alert messages convey a description of the alert and a legacy field),
    CONTENT#4717(   that conveyed the severity level of the message in previous versions),
    CONTENT#4718(   of TLS.  Alerts are divided into two classes: closure alerts and),
    CONTENT#4719(   error alerts.  In TLS 1.3, the severity is implicit in the type of),
    CONTENT#4720(   alert being sent, and the "level" field can safely be ignored.  The),
    CONTENT#4721(   "close_notify" alert is used to indicate orderly closure of one),
    CONTENT#4722(   direction of the connection.  Upon receiving such an alert, the TLS),
    CONTENT#4723(   implementation SHOULD indicate end-of-data to the application.),
      BREAK#4724,
    CONTENT#4725(   Error alerts indicate abortive closure of the connection (see),
    CONTENT#4726(   Section 6.2).  Upon receiving an error alert, the TLS implementation),
    CONTENT#4727(   SHOULD indicate an error to the application and MUST NOT allow any),
    CONTENT#4728(   further data to be sent or received on the connection.  Servers and),
    CONTENT#4729(   clients MUST forget the secret values and keys established in failed),
    CONTENT#4730(   connections, with the exception of the PSKs associated with session),
    CONTENT#4731(   tickets, which SHOULD be discarded if possible.),
      BREAK#4732,
    CONTENT#4733(   All the alerts listed in Section 6.2 MUST be sent with),
    CONTENT#4734(   AlertLevel=fatal and MUST be treated as error alerts when received),
    CONTENT#4735(   regardless of the AlertLevel in the message.  Unknown Alert types),
    CONTENT#4736(   MUST be treated as error alerts.),
      BREAK#4737,
    CONTENT#4738(   Note: TLS defines two generic alerts (see Section 6) to use upon),
    CONTENT#4739(   failure to parse a message.  Peers which receive a message which),
    CONTENT#4740(   cannot be parsed according to the syntax (e.g., have a length),
    CONTENT#4741(   extending beyond the message boundary or contain an out-of-range),
    CONTENT#4742(   length) MUST terminate the connection with a "decode_error" alert.),
    CONTENT#4743(   Peers which receive a message which is syntactically correct but),
    CONTENT#4744(   semantically invalid (e.g., a DHE share of p - 1, or an invalid enum)),
    CONTENT#4745(   MUST terminate the connection with an "illegal_parameter" alert.),
      BREAK#4746,
      BREAK#4747,
      BREAK#4748,
      BREAK#4749,
      BREAK#4750,
      BREAK#4751,
      BREAK#4752,
      BREAK#4753,
      BREAK#4754,
      BREAK#4755,
      BREAK#4756,
      BREAK#4757,
      BREAK#4758,
      BREAK#4759,
      BREAK#4760,
      BREAK#4762,
      BREAK#4764,
      BREAK#4765,
    CONTENT#4766(      enum { warning(1), fatal(2), (255) } AlertLevel;),
      BREAK#4767,
    CONTENT#4768(      enum {),
    CONTENT#4769(          close_notify(0),),
    CONTENT#4770(          unexpected_message(10),),
    CONTENT#4771(          bad_record_mac(20),),
    CONTENT#4772(          record_overflow(22),),
    CONTENT#4773(          handshake_failure(40),),
    CONTENT#4774(          bad_certificate(42),),
    CONTENT#4775(          unsupported_certificate(43),),
    CONTENT#4776(          certificate_revoked(44),),
    CONTENT#4777(          certificate_expired(45),),
    CONTENT#4778(          certificate_unknown(46),),
    CONTENT#4779(          illegal_parameter(47),),
    CONTENT#4780(          unknown_ca(48),),
    CONTENT#4781(          access_denied(49),),
    CONTENT#4782(          decode_error(50),),
    CONTENT#4783(          decrypt_error(51),),
    CONTENT#4784(          protocol_version(70),),
    CONTENT#4785(          insufficient_security(71),),
    CONTENT#4786(          internal_error(80),),
    CONTENT#4787(          inappropriate_fallback(86),),
    CONTENT#4788(          user_canceled(90),),
    CONTENT#4789(          missing_extension(109),),
    CONTENT#4790(          unsupported_extension(110),),
    CONTENT#4791(          unrecognized_name(112),),
    CONTENT#4792(          bad_certificate_status_response(113),),
    CONTENT#4793(          unknown_psk_identity(115),),
    CONTENT#4794(          certificate_required(116),),
    CONTENT#4795(          no_application_protocol(120),),
    CONTENT#4796(          (255)),
    CONTENT#4797(      } AlertDescription;),
      BREAK#4798,
    CONTENT#4799(      struct {),
    CONTENT#4800(          AlertLevel level;),
    CONTENT#4801(          AlertDescription description;),
    CONTENT#4802(      } Alert;),
      BREAK#4803,
      BREAK#4804,
      BREAK#4805,
      BREAK#4806,
      BREAK#4807,
      BREAK#4808,
      BREAK#4809,
      BREAK#4810,
      BREAK#4811,
      BREAK#4812,
      BREAK#4813,
      BREAK#4814,
      BREAK#4815,
      BREAK#4816,
      BREAK#4818,
      BREAK#4820,
      BREAK#4821,
    SECTION#4822(id=6.1, title=Closure Alerts),
      BREAK#4823,
    CONTENT#4824(   The client and the server must share knowledge that the connection is),
    CONTENT#4825(   ending in order to avoid a truncation attack.),
      BREAK#4826,
    CONTENT#4827(   close_notify:  This alert notifies the recipient that the sender will),
    CONTENT#4828(      not send any more messages on this connection.  Any data received),
    CONTENT#4829(      after a closure alert has been received MUST be ignored.),
      BREAK#4830,
    CONTENT#4831(   user_canceled:  This alert notifies the recipient that the sender is),
    CONTENT#4832(      canceling the handshake for some reason unrelated to a protocol),
    CONTENT#4833(      failure.  If a user cancels an operation after the handshake is),
    CONTENT#4834(      complete, just closing the connection by sending a "close_notify"),
    CONTENT#4835(      is more appropriate.  This alert SHOULD be followed by a),
    CONTENT#4836(      "close_notify".  This alert generally has AlertLevel=warning.),
      BREAK#4837,
    CONTENT#4838(   Either party MAY initiate a close of its write side of the connection),
    CONTENT#4839(   by sending a "close_notify" alert.  Any data received after a closure),
    CONTENT#4840(   alert has been received MUST be ignored.  If a transport-level close),
    CONTENT#4841(   is received prior to a "close_notify", the receiver cannot know that),
    CONTENT#4842(   all the data that was sent has been received.),
      BREAK#4843,
    CONTENT#4844(   Each party MUST send a "close_notify" alert before closing its write),
    CONTENT#4845(   side of the connection, unless it has already sent some error alert.),
    CONTENT#4846(   This does not have any effect on its read side of the connection.),
    CONTENT#4847(   Note that this is a change from versions of TLS prior to TLS 1.3 in),
    CONTENT#4848(   which implementations were required to react to a "close_notify" by),
    CONTENT#4849(   discarding pending writes and sending an immediate "close_notify"),
    CONTENT#4850(   alert of their own.  That previous requirement could cause truncation),
    CONTENT#4851(   in the read side.  Both parties need not wait to receive a),
    CONTENT#4852(   "close_notify" alert before closing their read side of the),
    CONTENT#4853(   connection, though doing so would introduce the possibility of),
    CONTENT#4854(   truncation.),
      BREAK#4855,
    CONTENT#4856(   If the application protocol using TLS provides that any data may be),
    CONTENT#4857(   carried over the underlying transport after the TLS connection is),
    CONTENT#4858(   closed, the TLS implementation MUST receive a "close_notify" alert),
    CONTENT#4859(   before indicating end-of-data to the application layer.  No part of),
    CONTENT#4860(   this standard should be taken to dictate the manner in which a usage),
    CONTENT#4861(   profile for TLS manages its data transport, including when),
    CONTENT#4862(   connections are opened or closed.),
      BREAK#4863,
    CONTENT#4864(   Note: It is assumed that closing the write side of a connection),
    CONTENT#4865(   reliably delivers pending data before destroying the transport.),
      BREAK#4866,
      BREAK#4867,
      BREAK#4868,
      BREAK#4869,
      BREAK#4870,
      BREAK#4871,
      BREAK#4872,
      BREAK#4874,
      BREAK#4876,
      BREAK#4877,
    SECTION#4878(id=6.2, title=Error Alerts),
      BREAK#4879,
    CONTENT#4880(   Error handling in TLS is very simple.  When an error is detected, the),
    CONTENT#4881(   detecting party sends a message to its peer.  Upon transmission or),
    CONTENT#4882(   receipt of a fatal alert message, both parties MUST immediately close),
    CONTENT#4883(   the connection.),
      BREAK#4884,
    CONTENT#4885(   Whenever an implementation encounters a fatal error condition, it),
    CONTENT#4886(   SHOULD send an appropriate fatal alert and MUST close the connection),
    CONTENT#4887(   without sending or receiving any additional data.  In the rest of),
    CONTENT#4888(   this specification, when the phrases "terminate the connection" and),
    CONTENT#4889(   "abort the handshake" are used without a specific alert it means that),
    CONTENT#4890(   the implementation SHOULD send the alert indicated by the),
    CONTENT#4891(   descriptions below.  The phrases "terminate the connection with an X),
    CONTENT#4892(   alert" and "abort the handshake with an X alert" mean that the),
    CONTENT#4893(   implementation MUST send alert X if it sends any alert.  All alerts),
    CONTENT#4894(   defined below in this section, as well as all unknown alerts, are),
    CONTENT#4895(   universally considered fatal as of TLS 1.3 (see Section 6).  The),
    CONTENT#4896(   implementation SHOULD provide a way to facilitate logging the sending),
    CONTENT#4897(   and receiving of alerts.),
      BREAK#4898,
    CONTENT#4899(   The following error alerts are defined:),
      BREAK#4900,
    CONTENT#4901(   unexpected_message:  An inappropriate message (e.g., the wrong),
    CONTENT#4902(      handshake message, premature Application Data, etc.) was received.),
    CONTENT#4903(      This alert should never be observed in communication between),
    CONTENT#4904(      proper implementations.),
      BREAK#4905,
    CONTENT#4906(   bad_record_mac:  This alert is returned if a record is received which),
    CONTENT#4907(      cannot be deprotected.  Because AEAD algorithms combine decryption),
    CONTENT#4908(      and verification, and also to avoid side-channel attacks, this),
    CONTENT#4909(      alert is used for all deprotection failures.  This alert should),
    CONTENT#4910(      never be observed in communication between proper implementations,),
    CONTENT#4911(      except when messages were corrupted in the network.),
      BREAK#4912,
    CONTENT#4913(   record_overflow:  A TLSCiphertext record was received that had a),
    CONTENT#4914(      length more than 2^14 + 256 bytes, or a record decrypted to a),
    CONTENT#4915(      TLSPlaintext record with more than 2^14 bytes (or some other),
    CONTENT#4916(      negotiated limit).  This alert should never be observed in),
    CONTENT#4917(      communication between proper implementations, except when messages),
    CONTENT#4918(      were corrupted in the network.),
      BREAK#4919,
    CONTENT#4920(   handshake_failure:  Receipt of a "handshake_failure" alert message),
    CONTENT#4921(      indicates that the sender was unable to negotiate an acceptable),
    CONTENT#4922(      set of security parameters given the options available.),
      BREAK#4923,
    CONTENT#4924(   bad_certificate:  A certificate was corrupt, contained signatures),
    CONTENT#4925(      that did not verify correctly, etc.),
      BREAK#4926,
      BREAK#4927,
      BREAK#4928,
      BREAK#4930,
      BREAK#4932,
      BREAK#4933,
    CONTENT#4934(   unsupported_certificate:  A certificate was of an unsupported type.),
      BREAK#4935,
    CONTENT#4936(   certificate_revoked:  A certificate was revoked by its signer.),
      BREAK#4937,
    CONTENT#4938(   certificate_expired:  A certificate has expired or is not currently),
    CONTENT#4939(      valid.),
      BREAK#4940,
    CONTENT#4941(   certificate_unknown:  Some other (unspecified) issue arose in),
    CONTENT#4942(      processing the certificate, rendering it unacceptable.),
      BREAK#4943,
    CONTENT#4944(   illegal_parameter:  A field in the handshake was incorrect or),
    CONTENT#4945(      inconsistent with other fields.  This alert is used for errors),
    CONTENT#4946(      which conform to the formal protocol syntax but are otherwise),
    CONTENT#4947(      incorrect.),
      BREAK#4948,
    CONTENT#4949(   unknown_ca:  A valid certificate chain or partial chain was received,),
    CONTENT#4950(      but the certificate was not accepted because the CA certificate),
    CONTENT#4951(      could not be located or could not be matched with a known trust),
    CONTENT#4952(      anchor.),
      BREAK#4953,
    CONTENT#4954(   access_denied:  A valid certificate or PSK was received, but when),
    CONTENT#4955(      access control was applied, the sender decided not to proceed with),
    CONTENT#4956(      negotiation.),
      BREAK#4957,
    CONTENT#4958(   decode_error:  A message could not be decoded because some field was),
    CONTENT#4959(      out of the specified range or the length of the message was),
    CONTENT#4960(      incorrect.  This alert is used for errors where the message does),
    CONTENT#4961(      not conform to the formal protocol syntax.  This alert should),
    CONTENT#4962(      never be observed in communication between proper implementations,),
    CONTENT#4963(      except when messages were corrupted in the network.),
      BREAK#4964,
    CONTENT#4965(   decrypt_error:  A handshake (not record layer) cryptographic),
    CONTENT#4966(      operation failed, including being unable to correctly verify a),
    CONTENT#4967(      signature or validate a Finished message or a PSK binder.),
      BREAK#4968,
    CONTENT#4969(   protocol_version:  The protocol version the peer has attempted to),
    CONTENT#4970(      negotiate is recognized but not supported (see Appendix D).),
      BREAK#4971,
    CONTENT#4972(   insufficient_security:  Returned instead of "handshake_failure" when),
    CONTENT#4973(      a negotiation has failed specifically because the server requires),
    CONTENT#4974(      parameters more secure than those supported by the client.),
      BREAK#4975,
    CONTENT#4976(   internal_error:  An internal error unrelated to the peer or the),
    CONTENT#4977(      correctness of the protocol (such as a memory allocation failure)),
    CONTENT#4978(      makes it impossible to continue.),
      BREAK#4979,
    CONTENT#4980(   inappropriate_fallback:  Sent by a server in response to an invalid),
    CONTENT#4981(      connection retry attempt from a client (see [RFC7507]).),
      BREAK#4982,
      BREAK#4983,
      BREAK#4984,
      BREAK#4986,
      BREAK#4988,
      BREAK#4989,
    CONTENT#4990(   missing_extension:  Sent by endpoints that receive a handshake),
    CONTENT#4991(      message not containing an extension that is mandatory to send for),
    CONTENT#4992(      the offered TLS version or other negotiated parameters.),
      BREAK#4993,
    CONTENT#4994(   unsupported_extension:  Sent by endpoints receiving any handshake),
    CONTENT#4995(      message containing an extension known to be prohibited for),
    CONTENT#4996(      inclusion in the given handshake message, or including any),
    CONTENT#4997(      extensions in a ServerHello or Certificate not first offered in),
    CONTENT#4998(      the corresponding ClientHello or CertificateRequest.),
      BREAK#4999,
    CONTENT#5000(   unrecognized_name:  Sent by servers when no server exists identified),
    CONTENT#5001(      by the name provided by the client via the "server_name" extension),
    CONTENT#5002(      (see [RFC6066]).),
      BREAK#5003,
    CONTENT#5004(   bad_certificate_status_response:  Sent by clients when an invalid or),
    CONTENT#5005(      unacceptable OCSP response is provided by the server via the),
    CONTENT#5006(      "status_request" extension (see [RFC6066]).),
      BREAK#5007,
    CONTENT#5008(   unknown_psk_identity:  Sent by servers when PSK key establishment is),
    CONTENT#5009(      desired but no acceptable PSK identity is provided by the client.),
    CONTENT#5010(      Sending this alert is OPTIONAL; servers MAY instead choose to send),
    CONTENT#5011(      a "decrypt_error" alert to merely indicate an invalid PSK),
    CONTENT#5012(      identity.),
      BREAK#5013,
    CONTENT#5014(   certificate_required:  Sent by servers when a client certificate is),
    CONTENT#5015(      desired but none was provided by the client.),
      BREAK#5016,
    CONTENT#5017(   no_application_protocol:  Sent by servers when a client),
    CONTENT#5018(      "application_layer_protocol_negotiation" extension advertises only),
    CONTENT#5019(      protocols that the server does not support (see [RFC7301]).),
      BREAK#5020,
    CONTENT#5021(   New Alert values are assigned by IANA as described in Section 11.),
      BREAK#5022,
    SECTION#5023(id=7, title=Cryptographic Computations),
      BREAK#5024,
    CONTENT#5025(   The TLS handshake establishes one or more input secrets which are),
    CONTENT#5026(   combined to create the actual working keying material, as detailed),
    CONTENT#5027(   below.  The key derivation process incorporates both the input),
    CONTENT#5028(   secrets and the handshake transcript.  Note that because the),
    CONTENT#5029(   handshake transcript includes the random values from the Hello),
    CONTENT#5030(   messages, any given handshake will have different traffic secrets,),
    CONTENT#5031(   even if the same input secrets are used, as is the case when the same),
    CONTENT#5032(   PSK is used for multiple connections.),
      BREAK#5033,
      BREAK#5034,
      BREAK#5035,
      BREAK#5036,
      BREAK#5037,
      BREAK#5038,
      BREAK#5039,
      BREAK#5040,
      BREAK#5042,
      BREAK#5044,
      BREAK#5045,
    SECTION#5046(id=7.1, title=Key Schedule),
      BREAK#5047,
    CONTENT#5048(   The key derivation process makes use of the HKDF-Extract and),
    CONTENT#5049(   HKDF-Expand functions as defined for HKDF [RFC5869], as well as the),
    CONTENT#5050(   functions defined below:),
      BREAK#5051,
    CONTENT#5052(       HKDF-Expand-Label(Secret, Label, Context, Length) =),
    CONTENT#5053(            HKDF-Expand(Secret, HkdfLabel, Length)),
      BREAK#5054,
    CONTENT#5055(       Where HkdfLabel is specified as:),
      BREAK#5056,
    CONTENT#5057(       struct {),
    CONTENT#5058(           uint16 length = Length;),
    CONTENT#5059(           opaque label<7..255> = "tls13 " + Label;),
    CONTENT#5060(           opaque context<0..255> = Context;),
    CONTENT#5061(       } HkdfLabel;),
      BREAK#5062,
    CONTENT#5063(       Derive-Secret(Secret, Label, Messages) =),
    CONTENT#5064(            HKDF-Expand-Label(Secret, Label,),
    CONTENT#5065(                              Transcript-Hash(Messages), Hash.length)),
      BREAK#5066,
    CONTENT#5067(   The Hash function used by Transcript-Hash and HKDF is the cipher),
    CONTENT#5068(   suite hash algorithm.  Hash.length is its output length in bytes.),
    CONTENT#5069(   Messages is the concatenation of the indicated handshake messages,),
    CONTENT#5070(   including the handshake message type and length fields, but not),
    CONTENT#5071(   including record layer headers.  Note that in some cases a zero-),
    CONTENT#5072(   length Context (indicated by "") is passed to HKDF-Expand-Label.  The),
    CONTENT#5073(   labels specified in this document are all ASCII strings and do not),
    CONTENT#5074(   include a trailing NUL byte.),
      BREAK#5075,
    CONTENT#5076(   Note: With common hash functions, any label longer than 12 characters),
    CONTENT#5077(   requires an additional iteration of the hash function to compute.),
    CONTENT#5078(   The labels in this specification have all been chosen to fit within),
    CONTENT#5079(   this limit.),
      BREAK#5080,
      BREAK#5081,
      BREAK#5082,
      BREAK#5083,
      BREAK#5084,
      BREAK#5085,
      BREAK#5086,
      BREAK#5087,
      BREAK#5088,
      BREAK#5089,
      BREAK#5090,
      BREAK#5091,
      BREAK#5092,
      BREAK#5093,
      BREAK#5094,
      BREAK#5095,
      BREAK#5096,
      BREAK#5098,
      BREAK#5100,
      BREAK#5101,
    CONTENT#5102(   Keys are derived from two input secrets using the HKDF-Extract and),
    CONTENT#5103(   Derive-Secret functions.  The general pattern for adding a new secret),
    CONTENT#5104(   is to use HKDF-Extract with the Salt being the current secret state),
    CONTENT#5105(   and the Input Keying Material (IKM) being the new secret to be added.),
    CONTENT#5106(   In this version of TLS 1.3, the two input secrets are:),
      BREAK#5107,
    CONTENT#5108(   -  PSK (a pre-shared key established externally or derived from the),
    CONTENT#5109(      resumption_master_secret value from a previous connection)),
      BREAK#5110,
    CONTENT#5111(   -  (EC)DHE shared secret (Section 7.4)),
      BREAK#5112,
    CONTENT#5113(   This produces a full key derivation schedule shown in the diagram),
    CONTENT#5114(   below.  In this diagram, the following formatting conventions apply:),
      BREAK#5115,
    CONTENT#5116(   -  HKDF-Extract is drawn as taking the Salt argument from the top and),
    CONTENT#5117(      the IKM argument from the left, with its output to the bottom and),
    CONTENT#5118(      the name of the output on the right.),
      BREAK#5119,
    CONTENT#5120(   -  Derive-Secret's Secret argument is indicated by the incoming),
    CONTENT#5121(      arrow.  For instance, the Early Secret is the Secret for),
    CONTENT#5122(      generating the client_early_traffic_secret.),
      BREAK#5123,
    CONTENT#5124(   -  "0" indicates a string of Hash.length bytes set to zero.),
      BREAK#5125,
      BREAK#5126,
      BREAK#5127,
      BREAK#5128,
      BREAK#5129,
      BREAK#5130,
      BREAK#5131,
      BREAK#5132,
      BREAK#5133,
      BREAK#5134,
      BREAK#5135,
      BREAK#5136,
      BREAK#5137,
      BREAK#5138,
      BREAK#5139,
      BREAK#5140,
      BREAK#5141,
      BREAK#5142,
      BREAK#5143,
      BREAK#5144,
      BREAK#5145,
      BREAK#5146,
      BREAK#5147,
      BREAK#5148,
      BREAK#5149,
      BREAK#5150,
      BREAK#5151,
      BREAK#5152,
      BREAK#5154,
      BREAK#5156,
      BREAK#5157,
    CONTENT#5158(             0),
    CONTENT#5159(             |),
    CONTENT#5160(             v),
    CONTENT#5161(   PSK ->  HKDF-Extract = Early Secret),
    CONTENT#5162(             |),
    CONTENT#5163(             +-----> Derive-Secret(., "ext binder" | "res binder", "")),
    CONTENT#5164(             |                     = binder_key),
    CONTENT#5165(             |),
    CONTENT#5166(             +-----> Derive-Secret(., "c e traffic", ClientHello)),
    CONTENT#5167(             |                     = client_early_traffic_secret),
    CONTENT#5168(             |),
    CONTENT#5169(             +-----> Derive-Secret(., "e exp master", ClientHello)),
    CONTENT#5170(             |                     = early_exporter_master_secret),
    CONTENT#5171(             v),
    CONTENT#5172(       Derive-Secret(., "derived", "")),
    CONTENT#5173(             |),
    CONTENT#5174(             v),
    CONTENT#5175(   (EC)DHE -> HKDF-Extract = Handshake Secret),
    CONTENT#5176(             |),
    CONTENT#5177(             +-----> Derive-Secret(., "c hs traffic",),
    CONTENT#5178(             |                     ClientHello...ServerHello)),
    CONTENT#5179(             |                     = client_handshake_traffic_secret),
    CONTENT#5180(             |),
    CONTENT#5181(             +-----> Derive-Secret(., "s hs traffic",),
    CONTENT#5182(             |                     ClientHello...ServerHello)),
    CONTENT#5183(             |                     = server_handshake_traffic_secret),
    CONTENT#5184(             v),
    CONTENT#5185(       Derive-Secret(., "derived", "")),
    CONTENT#5186(             |),
    CONTENT#5187(             v),
    CONTENT#5188(   0 -> HKDF-Extract = Master Secret),
    CONTENT#5189(             |),
    CONTENT#5190(             +-----> Derive-Secret(., "c ap traffic",),
    CONTENT#5191(             |                     ClientHello...server Finished)),
    CONTENT#5192(             |                     = client_application_traffic_secret_0),
    CONTENT#5193(             |),
    CONTENT#5194(             +-----> Derive-Secret(., "s ap traffic",),
    CONTENT#5195(             |                     ClientHello...server Finished)),
    CONTENT#5196(             |                     = server_application_traffic_secret_0),
    CONTENT#5197(             |),
    CONTENT#5198(             +-----> Derive-Secret(., "exp master",),
    CONTENT#5199(             |                     ClientHello...server Finished)),
    CONTENT#5200(             |                     = exporter_master_secret),
    CONTENT#5201(             |),
    CONTENT#5202(             +-----> Derive-Secret(., "res master",),
    CONTENT#5203(                                   ClientHello...client Finished)),
    CONTENT#5204(                                   = resumption_master_secret),
      BREAK#5205,
      BREAK#5206,
      BREAK#5207,
      BREAK#5208,
      BREAK#5210,
      BREAK#5212,
      BREAK#5213,
    CONTENT#5214(   The general pattern here is that the secrets shown down the left side),
    CONTENT#5215(   of the diagram are just raw entropy without context, whereas the),
    CONTENT#5216(   secrets down the right side include Handshake Context and therefore),
    CONTENT#5217(   can be used to derive working keys without additional context.  Note),
    CONTENT#5218(   that the different calls to Derive-Secret may take different Messages),
    CONTENT#5219(   arguments, even with the same secret.  In a 0-RTT exchange,),
    CONTENT#5220(   Derive-Secret is called with four distinct transcripts; in a),
    CONTENT#5221(   1-RTT-only exchange, it is called with three distinct transcripts.),
      BREAK#5222,
    CONTENT#5223(   If a given secret is not available, then the 0-value consisting of a),
    CONTENT#5224(   string of Hash.length bytes set to zeros is used.  Note that this),
    CONTENT#5225(   does not mean skipping rounds, so if PSK is not in use, Early Secret),
    CONTENT#5226(   will still be HKDF-Extract(0, 0).  For the computation of the),
    CONTENT#5227(   binder_key, the label is "ext binder" for external PSKs (those),
    CONTENT#5228(   provisioned outside of TLS) and "res binder" for resumption PSKs),
    CONTENT#5229(   (those provisioned as the resumption master secret of a previous),
    CONTENT#5230(   handshake).  The different labels prevent the substitution of one),
    CONTENT#5231(   type of PSK for the other.),
      BREAK#5232,
    CONTENT#5233(   There are multiple potential Early Secret values, depending on which),
    CONTENT#5234(   PSK the server ultimately selects.  The client will need to compute),
    CONTENT#5235(   one for each potential PSK; if no PSK is selected, it will then need),
    CONTENT#5236(   to compute the Early Secret corresponding to the zero PSK.),
      BREAK#5237,
    CONTENT#5238(   Once all the values which are to be derived from a given secret have),
    CONTENT#5239(   been computed, that secret SHOULD be erased.),
      BREAK#5240,
    SECTION#5241(id=7.2, title=Updating Traffic Secrets),
      BREAK#5242,
    CONTENT#5243(   Once the handshake is complete, it is possible for either side to),
    CONTENT#5244(   update its sending traffic keys using the KeyUpdate handshake message),
    CONTENT#5245(   defined in Section 4.6.3.  The next generation of traffic keys is),
    CONTENT#5246(   computed by generating client_/server_application_traffic_secret_N+1),
    CONTENT#5247(   from client_/server_application_traffic_secret_N as described in this),
    CONTENT#5248(   section and then re-deriving the traffic keys as described in),
    CONTENT#5249(   Section 7.3.),
      BREAK#5250,
    CONTENT#5251(   The next-generation application_traffic_secret is computed as:),
      BREAK#5252,
    CONTENT#5253(       application_traffic_secret_N+1 =),
    CONTENT#5254(           HKDF-Expand-Label(application_traffic_secret_N,),
    CONTENT#5255(                             "traffic upd", "", Hash.length)),
      BREAK#5256,
    CONTENT#5257(   Once client_/server_application_traffic_secret_N+1 and its associated),
    CONTENT#5258(   traffic keys have been computed, implementations SHOULD delete),
    CONTENT#5259(   client_/server_application_traffic_secret_N and its associated),
    CONTENT#5260(   traffic keys.),
      BREAK#5261,
      BREAK#5262,
      BREAK#5263,
      BREAK#5264,
      BREAK#5266,
      BREAK#5268,
      BREAK#5269,
    SECTION#5270(id=7.3, title=Traffic Key Calculation),
      BREAK#5271,
    CONTENT#5272(   The traffic keying material is generated from the following input),
    CONTENT#5273(   values:),
      BREAK#5274,
    CONTENT#5275(   -  A secret value),
      BREAK#5276,
    CONTENT#5277(   -  A purpose value indicating the specific value being generated),
      BREAK#5278,
    CONTENT#5279(   -  The length of the key being generated),
      BREAK#5280,
    CONTENT#5281(   The traffic keying material is generated from an input traffic secret),
    CONTENT#5282(   value using:),
      BREAK#5283,
    CONTENT#5284(   [sender]_write_key = HKDF-Expand-Label(Secret, "key", "", key_length)),
    CONTENT#5285(   [sender]_write_iv  = HKDF-Expand-Label(Secret, "iv", "", iv_length)),
      BREAK#5286,
    CONTENT#5287(   [sender] denotes the sending side.  The value of Secret for each),
    CONTENT#5288(   record type is shown in the table below.),
      BREAK#5289,
    CONTENT#5290(       +-------------------+---------------------------------------+),
    CONTENT#5291(       | Record Type       | Secret                                |),
    CONTENT#5292(       +-------------------+---------------------------------------+),
    CONTENT#5293(       | 0-RTT Application | client_early_traffic_secret           |),
    CONTENT#5294(       |                   |                                       |),
    CONTENT#5295(       | Handshake         | [sender]_handshake_traffic_secret     |),
    CONTENT#5296(       |                   |                                       |),
    CONTENT#5297(       | Application Data  | [sender]_application_traffic_secret_N |),
    CONTENT#5298(       +-------------------+---------------------------------------+),
      BREAK#5299,
    CONTENT#5300(   All the traffic keying material is recomputed whenever the underlying),
    CONTENT#5301(   Secret changes (e.g., when changing from the handshake to Application),
    CONTENT#5302(   Data keys or upon a key update).),
      BREAK#5303,
    SECTION#5304(id=7.4, title=(EC)DHE Shared Secret Calculation),
      BREAK#5305,
    SECTION#5306(id=7.4.1, title=Finite Field Diffie-Hellman),
      BREAK#5307,
    CONTENT#5308(   For finite field groups, a conventional Diffie-Hellman [DH76]),
    CONTENT#5309(   computation is performed.  The negotiated key (Z) is converted to a),
    CONTENT#5310(   byte string by encoding in big-endian form and left-padded with zeros),
    CONTENT#5311(   up to the size of the prime.  This byte string is used as the shared),
    CONTENT#5312(   secret in the key schedule as specified above.),
      BREAK#5313,
    CONTENT#5314(   Note that this construction differs from previous versions of TLS),
    CONTENT#5315(   which removed leading zeros.),
      BREAK#5316,
      BREAK#5317,
      BREAK#5318,
      BREAK#5319,
      BREAK#5320,
      BREAK#5322,
      BREAK#5324,
      BREAK#5325,
    SECTION#5326(id=7.4.2, title=Elliptic Curve Diffie-Hellman),
      BREAK#5327,
    CONTENT#5328(   For secp256r1, secp384r1, and secp521r1, ECDH calculations (including),
    CONTENT#5329(   parameter and key generation as well as the shared secret),
    CONTENT#5330(   calculation) are performed according to [IEEE1363] using the),
    CONTENT#5331(   ECKAS-DH1 scheme with the identity map as the key derivation function),
    CONTENT#5332(   (KDF), so that the shared secret is the x-coordinate of the ECDH),
    CONTENT#5333(   shared secret elliptic curve point represented as an octet string.),
    CONTENT#5334(   Note that this octet string ("Z" in IEEE 1363 terminology) as output),
    CONTENT#5335(   by FE2OSP (the Field Element to Octet String Conversion Primitive)),
    CONTENT#5336(   has constant length for any given field; leading zeros found in this),
    CONTENT#5337(   octet string MUST NOT be truncated.),
      BREAK#5338,
    CONTENT#5339(   (Note that this use of the identity KDF is a technicality.  The),
    CONTENT#5340(   complete picture is that ECDH is employed with a non-trivial KDF),
    CONTENT#5341(   because TLS does not directly use this secret for anything other than),
    CONTENT#5342(   for computing other secrets.)),
      BREAK#5343,
    CONTENT#5344(   For X25519 and X448, the ECDH calculations are as follows:),
      BREAK#5345,
    CONTENT#5346(   -  The public key to put into the KeyShareEntry.key_exchange),
    CONTENT#5347(      structure is the result of applying the ECDH scalar multiplication),
    CONTENT#5348(      function to the secret key of appropriate length (into scalar),
    CONTENT#5349(      input) and the standard public basepoint (into u-coordinate point),
    CONTENT#5350(      input).),
      BREAK#5351,
    CONTENT#5352(   -  The ECDH shared secret is the result of applying the ECDH scalar),
    CONTENT#5353(      multiplication function to the secret key (into scalar input) and),
    CONTENT#5354(      the peer's public key (into u-coordinate point input).  The output),
    CONTENT#5355(      is used raw, with no processing.),
      BREAK#5356,
    CONTENT#5357(   For these curves, implementations SHOULD use the approach specified),
    CONTENT#5358(   in [RFC7748] to calculate the Diffie-Hellman shared secret.),
    CONTENT#5359(   Implementations MUST check whether the computed Diffie-Hellman shared),
    CONTENT#5360(   secret is the all-zero value and abort if so, as described in),
    CONTENT#5361(   Section 6 of [RFC7748].  If implementors use an alternative),
    CONTENT#5362(   implementation of these elliptic curves, they SHOULD perform the),
    CONTENT#5363(   additional checks specified in Section 7 of [RFC7748].),
      BREAK#5364,
      BREAK#5365,
      BREAK#5366,
      BREAK#5367,
      BREAK#5368,
      BREAK#5369,
      BREAK#5370,
      BREAK#5371,
      BREAK#5372,
      BREAK#5373,
      BREAK#5374,
      BREAK#5375,
      BREAK#5376,
      BREAK#5378,
      BREAK#5380,
      BREAK#5381,
    SECTION#5382(id=7.5, title=Exporters),
      BREAK#5383,
    CONTENT#5384(   [RFC5705] defines keying material exporters for TLS in terms of the),
    CONTENT#5385(   TLS pseudorandom function (PRF).  This document replaces the PRF with),
    CONTENT#5386(   HKDF, thus requiring a new construction.  The exporter interface),
    CONTENT#5387(   remains the same.),
      BREAK#5388,
    CONTENT#5389(   The exporter value is computed as:),
      BREAK#5390,
    CONTENT#5391(   TLS-Exporter(label, context_value, key_length) =),
    CONTENT#5392(       HKDF-Expand-Label(Derive-Secret(Secret, label, ""),),
    CONTENT#5393(                         "exporter", Hash(context_value), key_length)),
      BREAK#5394,
    CONTENT#5395(   Where Secret is either the early_exporter_master_secret or the),
    CONTENT#5396(   exporter_master_secret.  Implementations MUST use the),
    CONTENT#5397(   exporter_master_secret unless explicitly specified by the),
    CONTENT#5398(   application.  The early_exporter_master_secret is defined for use in),
    CONTENT#5399(   settings where an exporter is needed for 0-RTT data.  A separate),
    CONTENT#5400(   interface for the early exporter is RECOMMENDED; this avoids the),
    CONTENT#5401(   exporter user accidentally using an early exporter when a regular one),
    CONTENT#5402(   is desired or vice versa.),
      BREAK#5403,
    CONTENT#5404(   If no context is provided, the context_value is zero length.),
    CONTENT#5405(   Consequently, providing no context computes the same value as),
    CONTENT#5406(   providing an empty context.  This is a change from previous versions),
    CONTENT#5407(   of TLS where an empty context produced a different output than an),
    CONTENT#5408(   absent context.  As of this document's publication, no allocated),
    CONTENT#5409(   exporter label is used both with and without a context.  Future),
    CONTENT#5410(   specifications MUST NOT define a use of exporters that permit both an),
    CONTENT#5411(   empty context and no context with the same label.  New uses of),
    CONTENT#5412(   exporters SHOULD provide a context in all exporter computations,),
    CONTENT#5413(   though the value could be empty.),
      BREAK#5414,
    CONTENT#5415(   Requirements for the format of exporter labels are defined in),
    CONTENT#5416(   Section 4 of [RFC5705].),
      BREAK#5417,
      BREAK#5418,
      BREAK#5419,
      BREAK#5420,
      BREAK#5421,
      BREAK#5422,
      BREAK#5423,
      BREAK#5424,
      BREAK#5425,
      BREAK#5426,
      BREAK#5427,
      BREAK#5428,
      BREAK#5429,
      BREAK#5430,
      BREAK#5431,
      BREAK#5432,
      BREAK#5434,
      BREAK#5436,
      BREAK#5437,
    SECTION#5438(id=8, title=0-RTT and Anti-Replay),
      BREAK#5439,
    CONTENT#5440(   As noted in Section 2.3 and Appendix E.5, TLS does not provide),
    CONTENT#5441(   inherent replay protections for 0-RTT data.  There are two potential),
    CONTENT#5442(   threats to be concerned with:),
      BREAK#5443,
    CONTENT#5444(   -  Network attackers who mount a replay attack by simply duplicating),
    CONTENT#5445(      a flight of 0-RTT data.),
      BREAK#5446,
    CONTENT#5447(   -  Network attackers who take advantage of client retry behavior to),
    CONTENT#5448(      arrange for the server to receive multiple copies of an),
    CONTENT#5449(      application message.  This threat already exists to some extent),
    CONTENT#5450(      because clients that value robustness respond to network errors by),
    CONTENT#5451(      attempting to retry requests.  However, 0-RTT adds an additional),
    CONTENT#5452(      dimension for any server system which does not maintain globally),
    CONTENT#5453(      consistent server state.  Specifically, if a server system has),
    CONTENT#5454(      multiple zones where tickets from zone A will not be accepted in),
    CONTENT#5455(      zone B, then an attacker can duplicate a ClientHello and early),
    CONTENT#5456(      data intended for A to both A and B.  At A, the data will be),
    CONTENT#5457(      accepted in 0-RTT, but at B the server will reject 0-RTT data and),
    CONTENT#5458(      instead force a full handshake.  If the attacker blocks the),
    CONTENT#5459(      ServerHello from A, then the client will complete the handshake),
    CONTENT#5460(      with B and probably retry the request, leading to duplication on),
    CONTENT#5461(      the server system as a whole.),
      BREAK#5462,
    CONTENT#5463(   The first class of attack can be prevented by sharing state to),
    CONTENT#5464(   guarantee that the 0-RTT data is accepted at most once.  Servers),
    CONTENT#5465(   SHOULD provide that level of replay safety by implementing one of the),
    CONTENT#5466(   methods described in this section or by equivalent means.  It is),
    CONTENT#5467(   understood, however, that due to operational concerns not all),
    CONTENT#5468(   deployments will maintain state at that level.  Therefore, in normal),
    CONTENT#5469(   operation, clients will not know which, if any, of these mechanisms),
    CONTENT#5470(   servers actually implement and hence MUST only send early data which),
    CONTENT#5471(   they deem safe to be replayed.),
      BREAK#5472,
    CONTENT#5473(   In addition to the direct effects of replays, there is a class of),
    CONTENT#5474(   attacks where even operations normally considered idempotent could be),
    CONTENT#5475(   exploited by a large number of replays (timing attacks, resource),
    CONTENT#5476(   limit exhaustion and others, as described in Appendix E.5).  Those),
    CONTENT#5477(   can be mitigated by ensuring that every 0-RTT payload can be replayed),
    CONTENT#5478(   only a limited number of times.  The server MUST ensure that any),
    CONTENT#5479(   instance of it (be it a machine, a thread, or any other entity within),
    CONTENT#5480(   the relevant serving infrastructure) would accept 0-RTT for the same),
    CONTENT#5481(   0-RTT handshake at most once; this limits the number of replays to),
    CONTENT#5482(   the number of server instances in the deployment.  Such a guarantee),
    CONTENT#5483(   can be accomplished by locally recording data from recently received),
    CONTENT#5484(   ClientHellos and rejecting repeats, or by any other method that),
      BREAK#5485,
      BREAK#5486,
      BREAK#5487,
      BREAK#5488,
      BREAK#5490,
      BREAK#5492,
      BREAK#5493,
    CONTENT#5494(   provides the same or a stronger guarantee.  The "at most once per),
    CONTENT#5495(   server instance" guarantee is a minimum requirement; servers SHOULD),
    CONTENT#5496(   limit 0-RTT replays further when feasible.),
      BREAK#5497,
    CONTENT#5498(   The second class of attack cannot be prevented at the TLS layer and),
    CONTENT#5499(   MUST be dealt with by any application.  Note that any application),
    CONTENT#5500(   whose clients implement any kind of retry behavior already needs to),
    CONTENT#5501(   implement some sort of anti-replay defense.),
      BREAK#5502,
    SECTION#5503(id=8.1, title=Single-Use Tickets),
      BREAK#5504,
    CONTENT#5505(   The simplest form of anti-replay defense is for the server to only),
    CONTENT#5506(   allow each session ticket to be used once.  For instance, the server),
    CONTENT#5507(   can maintain a database of all outstanding valid tickets, deleting),
    CONTENT#5508(   each ticket from the database as it is used.  If an unknown ticket is),
    CONTENT#5509(   provided, the server would then fall back to a full handshake.),
      BREAK#5510,
    CONTENT#5511(   If the tickets are not self-contained but rather are database keys,),
    CONTENT#5512(   and the corresponding PSKs are deleted upon use, then connections),
    CONTENT#5513(   established using PSKs enjoy forward secrecy.  This improves security),
    CONTENT#5514(   for all 0-RTT data and PSK usage when PSK is used without (EC)DHE.),
      BREAK#5515,
    CONTENT#5516(   Because this mechanism requires sharing the session database between),
    CONTENT#5517(   server nodes in environments with multiple distributed servers, it),
    CONTENT#5518(   may be hard to achieve high rates of successful PSK 0-RTT connections),
    CONTENT#5519(   when compared to self-encrypted tickets.  Unlike session databases,),
    CONTENT#5520(   session tickets can successfully do PSK-based session establishment),
    CONTENT#5521(   even without consistent storage, though when 0-RTT is allowed they),
    CONTENT#5522(   still require consistent storage for anti-replay of 0-RTT data, as),
    CONTENT#5523(   detailed in the following section.),
      BREAK#5524,
    SECTION#5525(id=8.2, title=Client Hello Recording),
      BREAK#5526,
    CONTENT#5527(   An alternative form of anti-replay is to record a unique value),
    CONTENT#5528(   derived from the ClientHello (generally either the random value or),
    CONTENT#5529(   the PSK binder) and reject duplicates.  Recording all ClientHellos),
    CONTENT#5530(   causes state to grow without bound, but a server can instead record),
    CONTENT#5531(   ClientHellos within a given time window and use the),
    CONTENT#5532(   "obfuscated_ticket_age" to ensure that tickets aren't reused outside),
    CONTENT#5533(   that window.),
      BREAK#5534,
    CONTENT#5535(   In order to implement this, when a ClientHello is received, the),
    CONTENT#5536(   server first verifies the PSK binder as described in Section 4.2.11.),
    CONTENT#5537(   It then computes the expected_arrival_time as described in the next),
    CONTENT#5538(   section and rejects 0-RTT if it is outside the recording window,),
    CONTENT#5539(   falling back to the 1-RTT handshake.),
      BREAK#5540,
      BREAK#5541,
      BREAK#5542,
      BREAK#5543,
      BREAK#5544,
      BREAK#5546,
      BREAK#5548,
      BREAK#5549,
    CONTENT#5550(   If the expected_arrival_time is in the window, then the server checks),
    CONTENT#5551(   to see if it has recorded a matching ClientHello.  If one is found,),
    CONTENT#5552(   it either aborts the handshake with an "illegal_parameter" alert or),
    CONTENT#5553(   accepts the PSK but rejects 0-RTT.  If no matching ClientHello is),
    CONTENT#5554(   found, then it accepts 0-RTT and then stores the ClientHello for as),
    CONTENT#5555(   long as the expected_arrival_time is inside the window.  Servers MAY),
    CONTENT#5556(   also implement data stores with false positives, such as Bloom),
    CONTENT#5557(   filters, in which case they MUST respond to apparent replay by),
    CONTENT#5558(   rejecting 0-RTT but MUST NOT abort the handshake.),
      BREAK#5559,
    CONTENT#5560(   The server MUST derive the storage key only from validated sections),
    CONTENT#5561(   of the ClientHello.  If the ClientHello contains multiple PSK),
    CONTENT#5562(   identities, then an attacker can create multiple ClientHellos with),
    CONTENT#5563(   different binder values for the less-preferred identity on the),
    CONTENT#5564(   assumption that the server will not verify it (as recommended by),
    CONTENT#5565(   Section 4.2.11).  I.e., if the client sends PSKs A and B but the),
    CONTENT#5566(   server prefers A, then the attacker can change the binder for B),
    CONTENT#5567(   without affecting the binder for A.  If the binder for B is part of),
    CONTENT#5568(   the storage key, then this ClientHello will not appear as a),
    CONTENT#5569(   duplicate, which will cause the ClientHello to be accepted, and may),
    CONTENT#5570(   cause side effects such as replay cache pollution, although any 0-RTT),
    CONTENT#5571(   data will not be decryptable because it will use different keys.  If),
    CONTENT#5572(   the validated binder or the ClientHello.random is used as the storage),
    CONTENT#5573(   key, then this attack is not possible.),
      BREAK#5574,
    CONTENT#5575(   Because this mechanism does not require storing all outstanding),
    CONTENT#5576(   tickets, it may be easier to implement in distributed systems with),
    CONTENT#5577(   high rates of resumption and 0-RTT, at the cost of potentially weaker),
    CONTENT#5578(   anti-replay defense because of the difficulty of reliably storing and),
    CONTENT#5579(   retrieving the received ClientHello messages.  In many such systems,),
    CONTENT#5580(   it is impractical to have globally consistent storage of all the),
    CONTENT#5581(   received ClientHellos.  In this case, the best anti-replay protection),
    CONTENT#5582(   is provided by having a single storage zone be authoritative for a),
    CONTENT#5583(   given ticket and refusing 0-RTT for that ticket in any other zone.),
    CONTENT#5584(   This approach prevents simple replay by the attacker because only one),
    CONTENT#5585(   zone will accept 0-RTT data.  A weaker design is to implement),
    CONTENT#5586(   separate storage for each zone but allow 0-RTT in any zone.  This),
    CONTENT#5587(   approach limits the number of replays to once per zone.  Application),
    CONTENT#5588(   message duplication of course remains possible with either design.),
      BREAK#5589,
    CONTENT#5590(   When implementations are freshly started, they SHOULD reject 0-RTT as),
    CONTENT#5591(   long as any portion of their recording window overlaps the startup),
    CONTENT#5592(   time.  Otherwise, they run the risk of accepting replays which were),
    CONTENT#5593(   originally sent during that period.),
      BREAK#5594,
      BREAK#5595,
      BREAK#5596,
      BREAK#5597,
      BREAK#5598,
      BREAK#5599,
      BREAK#5600,
      BREAK#5602,
      BREAK#5604,
      BREAK#5605,
    CONTENT#5606(   Note: If the client's clock is running much faster than the server's,),
    CONTENT#5607(   then a ClientHello may be received that is outside the window in the),
    CONTENT#5608(   future, in which case it might be accepted for 1-RTT, causing a),
    CONTENT#5609(   client retry, and then acceptable later for 0-RTT.  This is another),
    CONTENT#5610(   variant of the second form of attack described in Section 8.),
      BREAK#5611,
    SECTION#5612(id=8.3, title=Freshness Checks),
      BREAK#5613,
    CONTENT#5614(   Because the ClientHello indicates the time at which the client sent),
    CONTENT#5615(   it, it is possible to efficiently determine whether a ClientHello was),
    CONTENT#5616(   likely sent reasonably recently and only accept 0-RTT for such a),
    CONTENT#5617(   ClientHello, otherwise falling back to a 1-RTT handshake.  This is),
    CONTENT#5618(   necessary for the ClientHello storage mechanism described in),
    CONTENT#5619(   Section 8.2 because otherwise the server needs to store an unlimited),
    CONTENT#5620(   number of ClientHellos, and is a useful optimization for self-),
    CONTENT#5621(   contained single-use tickets because it allows efficient rejection of),
    CONTENT#5622(   ClientHellos which cannot be used for 0-RTT.),
      BREAK#5623,
    CONTENT#5624(   In order to implement this mechanism, a server needs to store the),
    CONTENT#5625(   time that the server generated the session ticket, offset by an),
    CONTENT#5626(   estimate of the round-trip time between client and server.  I.e.,),
      BREAK#5627,
    CONTENT#5628(       adjusted_creation_time = creation_time + estimated_RTT),
      BREAK#5629,
    CONTENT#5630(   This value can be encoded in the ticket, thus avoiding the need to),
    CONTENT#5631(   keep state for each outstanding ticket.  The server can determine the),
    CONTENT#5632(   client's view of the age of the ticket by subtracting the ticket's),
    CONTENT#5633(   "ticket_age_add" value from the "obfuscated_ticket_age" parameter in),
    CONTENT#5634(   the client's "pre_shared_key" extension.  The server can determine),
    CONTENT#5635(   the expected_arrival_time of the ClientHello as:),
      BREAK#5636,
    CONTENT#5637(     expected_arrival_time = adjusted_creation_time + clients_ticket_age),
      BREAK#5638,
    CONTENT#5639(   When a new ClientHello is received, the expected_arrival_time is then),
    CONTENT#5640(   compared against the current server wall clock time and if they),
    CONTENT#5641(   differ by more than a certain amount, 0-RTT is rejected, though the),
    CONTENT#5642(   1-RTT handshake can be allowed to complete.),
      BREAK#5643,
      BREAK#5644,
      BREAK#5645,
      BREAK#5646,
      BREAK#5647,
      BREAK#5648,
      BREAK#5649,
      BREAK#5650,
      BREAK#5651,
      BREAK#5652,
      BREAK#5653,
      BREAK#5654,
      BREAK#5655,
      BREAK#5656,
      BREAK#5658,
      BREAK#5660,
      BREAK#5661,
    CONTENT#5662(   There are several potential sources of error that might cause),
    CONTENT#5663(   mismatches between the expected_arrival_time and the measured time.),
    CONTENT#5664(   Variations in client and server clock rates are likely to be minimal,),
    CONTENT#5665(   though potentially the absolute times may be off by large values.),
    CONTENT#5666(   Network propagation delays are the most likely causes of a mismatch),
    CONTENT#5667(   in legitimate values for elapsed time.  Both the NewSessionTicket and),
    CONTENT#5668(   ClientHello messages might be retransmitted and therefore delayed,),
    CONTENT#5669(   which might be hidden by TCP.  For clients on the Internet, this),
    CONTENT#5670(   implies windows on the order of ten seconds to account for errors in),
    CONTENT#5671(   clocks and variations in measurements; other deployment scenarios may),
    CONTENT#5672(   have different needs.  Clock skew distributions are not symmetric, so),
    CONTENT#5673(   the optimal tradeoff may involve an asymmetric range of permissible),
    CONTENT#5674(   mismatch values.),
      BREAK#5675,
    CONTENT#5676(   Note that freshness checking alone is not sufficient to prevent),
    CONTENT#5677(   replays because it does not detect them during the error window,),
    CONTENT#5678(   which -- depending on bandwidth and system capacity -- could include),
    CONTENT#5679(   billions of replays in real-world settings.  In addition, this),
    CONTENT#5680(   freshness checking is only done at the time the ClientHello is),
    CONTENT#5681(   received and not when subsequent early Application Data records are),
    CONTENT#5682(   received.  After early data is accepted, records may continue to be),
    CONTENT#5683(   streamed to the server over a longer time period.),
      BREAK#5684,
    SECTION#5685(id=9, title=Compliance Requirements),
      BREAK#5686,
    SECTION#5687(id=9.1, title=Mandatory-to-Implement Cipher Suites),
      BREAK#5688,
    CONTENT#5689(   In the absence of an application profile standard specifying),
    CONTENT#5690(   otherwise:),
      BREAK#5691,
    CONTENT#5692(   A TLS-compliant application MUST implement the TLS_AES_128_GCM_SHA256),
    CONTENT#5693(   [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384),
    CONTENT#5694(   [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites (see),
    CONTENT#5695(   Appendix B.4).),
      BREAK#5696,
    CONTENT#5697(   A TLS-compliant application MUST support digital signatures with),
    CONTENT#5698(   rsa_pkcs1_sha256 (for certificates), rsa_pss_rsae_sha256 (for),
    CONTENT#5699(   CertificateVerify and certificates), and ecdsa_secp256r1_sha256.  A),
    CONTENT#5700(   TLS-compliant application MUST support key exchange with secp256r1),
    CONTENT#5701(   (NIST P-256) and SHOULD support key exchange with X25519 [RFC7748].),
      BREAK#5702,
      BREAK#5703,
      BREAK#5704,
      BREAK#5705,
      BREAK#5706,
      BREAK#5707,
      BREAK#5708,
      BREAK#5709,
      BREAK#5710,
      BREAK#5711,
      BREAK#5712,
      BREAK#5714,
      BREAK#5716,
      BREAK#5717,
    SECTION#5718(id=9.2, title=Mandatory-to-Implement Extensions),
      BREAK#5719,
    CONTENT#5720(   In the absence of an application profile standard specifying),
    CONTENT#5721(   otherwise, a TLS-compliant application MUST implement the following),
    CONTENT#5722(   TLS extensions:),
      BREAK#5723,
    CONTENT#5724(   -  Supported Versions ("supported_versions"; Section 4.2.1)),
      BREAK#5725,
    CONTENT#5726(   -  Cookie ("cookie"; Section 4.2.2)),
      BREAK#5727,
    CONTENT#5728(   -  Signature Algorithms ("signature_algorithms"; Section 4.2.3)),
      BREAK#5729,
    CONTENT#5730(   -  Signature Algorithms Certificate ("signature_algorithms_cert";),
    CONTENT#5731(      Section 4.2.3)),
      BREAK#5732,
    CONTENT#5733(   -  Negotiated Groups ("supported_groups"; Section 4.2.7)),
      BREAK#5734,
    CONTENT#5735(   -  Key Share ("key_share"; Section 4.2.8)),
      BREAK#5736,
    CONTENT#5737(   -  Server Name Indication ("server_name"; Section 3 of [RFC6066])),
      BREAK#5738,
    CONTENT#5739(   All implementations MUST send and use these extensions when offering),
    CONTENT#5740(   applicable features:),
      BREAK#5741,
    CONTENT#5742(   -  "supported_versions" is REQUIRED for all ClientHello, ServerHello,),
    CONTENT#5743(      and HelloRetryRequest messages.),
      BREAK#5744,
    CONTENT#5745(   -  "signature_algorithms" is REQUIRED for certificate authentication.),
      BREAK#5746,
    CONTENT#5747(   -  "supported_groups" is REQUIRED for ClientHello messages using DHE),
    CONTENT#5748(      or ECDHE key exchange.),
      BREAK#5749,
    CONTENT#5750(   -  "key_share" is REQUIRED for DHE or ECDHE key exchange.),
      BREAK#5751,
    CONTENT#5752(   -  "pre_shared_key" is REQUIRED for PSK key agreement.),
      BREAK#5753,
    CONTENT#5754(   -  "psk_key_exchange_modes" is REQUIRED for PSK key agreement.),
      BREAK#5755,
      BREAK#5756,
      BREAK#5757,
      BREAK#5758,
      BREAK#5759,
      BREAK#5760,
      BREAK#5761,
      BREAK#5762,
      BREAK#5763,
      BREAK#5764,
      BREAK#5765,
      BREAK#5766,
      BREAK#5767,
      BREAK#5768,
      BREAK#5770,
      BREAK#5772,
      BREAK#5773,
    CONTENT#5774(   A client is considered to be attempting to negotiate using this),
    CONTENT#5775(   specification if the ClientHello contains a "supported_versions"),
    CONTENT#5776(   extension with 0x0304 contained in its body.  Such a ClientHello),
    CONTENT#5777(   message MUST meet the following requirements:),
      BREAK#5778,
    CONTENT#5779(   -  If not containing a "pre_shared_key" extension, it MUST contain),
    CONTENT#5780(      both a "signature_algorithms" extension and a "supported_groups"),
    CONTENT#5781(      extension.),
      BREAK#5782,
    CONTENT#5783(   -  If containing a "supported_groups" extension, it MUST also contain),
    CONTENT#5784(      a "key_share" extension, and vice versa.  An empty),
    CONTENT#5785(      KeyShare.client_shares vector is permitted.),
      BREAK#5786,
    CONTENT#5787(   Servers receiving a ClientHello which does not conform to these),
    CONTENT#5788(   requirements MUST abort the handshake with a "missing_extension"),
    CONTENT#5789(   alert.),
      BREAK#5790,
    CONTENT#5791(   Additionally, all implementations MUST support the use of the),
    CONTENT#5792(   "server_name" extension with applications capable of using it.),
    CONTENT#5793(   Servers MAY require clients to send a valid "server_name" extension.),
    CONTENT#5794(   Servers requiring this extension SHOULD respond to a ClientHello),
    CONTENT#5795(   lacking a "server_name" extension by terminating the connection with),
    CONTENT#5796(   a "missing_extension" alert.),
      BREAK#5797,
    SECTION#5798(id=9.3, title=Protocol Invariants),
      BREAK#5799,
    CONTENT#5800(   This section describes invariants that TLS endpoints and middleboxes),
    CONTENT#5801(   MUST follow.  It also applies to earlier versions of TLS.),
      BREAK#5802,
    CONTENT#5803(   TLS is designed to be securely and compatibly extensible.  Newer),
    CONTENT#5804(   clients or servers, when communicating with newer peers, should),
    CONTENT#5805(   negotiate the most preferred common parameters.  The TLS handshake),
    CONTENT#5806(   provides downgrade protection: Middleboxes passing traffic between a),
    CONTENT#5807(   newer client and newer server without terminating TLS should be),
    CONTENT#5808(   unable to influence the handshake (see Appendix E.1).  At the same),
    CONTENT#5809(   time, deployments update at different rates, so a newer client or),
    CONTENT#5810(   server MAY continue to support older parameters, which would allow it),
    CONTENT#5811(   to interoperate with older endpoints.),
      BREAK#5812,
      BREAK#5813,
      BREAK#5814,
      BREAK#5815,
      BREAK#5816,
      BREAK#5817,
      BREAK#5818,
      BREAK#5819,
      BREAK#5820,
      BREAK#5821,
      BREAK#5822,
      BREAK#5823,
      BREAK#5824,
      BREAK#5826,
      BREAK#5828,
      BREAK#5829,
    CONTENT#5830(   For this to work, implementations MUST correctly handle extensible),
    CONTENT#5831(   fields:),
      BREAK#5832,
    CONTENT#5833(   -  A client sending a ClientHello MUST support all parameters),
    CONTENT#5834(      advertised in it.  Otherwise, the server may fail to interoperate),
    CONTENT#5835(      by selecting one of those parameters.),
      BREAK#5836,
    CONTENT#5837(   -  A server receiving a ClientHello MUST correctly ignore all),
    CONTENT#5838(      unrecognized cipher suites, extensions, and other parameters.),
    CONTENT#5839(      Otherwise, it may fail to interoperate with newer clients.  In),
    CONTENT#5840(      TLS 1.3, a client receiving a CertificateRequest or),
    CONTENT#5841(      NewSessionTicket MUST also ignore all unrecognized extensions.),
      BREAK#5842,
    CONTENT#5843(   -  A middlebox which terminates a TLS connection MUST behave as a),
    CONTENT#5844(      compliant TLS server (to the original client), including having a),
    CONTENT#5845(      certificate which the client is willing to accept, and also as a),
    CONTENT#5846(      compliant TLS client (to the original server), including verifying),
    CONTENT#5847(      the original server's certificate.  In particular, it MUST),
    CONTENT#5848(      generate its own ClientHello containing only parameters it),
    CONTENT#5849(      understands, and it MUST generate a fresh ServerHello random),
    CONTENT#5850(      value, rather than forwarding the endpoint's value.),
      BREAK#5851,
    CONTENT#5852(      Note that TLS's protocol requirements and security analysis only),
    CONTENT#5853(      apply to the two connections separately.  Safely deploying a TLS),
    CONTENT#5854(      terminator requires additional security considerations which are),
    CONTENT#5855(      beyond the scope of this document.),
      BREAK#5856,
    CONTENT#5857(   -  A middlebox which forwards ClientHello parameters it does not),
    CONTENT#5858(      understand MUST NOT process any messages beyond that ClientHello.),
    CONTENT#5859(      It MUST forward all subsequent traffic unmodified.  Otherwise, it),
    CONTENT#5860(      may fail to interoperate with newer clients and servers.),
      BREAK#5861,
    CONTENT#5862(      Forwarded ClientHellos may contain advertisements for features not),
    CONTENT#5863(      supported by the middlebox, so the response may include future TLS),
    CONTENT#5864(      additions the middlebox does not recognize.  These additions MAY),
    CONTENT#5865(      change any message beyond the ClientHello arbitrarily.  In),
    CONTENT#5866(      particular, the values sent in the ServerHello might change, the),
    CONTENT#5867(      ServerHello format might change, and the TLSCiphertext format),
    CONTENT#5868(      might change.),
      BREAK#5869,
    CONTENT#5870(   The design of TLS 1.3 was constrained by widely deployed),
    CONTENT#5871(   non-compliant TLS middleboxes (see Appendix D.4); however, it does),
    CONTENT#5872(   not relax the invariants.  Those middleboxes continue to be),
    CONTENT#5873(   non-compliant.),
      BREAK#5874,
      BREAK#5875,
      BREAK#5876,
      BREAK#5877,
      BREAK#5878,
      BREAK#5879,
      BREAK#5880,
      BREAK#5882,
      BREAK#5884,
      BREAK#5885,
    SECTION#5886(id=10, title=Security Considerations),
      BREAK#5887,
    CONTENT#5888(   Security issues are discussed throughout this memo, especially in),
    CONTENT#5889(   Appendices C, D, and E.),
      BREAK#5890,
    SECTION#5891(id=11, title=IANA Considerations),
      BREAK#5892,
    CONTENT#5893(   This document uses several registries that were originally created in),
    CONTENT#5894(   [RFC4346] and updated in [RFC8447].  IANA has updated these to),
    CONTENT#5895(   reference this document.  The registries and their allocation),
    CONTENT#5896(   policies are below:),
      BREAK#5897,
    CONTENT#5898(   -  TLS Cipher Suites registry: values with the first byte in the),
    CONTENT#5899(      range 0-254 (decimal) are assigned via Specification Required),
    CONTENT#5900(      [RFC8126].  Values with the first byte 255 (decimal) are reserved),
    CONTENT#5901(      for Private Use [RFC8126].),
      BREAK#5902,
    CONTENT#5903(      IANA has added the cipher suites listed in Appendix B.4 to the),
    CONTENT#5904(      registry.  The "Value" and "Description" columns are taken from),
    CONTENT#5905(      the table.  The "DTLS-OK" and "Recommended" columns are both),
    CONTENT#5906(      marked as "Y" for each new cipher suite.),
      BREAK#5907,
    CONTENT#5908(   -  TLS ContentType registry: Future values are allocated via),
    CONTENT#5909(      Standards Action [RFC8126].),
      BREAK#5910,
    CONTENT#5911(   -  TLS Alerts registry: Future values are allocated via Standards),
    CONTENT#5912(      Action [RFC8126].  IANA has populated this registry with the),
    CONTENT#5913(      values from Appendix B.2.  The "DTLS-OK" column is marked as "Y"),
    CONTENT#5914(      for all such values.  Values marked as "_RESERVED" have comments),
    CONTENT#5915(      describing their previous usage.),
      BREAK#5916,
    CONTENT#5917(   -  TLS HandshakeType registry: Future values are allocated via),
    CONTENT#5918(      Standards Action [RFC8126].  IANA has updated this registry to),
    CONTENT#5919(      rename item 4 from "NewSessionTicket" to "new_session_ticket" and),
    CONTENT#5920(      populated this registry with the values from Appendix B.3.  The),
    CONTENT#5921(      "DTLS-OK" column is marked as "Y" for all such values.  Values),
    CONTENT#5922(      marked "_RESERVED" have comments describing their previous or),
    CONTENT#5923(      temporary usage.),
      BREAK#5924,
      BREAK#5925,
      BREAK#5926,
      BREAK#5927,
      BREAK#5928,
      BREAK#5929,
      BREAK#5930,
      BREAK#5931,
      BREAK#5932,
      BREAK#5933,
      BREAK#5934,
      BREAK#5935,
      BREAK#5936,
      BREAK#5938,
      BREAK#5940,
      BREAK#5941,
    CONTENT#5942(   This document also uses the TLS ExtensionType Values registry),
    CONTENT#5943(   originally created in [RFC4366].  IANA has updated it to reference),
    CONTENT#5944(   this document.  Changes to the registry follow:),
      BREAK#5945,
    CONTENT#5946(   -  IANA has updated the registration policy as follows:),
      BREAK#5947,
    CONTENT#5948(      Values with the first byte in the range 0-254 (decimal) are),
    CONTENT#5949(      assigned via Specification Required [RFC8126].  Values with the),
    CONTENT#5950(      first byte 255 (decimal) are reserved for Private Use [RFC8126].),
      BREAK#5951,
    CONTENT#5952(   -  IANA has updated this registry to include the "key_share",),
    CONTENT#5953(      "pre_shared_key", "psk_key_exchange_modes", "early_data",),
    CONTENT#5954(      "cookie", "supported_versions", "certificate_authorities",),
    CONTENT#5955(      "oid_filters", "post_handshake_auth", and),
    CONTENT#5956(      "signature_algorithms_cert" extensions with the values defined in),
    CONTENT#5957(      this document and the "Recommended" value of "Y".),
      BREAK#5958,
    CONTENT#5959(   -  IANA has updated this registry to include a "TLS 1.3" column which),
    CONTENT#5960(      lists the messages in which the extension may appear.  This column),
    CONTENT#5961(      has been initially populated from the table in Section 4.2, with),
    CONTENT#5962(      any extension not listed there marked as "-" to indicate that it),
    CONTENT#5963(      is not used by TLS 1.3.),
      BREAK#5964,
    CONTENT#5965(   This document updates an entry in the TLS Certificate Types registry),
    CONTENT#5966(   originally created in [RFC6091] and updated in [RFC8447].  IANA has),
    CONTENT#5967(   updated the entry for value 1 to have the name "OpenPGP_RESERVED",),
    CONTENT#5968(   "Recommended" value "N", and comment "Used in TLS versions prior),
    CONTENT#5969(   to 1.3."),
      BREAK#5970,
    CONTENT#5971(   This document updates an entry in the TLS Certificate Status Types),
    CONTENT#5972(   registry originally created in [RFC6961].  IANA has updated the entry),
    CONTENT#5973(   for value 2 to have the name "ocsp_multi_RESERVED" and comment "Used),
    CONTENT#5974(   in TLS versions prior to 1.3".),
      BREAK#5975,
    CONTENT#5976(   This document updates two entries in the TLS Supported Groups),
    CONTENT#5977(   registry (created under a different name by [RFC4492]; now maintained),
    CONTENT#5978(   by [RFC8422]) and updated by [RFC7919] and [RFC8447].  The entries),
    CONTENT#5979(   for values 29 and 30 (x25519 and x448) have been updated to also),
    CONTENT#5980(   refer to this document.),
      BREAK#5981,
      BREAK#5982,
      BREAK#5983,
      BREAK#5984,
      BREAK#5985,
      BREAK#5986,
      BREAK#5987,
      BREAK#5988,
      BREAK#5989,
      BREAK#5990,
      BREAK#5991,
      BREAK#5992,
      BREAK#5994,
      BREAK#5996,
      BREAK#5997,
    CONTENT#5998(   In addition, this document defines two new registries that are),
    CONTENT#5999(   maintained by IANA:),
      BREAK#6000,
    CONTENT#6001(   -  TLS SignatureScheme registry: Values with the first byte in the),
    CONTENT#6002(      range 0-253 (decimal) are assigned via Specification Required),
    CONTENT#6003(      [RFC8126].  Values with the first byte 254 or 255 (decimal) are),
    CONTENT#6004(      reserved for Private Use [RFC8126].  Values with the first byte in),
    CONTENT#6005(      the range 0-6 or with the second byte in the range 0-3 that are),
    CONTENT#6006(      not currently allocated are reserved for backward compatibility.),
    CONTENT#6007(      This registry has a "Recommended" column.  The registry has been),
    CONTENT#6008(      initially populated with the values described in Section 4.2.3.),
    CONTENT#6009(      The following values are marked as "Recommended":),
    CONTENT#6010(      ecdsa_secp256r1_sha256, ecdsa_secp384r1_sha384,),
    CONTENT#6011(      rsa_pss_rsae_sha256, rsa_pss_rsae_sha384, rsa_pss_rsae_sha512,),
    CONTENT#6012(      rsa_pss_pss_sha256, rsa_pss_pss_sha384, rsa_pss_pss_sha512, and),
    CONTENT#6013(      ed25519.  The "Recommended" column is assigned a value of "N"),
    CONTENT#6014(      unless explicitly requested, and adding a value with a),
    CONTENT#6015(      "Recommended" value of "Y" requires Standards Action [RFC8126].),
    CONTENT#6016(      IESG Approval is REQUIRED for a Y->N transition.),
      BREAK#6017,
    CONTENT#6018(   -  TLS PskKeyExchangeMode registry: Values in the range 0-253),
    CONTENT#6019(      (decimal) are assigned via Specification Required [RFC8126].),
    CONTENT#6020(      The values 254 and 255 (decimal) are reserved for Private Use),
    CONTENT#6021(      [RFC8126].  This registry has a "Recommended" column.  The),
    CONTENT#6022(      registry has been initially populated with psk_ke (0) and),
    CONTENT#6023(      psk_dhe_ke (1).  Both are marked as "Recommended".  The),
    CONTENT#6024(      "Recommended" column is assigned a value of "N" unless explicitly),
    CONTENT#6025(      requested, and adding a value with a "Recommended" value of "Y"),
    CONTENT#6026(      requires Standards Action [RFC8126].  IESG Approval is REQUIRED),
    CONTENT#6027(      for a Y->N transition.),
      BREAK#6028,
      BREAK#6029,
      BREAK#6030,
      BREAK#6031,
      BREAK#6032,
      BREAK#6033,
      BREAK#6034,
      BREAK#6035,
      BREAK#6036,
      BREAK#6037,
      BREAK#6038,
      BREAK#6039,
      BREAK#6040,
      BREAK#6041,
      BREAK#6042,
      BREAK#6043,
      BREAK#6044,
      BREAK#6045,
      BREAK#6046,
      BREAK#6047,
      BREAK#6048,
      BREAK#6050,
      BREAK#6052,
      BREAK#6053,
    SECTION#6054(id=12, title=References),
      BREAK#6055,
    SECTION#6056(id=12.1, title=Normative References),
      BREAK#6057,
    CONTENT#6058(   [DH76]     Diffie, W. and M. Hellman, "New directions in),
    CONTENT#6059(              cryptography", IEEE Transactions on Information),
    CONTENT#6060(              Theory, Vol. 22 No. 6, pp. 644-654,),
    CONTENT#6061(              DOI 10.1109/TIT.1976.1055638, November 1976.),
      BREAK#6062,
    CONTENT#6063(   [ECDSA]    American National Standards Institute, "Public Key),
    CONTENT#6064(              Cryptography for the Financial Services Industry: The),
    CONTENT#6065(              Elliptic Curve Digital Signature Algorithm (ECDSA)",),
    CONTENT#6066(              ANSI ANS X9.62-2005, November 2005.),
      BREAK#6067,
    CONTENT#6068(   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of),
    CONTENT#6069(              Operation: Galois/Counter Mode (GCM) and GMAC",),
    CONTENT#6070(              NIST Special Publication 800-38D,),
    CONTENT#6071(              DOI 10.6028/NIST.SP.800-38D, November 2007.),
      BREAK#6072,
    CONTENT#6073(   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti, "HMAC: Keyed-),
    CONTENT#6074(              Hashing for Message Authentication", RFC 2104,),
    CONTENT#6075(              DOI 10.17487/RFC2104, February 1997,),
    CONTENT#6076(              <https://www.rfc-editor.org/info/rfc2104>.),
      BREAK#6077,
    CONTENT#6078(   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate),
    CONTENT#6079(              Requirement Levels", BCP 14, RFC 2119,),
    CONTENT#6080(              DOI 10.17487/RFC2119, March 1997,),
    CONTENT#6081(              <https://www.rfc-editor.org/info/rfc2119>.),
      BREAK#6082,
    CONTENT#6083(   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated),
    CONTENT#6084(              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,),
    CONTENT#6085(              <https://www.rfc-editor.org/info/rfc5116>.),
      BREAK#6086,
    CONTENT#6087(   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,),
    CONTENT#6088(              Housley, R., and W. Polk, "Internet X.509 Public Key),
    CONTENT#6089(              Infrastructure Certificate and Certificate Revocation List),
    CONTENT#6090(              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,),
    CONTENT#6091(              <https://www.rfc-editor.org/info/rfc5280>.),
      BREAK#6092,
    CONTENT#6093(   [RFC5705]  Rescorla, E., "Keying Material Exporters for Transport),
    CONTENT#6094(              Layer Security (TLS)", RFC 5705, DOI 10.17487/RFC5705,),
    CONTENT#6095(              March 2010, <https://www.rfc-editor.org/info/rfc5705>.),
      BREAK#6096,
    CONTENT#6097(   [RFC5756]  Turner, S., Brown, D., Yiu, K., Housley, R., and T. Polk,),
    CONTENT#6098(              "Updates for RSAES-OAEP and RSASSA-PSS Algorithm),
    CONTENT#6099(              Parameters", RFC 5756, DOI 10.17487/RFC5756, January 2010,),
    CONTENT#6100(              <https://www.rfc-editor.org/info/rfc5756>.),
      BREAK#6101,
      BREAK#6102,
      BREAK#6103,
      BREAK#6104,
      BREAK#6106,
      BREAK#6108,
      BREAK#6109,
    CONTENT#6110(   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand),
    CONTENT#6111(              Key Derivation Function (HKDF)", RFC 5869,),
    CONTENT#6112(              DOI 10.17487/RFC5869, May 2010,),
    CONTENT#6113(              <https://www.rfc-editor.org/info/rfc5869>.),
      BREAK#6114,
    CONTENT#6115(   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)),
    CONTENT#6116(              Extensions: Extension Definitions", RFC 6066,),
    CONTENT#6117(              DOI 10.17487/RFC6066, January 2011,),
    CONTENT#6118(              <https://www.rfc-editor.org/info/rfc6066>.),
      BREAK#6119,
    CONTENT#6120(   [RFC6655]  McGrew, D. and D. Bailey, "AES-CCM Cipher Suites for),
    CONTENT#6121(              Transport Layer Security (TLS)", RFC 6655,),
    CONTENT#6122(              DOI 10.17487/RFC6655, July 2012,),
    CONTENT#6123(              <https://www.rfc-editor.org/info/rfc6655>.),
      BREAK#6124,
    CONTENT#6125(   [RFC6960]  Santesson, S., Myers, M., Ankney, R., Malpani, A.,),
    CONTENT#6126(              Galperin, S., and C. Adams, "X.509 Internet Public Key),
    CONTENT#6127(              Infrastructure Online Certificate Status Protocol - OCSP",),
    CONTENT#6128(              RFC 6960, DOI 10.17487/RFC6960, June 2013,),
    CONTENT#6129(              <https://www.rfc-editor.org/info/rfc6960>.),
      BREAK#6130,
    CONTENT#6131(   [RFC6961]  Pettersen, Y., "The Transport Layer Security (TLS)),
    CONTENT#6132(              Multiple Certificate Status Request Extension", RFC 6961,),
    CONTENT#6133(              DOI 10.17487/RFC6961, June 2013,),
    CONTENT#6134(              <https://www.rfc-editor.org/info/rfc6961>.),
      BREAK#6135,
    CONTENT#6136(   [RFC6962]  Laurie, B., Langley, A., and E. Kasper, "Certificate),
    CONTENT#6137(              Transparency", RFC 6962, DOI 10.17487/RFC6962, June 2013,),
    CONTENT#6138(              <https://www.rfc-editor.org/info/rfc6962>.),
      BREAK#6139,
    CONTENT#6140(   [RFC6979]  Pornin, T., "Deterministic Usage of the Digital Signature),
    CONTENT#6141(              Algorithm (DSA) and Elliptic Curve Digital Signature),
    CONTENT#6142(              Algorithm (ECDSA)", RFC 6979, DOI 10.17487/RFC6979,),
    CONTENT#6143(              August 2013, <https://www.rfc-editor.org/info/rfc6979>.),
      BREAK#6144,
    CONTENT#6145(   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,),
    CONTENT#6146(              "Transport Layer Security (TLS) Application-Layer Protocol),
    CONTENT#6147(              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,),
    CONTENT#6148(              July 2014, <https://www.rfc-editor.org/info/rfc7301>.),
      BREAK#6149,
    CONTENT#6150(   [RFC7507]  Moeller, B. and A. Langley, "TLS Fallback Signaling Cipher),
    CONTENT#6151(              Suite Value (SCSV) for Preventing Protocol Downgrade),
    CONTENT#6152(              Attacks", RFC 7507, DOI 10.17487/RFC7507, April 2015,),
    CONTENT#6153(              <https://www.rfc-editor.org/info/rfc7507>.),
      BREAK#6154,
    CONTENT#6155(   [RFC7748]  Langley, A., Hamburg, M., and S. Turner, "Elliptic Curves),
    CONTENT#6156(              for Security", RFC 7748, DOI 10.17487/RFC7748,),
    CONTENT#6157(              January 2016, <https://www.rfc-editor.org/info/rfc7748>.),
      BREAK#6158,
      BREAK#6159,
      BREAK#6160,
      BREAK#6162,
      BREAK#6164,
      BREAK#6165,
    CONTENT#6166(   [RFC7919]  Gillmor, D., "Negotiated Finite Field Diffie-Hellman),
    CONTENT#6167(              Ephemeral Parameters for Transport Layer Security (TLS)",),
    CONTENT#6168(              RFC 7919, DOI 10.17487/RFC7919, August 2016,),
    CONTENT#6169(              <https://www.rfc-editor.org/info/rfc7919>.),
      BREAK#6170,
    CONTENT#6171(   [RFC8017]  Moriarty, K., Ed., Kaliski, B., Jonsson, J., and A. Rusch,),
    CONTENT#6172(              "PKCS #1: RSA Cryptography Specifications Version 2.2",),
    CONTENT#6173(              RFC 8017, DOI 10.17487/RFC8017, November 2016,),
    CONTENT#6174(              <https://www.rfc-editor.org/info/rfc8017>.),
      BREAK#6175,
    CONTENT#6176(   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital),
    CONTENT#6177(              Signature Algorithm (EdDSA)", RFC 8032,),
    CONTENT#6178(              DOI 10.17487/RFC8032, January 2017,),
    CONTENT#6179(              <https://www.rfc-editor.org/info/rfc8032>.),
      BREAK#6180,
    CONTENT#6181(   [RFC8126]  Cotton, M., Leiba, B., and T. Narten, "Guidelines for),
    CONTENT#6182(              Writing an IANA Considerations Section in RFCs", BCP 26,),
    CONTENT#6183(              RFC 8126, DOI 10.17487/RFC8126, June 2017,),
    CONTENT#6184(              <https://www.rfc-editor.org/info/rfc8126>.),
      BREAK#6185,
    CONTENT#6186(   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in),
    CONTENT#6187(              RFC 2119 Key Words", BCP 14, RFC 8174,),
    CONTENT#6188(              DOI 10.17487/RFC8174, May 2017,),
    CONTENT#6189(              <https://www.rfc-editor.org/info/rfc8174>.),
      BREAK#6190,
    CONTENT#6191(   [RFC8439]  Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF),
    CONTENT#6192(              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,),
    CONTENT#6193(              <https://www.rfc-editor.org/info/rfc8439>.),
      BREAK#6194,
    CONTENT#6195(   [SHS]      Dang, Q., "Secure Hash Standard (SHS)", National Institute),
    CONTENT#6196(              of Standards and Technology report,),
    CONTENT#6197(              DOI 10.6028/NIST.FIPS.180-4, August 2015.),
      BREAK#6198,
    CONTENT#6199(   [X690]     ITU-T, "Information technology -- ASN.1 encoding rules:),
    CONTENT#6200(              Specification of Basic Encoding Rules (BER), Canonical),
    CONTENT#6201(              Encoding Rules (CER) and Distinguished Encoding Rules),
    CONTENT#6202(              (DER)", ISO/IEC 8825-1:2015, November 2015.),
      BREAK#6203,
      BREAK#6204,
      BREAK#6205,
      BREAK#6206,
      BREAK#6207,
      BREAK#6208,
      BREAK#6209,
      BREAK#6210,
      BREAK#6211,
      BREAK#6212,
      BREAK#6213,
      BREAK#6214,
      BREAK#6215,
      BREAK#6216,
      BREAK#6218,
      BREAK#6220,
      BREAK#6221,
    SECTION#6222(id=12.2, title=Informative References),
      BREAK#6223,
    CONTENT#6224(   [AEAD-LIMITS]),
    CONTENT#6225(              Luykx, A. and K. Paterson, "Limits on Authenticated),
    CONTENT#6226(              Encryption Use in TLS", August 2017,),
    CONTENT#6227(              <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.),
      BREAK#6228,
    CONTENT#6229(   [BBFGKZ16]),
    CONTENT#6230(              Bhargavan, K., Brzuska, C., Fournet, C., Green, M.,),
    CONTENT#6231(              Kohlweiss, M., and S. Zanella-Beguelin, "Downgrade),
    CONTENT#6232(              Resilience in Key-Exchange Protocols", Proceedings of IEEE),
    CONTENT#6233(              Symposium on Security and Privacy (San Jose),),
    CONTENT#6234(              DOI 10.1109/SP.2016.37, May 2016.),
      BREAK#6235,
    CONTENT#6236(   [BBK17]    Bhargavan, K., Blanchet, B., and N. Kobeissi, "Verified),
    CONTENT#6237(              Models and Reference Implementations for the TLS 1.3),
    CONTENT#6238(              Standard Candidate", Proceedings of IEEE Symposium on),
    CONTENT#6239(              Security and Privacy (San Jose), DOI 10.1109/SP.2017.26,),
    CONTENT#6240(              May 2017.),
      BREAK#6241,
    CONTENT#6242(   [BDFKPPRSZZ16]),
    CONTENT#6243(              Bhargavan, K., Delignat-Lavaud, A., Fournet, C.,),
    CONTENT#6244(              Kohlweiss, M., Pan, J., Protzenko, J., Rastogi, A., Swamy,),
    CONTENT#6245(              N., Zanella-Beguelin, S., and J. Zinzindohoue,),
    CONTENT#6246(              "Implementing and Proving the TLS 1.3 Record Layer",),
    CONTENT#6247(              Proceedings of IEEE Symposium on Security and Privacy (San),
    CONTENT#6248(              Jose), May 2017, <https://eprint.iacr.org/2016/1178>.),
      BREAK#6249,
    CONTENT#6250(   [Ben17a]   Benjamin, D., "Presentation before the TLS WG at),
    CONTENT#6251(              IETF 100", November 2017,),
    CONTENT#6252(              <https://datatracker.ietf.org/meeting/100/materials/),
    CONTENT#6253(              slides-100-tls-sessa-tls13/>.),
      BREAK#6254,
    CONTENT#6255(   [Ben17b]   Benjamin, D., "Additional TLS 1.3 results from Chrome",),
    CONTENT#6256(              message to the TLS mailing list, 18 December 2017,),
    CONTENT#6257(              <https://www.ietf.org/mail-archive/web/tls/current/),
    CONTENT#6258(              msg25168.html>.),
      BREAK#6259,
    CONTENT#6260(   [Blei98]   Bleichenbacher, D., "Chosen Ciphertext Attacks against),
    CONTENT#6261(              Protocols Based on RSA Encryption Standard PKCS #1",),
    CONTENT#6262(              Proceedings of CRYPTO '98, 1998.),
      BREAK#6263,
    CONTENT#6264(   [BMMRT15]  Badertscher, C., Matt, C., Maurer, U., Rogaway, P., and B.),
    CONTENT#6265(              Tackmann, "Augmented Secure Channels and the Goal of the),
    CONTENT#6266(              TLS 1.3 Record Layer", ProvSec 2015, September 2015,),
    CONTENT#6267(              <https://eprint.iacr.org/2015/394>.),
      BREAK#6268,
      BREAK#6269,
      BREAK#6270,
      BREAK#6271,
      BREAK#6272,
      BREAK#6274,
      BREAK#6276,
      BREAK#6277,
    CONTENT#6278(   [BT16]     Bellare, M. and B. Tackmann, "The Multi-User Security of),
    CONTENT#6279(              Authenticated Encryption: AES-GCM in TLS 1.3", Proceedings),
    CONTENT#6280(              of CRYPTO 2016, July 2016,),
    CONTENT#6281(              <https://eprint.iacr.org/2016/564>.),
      BREAK#6282,
    CONTENT#6283(   [CCG16]    Cohn-Gordon, K., Cremers, C., and L. Garratt, "On),
    CONTENT#6284(              Post-compromise Security", IEEE Computer Security),
    CONTENT#6285(              Foundations Symposium, DOI 10.1109/CSF.2016.19, July 2015.),
      BREAK#6286,
    CONTENT#6287(   [CHECKOWAY]),
    CONTENT#6288(              Checkoway, S., Maskiewicz, J., Garman, C., Fried, J.,),
    CONTENT#6289(              Cohney, S., Green, M., Heninger, N., Weinmann, R.,),
    CONTENT#6290(              Rescorla, E., and H. Shacham, "A Systematic Analysis of),
    CONTENT#6291(              the Juniper Dual EC Incident", Proceedings of the 2016 ACM),
    CONTENT#6292(              SIGSAC Conference on Computer and Communications Security),
    CONTENT#6293(              - CCS '16, DOI 10.1145/2976749.2978395, October 2016.),
      BREAK#6294,
    CONTENT#6295(   [CHHSV17]  Cremers, C., Horvat, M., Hoyland, J., Scott, S., and T.),
    CONTENT#6296(              van der Merwe, "Awkward Handshake: Possible mismatch of),
    CONTENT#6297(              client/server view on client authentication in),
    CONTENT#6298(              post-handshake mode in Revision 18", message to the TLS),
    CONTENT#6299(              mailing list, 10 February 2017, <https://www.ietf.org/),
    CONTENT#6300(              mail-archive/web/tls/current/msg22382.html>.),
      BREAK#6301,
    CONTENT#6302(   [CHSV16]   Cremers, C., Horvat, M., Scott, S., and T. van der Merwe,),
    CONTENT#6303(              "Automated Analysis and Verification of TLS 1.3: 0-RTT,),
    CONTENT#6304(              Resumption and Delayed Authentication", Proceedings of),
    CONTENT#6305(              IEEE Symposium on Security and Privacy (San Jose),),
    CONTENT#6306(              DOI 10.1109/SP.2016.35, May 2016,),
    CONTENT#6307(              <https://ieeexplore.ieee.org/document/7546518/>.),
      BREAK#6308,
    CONTENT#6309(   [CK01]     Canetti, R. and H. Krawczyk, "Analysis of Key-Exchange),
    CONTENT#6310(              Protocols and Their Use for Building Secure Channels",),
    CONTENT#6311(              Proceedings of Eurocrypt 2001,),
    CONTENT#6312(              DOI 10.1007/3-540-44987-6_28, April 2001.),
      BREAK#6313,
    CONTENT#6314(   [CLINIC]   Miller, B., Huang, L., Joseph, A., and J. Tygar, "I Know),
    CONTENT#6315(              Why You Went to the Clinic: Risks and Realization of HTTPS),
    CONTENT#6316(              Traffic Analysis", Privacy Enhancing Technologies, pp.),
    CONTENT#6317(              143-163, DOI 10.1007/978-3-319-08506-7_8, 2014.),
      BREAK#6318,
    CONTENT#6319(   [DFGS15]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,),
    CONTENT#6320(              "A Cryptographic Analysis of the TLS 1.3 Handshake),
    CONTENT#6321(              Protocol Candidates", Proceedings of ACM CCS 2015,),
    CONTENT#6322(              October 2015, <https://eprint.iacr.org/2015/914>.),
      BREAK#6323,
      BREAK#6324,
      BREAK#6325,
      BREAK#6326,
      BREAK#6327,
      BREAK#6328,
      BREAK#6330,
      BREAK#6332,
      BREAK#6333,
    CONTENT#6334(   [DFGS16]   Dowling, B., Fischlin, M., Guenther, F., and D. Stebila,),
    CONTENT#6335(              "A Cryptographic Analysis of the TLS 1.3 Full and),
    CONTENT#6336(              Pre-shared Key Handshake Protocol", TRON 2016,),
    CONTENT#6337(              February 2016, <https://eprint.iacr.org/2016/081>.),
      BREAK#6338,
    CONTENT#6339(   [DOW92]    Diffie, W., van Oorschot, P., and M. Wiener,),
    CONTENT#6340(              "Authentication and authenticated key exchanges", Designs,),
    CONTENT#6341(              Codes and Cryptography, DOI 10.1007/BF00124891, June 1992.),
      BREAK#6342,
    CONTENT#6343(   [DSS]      National Institute of Standards and Technology, U.S.),
    CONTENT#6344(              Department of Commerce, "Digital Signature Standard),
    CONTENT#6345(              (DSS)", NIST FIPS PUB 186-4, DOI 10.6028/NIST.FIPS.186-4,),
    CONTENT#6346(              July 2013.),
      BREAK#6347,
    CONTENT#6348(   [FG17]     Fischlin, M. and F. Guenther, "Replay Attacks on Zero),
    CONTENT#6349(              Round-Trip Time: The Case of the TLS 1.3 Handshake),
    CONTENT#6350(              Candidates", Proceedings of EuroS&P 2017, April 2017,),
    CONTENT#6351(              <https://eprint.iacr.org/2017/082>.),
      BREAK#6352,
    CONTENT#6353(   [FGSW16]   Fischlin, M., Guenther, F., Schmidt, B., and B. Warinschi,),
    CONTENT#6354(              "Key Confirmation in Key Exchange: A Formal Treatment and),
    CONTENT#6355(              Implications for TLS 1.3", Proceedings of IEEE Symposium),
    CONTENT#6356(              on Security and Privacy (San Jose),),
    CONTENT#6357(              DOI 10.1109/SP.2016.34, May 2016,),
    CONTENT#6358(              <https://ieeexplore.ieee.org/document/7546517/>.),
      BREAK#6359,
    CONTENT#6360(   [FW15]     Weimer, F., "Factoring RSA Keys With TLS Perfect Forward),
    CONTENT#6361(              Secrecy", September 2015.),
      BREAK#6362,
    CONTENT#6363(   [HCJC16]   Husak, M., Cermak, M., Jirsik, T., and P. Celeda, "HTTPS),
    CONTENT#6364(              traffic analysis and client identification using passive),
    CONTENT#6365(              SSL/TLS fingerprinting", EURASIP Journal on Information),
    CONTENT#6366(              Security, Vol. 2016, DOI 10.1186/s13635-016-0030-7,),
    CONTENT#6367(              February 2016.),
      BREAK#6368,
    CONTENT#6369(   [HGFS15]   Hlauschek, C., Gruber, M., Fankhauser, F., and C. Schanes,),
    CONTENT#6370(              "Prying Open Pandora's Box: KCI Attacks against TLS",),
    CONTENT#6371(              Proceedings of USENIX Workshop on Offensive Technologies,),
    CONTENT#6372(              August 2015.),
      BREAK#6373,
    CONTENT#6374(   [IEEE1363]),
    CONTENT#6375(              IEEE, "IEEE Standard Specifications for Public Key),
    CONTENT#6376(              Cryptography", IEEE Std. 1363-2000,),
    CONTENT#6377(              DOI 10.1109/IEEESTD.2000.92292.),
      BREAK#6378,
      BREAK#6379,
      BREAK#6380,
      BREAK#6381,
      BREAK#6382,
      BREAK#6383,
      BREAK#6384,
      BREAK#6386,
      BREAK#6388,
      BREAK#6389,
    CONTENT#6390(   [JSS15]    Jager, T., Schwenk, J., and J. Somorovsky, "On the),
    CONTENT#6391(              Security of TLS 1.3 and QUIC Against Weaknesses in PKCS#1),
    CONTENT#6392(              v1.5 Encryption", Proceedings of ACM CCS 2015,),
    CONTENT#6393(              DOI 10.1145/2810103.2813657, October 2015,),
    CONTENT#6394(              <https://www.nds.rub.de/media/nds/),
    CONTENT#6395(              veroeffentlichungen/2015/08/21/Tls13QuicAttacks.pdf>.),
      BREAK#6396,
    CONTENT#6397(   [KEYAGREEMENT]),
    CONTENT#6398(              Barker, E., Chen, L., Roginsky, A., Vassilev, A., and R.),
    CONTENT#6399(              Davis, "Recommendation for Pair-Wise Key Establishment),
    CONTENT#6400(              Schemes Using Discrete Logarithm Cryptography", National),
    CONTENT#6401(              Institute of Standards and Technology,),
    CONTENT#6402(              DOI 10.6028/NIST.SP.800-56Ar3, April 2018.),
      BREAK#6403,
    CONTENT#6404(   [Kraw10]   Krawczyk, H., "Cryptographic Extraction and Key),
    CONTENT#6405(              Derivation: The HKDF Scheme", Proceedings of CRYPTO 2010,),
    CONTENT#6406(              August 2010, <https://eprint.iacr.org/2010/264>.),
      BREAK#6407,
    CONTENT#6408(   [Kraw16]   Krawczyk, H., "A Unilateral-to-Mutual Authentication),
    CONTENT#6409(              Compiler for Key Exchange (with Applications to Client),
    CONTENT#6410(              Authentication in TLS 1.3", Proceedings of ACM CCS 2016,),
    CONTENT#6411(              October 2016, <https://eprint.iacr.org/2016/711>.),
      BREAK#6412,
    CONTENT#6413(   [KW16]     Krawczyk, H. and H. Wee, "The OPTLS Protocol and TLS 1.3",),
    CONTENT#6414(              Proceedings of EuroS&P 2016, March 2016,),
    CONTENT#6415(              <https://eprint.iacr.org/2015/978>.),
      BREAK#6416,
    CONTENT#6417(   [LXZFH16]  Li, X., Xu, J., Zhang, Z., Feng, D., and H. Hu, "Multiple),
    CONTENT#6418(              Handshakes Security of TLS 1.3 Candidates", Proceedings of),
    CONTENT#6419(              IEEE Symposium on Security and Privacy (San Jose),),
    CONTENT#6420(              DOI 10.1109/SP.2016.36, May 2016,),
    CONTENT#6421(              <https://ieeexplore.ieee.org/document/7546519/>.),
      BREAK#6422,
    CONTENT#6423(   [Mac17]    MacCarthaigh, C., "Security Review of TLS1.3 0-RTT",),
    CONTENT#6424(              March 2017, <https://github.com/tlswg/tls13-spec/),
    CONTENT#6425(              issues/1001>.),
      BREAK#6426,
    CONTENT#6427(   [PS18]     Patton, C. and T. Shrimpton, "Partially specified),
    CONTENT#6428(              channels: The TLS 1.3 record layer without elision", 2018,),
    CONTENT#6429(              <https://eprint.iacr.org/2018/634>.),
      BREAK#6430,
    CONTENT#6431(   [PSK-FINISHED]),
    CONTENT#6432(              Scott, S., Cremers, C., Horvat, M., and T. van der Merwe,),
    CONTENT#6433(              "Revision 10: possible attack if client authentication is),
    CONTENT#6434(              allowed during PSK", message to the TLS mailing list,),
    CONTENT#6435(              31 October 2015, <https://www.ietf.org/),
    CONTENT#6436(              mail-archive/web/tls/current/msg18215.html>.),
      BREAK#6437,
      BREAK#6438,
      BREAK#6439,
      BREAK#6440,
      BREAK#6442,
      BREAK#6444,
      BREAK#6445,
    CONTENT#6446(   [REKEY]    Abdalla, M. and M. Bellare, "Increasing the Lifetime of a),
    CONTENT#6447(              Key: A Comparative Analysis of the Security of Re-keying),
    CONTENT#6448(              Techniques", ASIACRYPT 2000, DOI 10.1007/3-540-44448-3_42,),
    CONTENT#6449(              October 2000.),
      BREAK#6450,
    CONTENT#6451(   [Res17a]   Rescorla, E., "Preliminary data on Firefox TLS 1.3),
    CONTENT#6452(              Middlebox experiment", message to the TLS mailing list,),
    CONTENT#6453(              5 December 2017, <https://www.ietf.org/),
    CONTENT#6454(              mail-archive/web/tls/current/msg25091.html>.),
      BREAK#6455,
    CONTENT#6456(   [Res17b]   Rescorla, E., "More compatibility measurement results",),
    CONTENT#6457(              message to the TLS mailing list, 22 December 2017,),
    CONTENT#6458(              <https://www.ietf.org/mail-archive/web/tls/current/),
    CONTENT#6459(              msg25179.html>.),
      BREAK#6460,
    CONTENT#6461(   [RFC3552]  Rescorla, E. and B. Korver, "Guidelines for Writing RFC),
    CONTENT#6462(              Text on Security Considerations", BCP 72, RFC 3552,),
    CONTENT#6463(              DOI 10.17487/RFC3552, July 2003,),
    CONTENT#6464(              <https://www.rfc-editor.org/info/rfc3552>.),
      BREAK#6465,
    CONTENT#6466(   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,),
    CONTENT#6467(              "Randomness Requirements for Security", BCP 106, RFC 4086,),
    CONTENT#6468(              DOI 10.17487/RFC4086, June 2005,),
    CONTENT#6469(              <https://www.rfc-editor.org/info/rfc4086>.),
      BREAK#6470,
    CONTENT#6471(   [RFC4346]  Dierks, T. and E. Rescorla, "The Transport Layer Security),
    CONTENT#6472(              (TLS) Protocol Version 1.1", RFC 4346,),
    CONTENT#6473(              DOI 10.17487/RFC4346, April 2006,),
    CONTENT#6474(              <https://www.rfc-editor.org/info/rfc4346>.),
      BREAK#6475,
    CONTENT#6476(   [RFC4366]  Blake-Wilson, S., Nystrom, M., Hopwood, D., Mikkelsen, J.,),
    CONTENT#6477(              and T. Wright, "Transport Layer Security (TLS)),
    CONTENT#6478(              Extensions", RFC 4366, DOI 10.17487/RFC4366, April 2006,),
    CONTENT#6479(              <https://www.rfc-editor.org/info/rfc4366>.),
      BREAK#6480,
    CONTENT#6481(   [RFC4492]  Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and B.),
    CONTENT#6482(              Moeller, "Elliptic Curve Cryptography (ECC) Cipher Suites),
    CONTENT#6483(              for Transport Layer Security (TLS)", RFC 4492,),
    CONTENT#6484(              DOI 10.17487/RFC4492, May 2006,),
    CONTENT#6485(              <https://www.rfc-editor.org/info/rfc4492>.),
      BREAK#6486,
    CONTENT#6487(   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,),
    CONTENT#6488(              "Transport Layer Security (TLS) Session Resumption without),
    CONTENT#6489(              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,),
    CONTENT#6490(              January 2008, <https://www.rfc-editor.org/info/rfc5077>.),
      BREAK#6491,
      BREAK#6492,
      BREAK#6493,
      BREAK#6494,
      BREAK#6495,
      BREAK#6496,
      BREAK#6498,
      BREAK#6500,
      BREAK#6501,
    CONTENT#6502(   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security),
    CONTENT#6503(              (TLS) Protocol Version 1.2", RFC 5246,),
    CONTENT#6504(              DOI 10.17487/RFC5246, August 2008,),
    CONTENT#6505(              <https://www.rfc-editor.org/info/rfc5246>.),
      BREAK#6506,
    CONTENT#6507(   [RFC5764]  McGrew, D. and E. Rescorla, "Datagram Transport Layer),
    CONTENT#6508(              Security (DTLS) Extension to Establish Keys for the Secure),
    CONTENT#6509(              Real-time Transport Protocol (SRTP)", RFC 5764,),
    CONTENT#6510(              DOI 10.17487/RFC5764, May 2010,),
    CONTENT#6511(              <https://www.rfc-editor.org/info/rfc5764>.),
      BREAK#6512,
    CONTENT#6513(   [RFC5929]  Altman, J., Williams, N., and L. Zhu, "Channel Bindings),
    CONTENT#6514(              for TLS", RFC 5929, DOI 10.17487/RFC5929, July 2010,),
    CONTENT#6515(              <https://www.rfc-editor.org/info/rfc5929>.),
      BREAK#6516,
    CONTENT#6517(   [RFC6091]  Mavrogiannopoulos, N. and D. Gillmor, "Using OpenPGP Keys),
    CONTENT#6518(              for Transport Layer Security (TLS) Authentication",),
    CONTENT#6519(              RFC 6091, DOI 10.17487/RFC6091, February 2011,),
    CONTENT#6520(              <https://www.rfc-editor.org/info/rfc6091>.),
      BREAK#6521,
    CONTENT#6522(   [RFC6101]  Freier, A., Karlton, P., and P. Kocher, "The Secure),
    CONTENT#6523(              Sockets Layer (SSL) Protocol Version 3.0", RFC 6101,),
    CONTENT#6524(              DOI 10.17487/RFC6101, August 2011,),
    CONTENT#6525(              <https://www.rfc-editor.org/info/rfc6101>.),
      BREAK#6526,
    CONTENT#6527(   [RFC6176]  Turner, S. and T. Polk, "Prohibiting Secure Sockets Layer),
    CONTENT#6528(              (SSL) Version 2.0", RFC 6176, DOI 10.17487/RFC6176,),
    CONTENT#6529(              March 2011, <https://www.rfc-editor.org/info/rfc6176>.),
      BREAK#6530,
    CONTENT#6531(   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer),
    CONTENT#6532(              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,),
    CONTENT#6533(              January 2012, <https://www.rfc-editor.org/info/rfc6347>.),
      BREAK#6534,
    CONTENT#6535(   [RFC6520]  Seggelmann, R., Tuexen, M., and M. Williams, "Transport),
    CONTENT#6536(              Layer Security (TLS) and Datagram Transport Layer Security),
    CONTENT#6537(              (DTLS) Heartbeat Extension", RFC 6520,),
    CONTENT#6538(              DOI 10.17487/RFC6520, February 2012,),
    CONTENT#6539(              <https://www.rfc-editor.org/info/rfc6520>.),
      BREAK#6540,
    CONTENT#6541(   [RFC7230]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer),
    CONTENT#6542(              Protocol (HTTP/1.1): Message Syntax and Routing",),
    CONTENT#6543(              RFC 7230, DOI 10.17487/RFC7230, June 2014,),
    CONTENT#6544(              <https://www.rfc-editor.org/info/rfc7230>.),
      BREAK#6545,
      BREAK#6546,
      BREAK#6547,
      BREAK#6548,
      BREAK#6549,
      BREAK#6550,
      BREAK#6551,
      BREAK#6552,
      BREAK#6554,
      BREAK#6556,
      BREAK#6557,
    CONTENT#6558(   [RFC7250]  Wouters, P., Ed., Tschofenig, H., Ed., Gilmore, J.,),
    CONTENT#6559(              Weiler, S., and T. Kivinen, "Using Raw Public Keys in),
    CONTENT#6560(              Transport Layer Security (TLS) and Datagram Transport),
    CONTENT#6561(              Layer Security (DTLS)", RFC 7250, DOI 10.17487/RFC7250,),
    CONTENT#6562(              June 2014, <https://www.rfc-editor.org/info/rfc7250>.),
      BREAK#6563,
    CONTENT#6564(   [RFC7465]  Popov, A., "Prohibiting RC4 Cipher Suites", RFC 7465,),
    CONTENT#6565(              DOI 10.17487/RFC7465, February 2015,),
    CONTENT#6566(              <https://www.rfc-editor.org/info/rfc7465>.),
      BREAK#6567,
    CONTENT#6568(   [RFC7568]  Barnes, R., Thomson, M., Pironti, A., and A. Langley,),
    CONTENT#6569(              "Deprecating Secure Sockets Layer Version 3.0", RFC 7568,),
    CONTENT#6570(              DOI 10.17487/RFC7568, June 2015,),
    CONTENT#6571(              <https://www.rfc-editor.org/info/rfc7568>.),
      BREAK#6572,
    CONTENT#6573(   [RFC7627]  Bhargavan, K., Ed., Delignat-Lavaud, A., Pironti, A.,),
    CONTENT#6574(              Langley, A., and M. Ray, "Transport Layer Security (TLS)),
    CONTENT#6575(              Session Hash and Extended Master Secret Extension",),
    CONTENT#6576(              RFC 7627, DOI 10.17487/RFC7627, September 2015,),
    CONTENT#6577(              <https://www.rfc-editor.org/info/rfc7627>.),
      BREAK#6578,
    CONTENT#6579(   [RFC7685]  Langley, A., "A Transport Layer Security (TLS) ClientHello),
    CONTENT#6580(              Padding Extension", RFC 7685, DOI 10.17487/RFC7685,),
    CONTENT#6581(              October 2015, <https://www.rfc-editor.org/info/rfc7685>.),
      BREAK#6582,
    CONTENT#6583(   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security),
    CONTENT#6584(              (TLS) Cached Information Extension", RFC 7924,),
    CONTENT#6585(              DOI 10.17487/RFC7924, July 2016,),
    CONTENT#6586(              <https://www.rfc-editor.org/info/rfc7924>.),
      BREAK#6587,
    CONTENT#6588(   [RFC8305]  Schinazi, D. and T. Pauly, "Happy Eyeballs Version 2:),
    CONTENT#6589(              Better Connectivity Using Concurrency", RFC 8305,),
    CONTENT#6590(              DOI 10.17487/RFC8305, December 2017,),
    CONTENT#6591(              <https://www.rfc-editor.org/info/rfc8305>.),
      BREAK#6592,
    CONTENT#6593(   [RFC8422]  Nir, Y., Josefsson, S., and M. Pegourie-Gonnard, "Elliptic),
    CONTENT#6594(              Curve Cryptography (ECC) Cipher Suites for Transport Layer),
    CONTENT#6595(              Security (TLS) Versions 1.2 and Earlier", RFC 8422,),
    CONTENT#6596(              DOI 10.17487/RFC8422, August 2018,),
    CONTENT#6597(              <https://www.rfc-editor.org/info/rfc8422>.),
      BREAK#6598,
    CONTENT#6599(   [RFC8447]  Salowey, J. and S. Turner, "IANA Registry Updates for TLS),
    CONTENT#6600(              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,),
    CONTENT#6601(              <https://www.rfc-editor.org/info/rfc8447>.),
      BREAK#6602,
    CONTENT#6603(   [RFC8449]  Thomson, M., "Record Size Limit Extension for TLS",),
    CONTENT#6604(              RFC 8449, DOI 10.17487/RFC8449, August 2018,),
    CONTENT#6605(              <https://www.rfc-editor.org/info/rfc8449>.),
      BREAK#6606,
      BREAK#6607,
      BREAK#6608,
      BREAK#6610,
      BREAK#6612,
      BREAK#6613,
    CONTENT#6614(   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for),
    CONTENT#6615(              Obtaining Digital Signatures and Public-Key),
    CONTENT#6616(              Cryptosystems", Communications of the ACM, Vol. 21 No. 2,),
    CONTENT#6617(              pp. 120-126, DOI 10.1145/359340.359342, February 1978.),
      BREAK#6618,
    CONTENT#6619(   [SIGMA]    Krawczyk, H., "SIGMA: The 'SIGn-and-MAc' Approach to),
    CONTENT#6620(              Authenticated Diffie-Hellman and its Use in the IKE),
    CONTENT#6621(              Protocols", Proceedings of CRYPTO 2003,),
    CONTENT#6622(              DOI 10.1007/978-3-540-45146-4_24, August 2003.),
      BREAK#6623,
    CONTENT#6624(   [SLOTH]    Bhargavan, K. and G. Leurent, "Transcript Collision),
    CONTENT#6625(              Attacks: Breaking Authentication in TLS, IKE, and SSH",),
    CONTENT#6626(              Network and Distributed System Security),
    CONTENT#6627(              Symposium (NDSS 2016), DOI 10.14722/ndss.2016.23418,),
    CONTENT#6628(              February 2016.),
      BREAK#6629,
    CONTENT#6630(   [SSL2]     Hickman, K., "The SSL Protocol", February 1995.),
      BREAK#6631,
    CONTENT#6632(   [TIMING]   Boneh, D. and D. Brumley, "Remote Timing Attacks Are),
    CONTENT#6633(              Practical", USENIX Security Symposium, August 2003.),
      BREAK#6634,
    CONTENT#6635(   [TLS13-TRACES]),
    CONTENT#6636(              Thomson, M., "Example Handshake Traces for TLS 1.3", Work),
    CONTENT#6637(              in Progress, draft-ietf-tls-tls13-vectors-06, July 2018.),
      BREAK#6638,
    CONTENT#6639(   [X501]     ITU-T, "Information Technology - Open Systems),
    CONTENT#6640(              Interconnection - The Directory: Models", ITU-T X.501,),
    CONTENT#6641(              October 2016, <https://www.itu.int/rec/T-REC-X.501/en>.),
      BREAK#6642,
      BREAK#6643,
      BREAK#6644,
      BREAK#6645,
      BREAK#6646,
      BREAK#6647,
      BREAK#6648,
      BREAK#6649,
      BREAK#6650,
      BREAK#6651,
      BREAK#6652,
      BREAK#6653,
      BREAK#6654,
      BREAK#6655,
      BREAK#6656,
      BREAK#6657,
      BREAK#6658,
      BREAK#6659,
      BREAK#6660,
      BREAK#6661,
      BREAK#6662,
      BREAK#6663,
      BREAK#6664,
      BREAK#6666,
      BREAK#6668,
      BREAK#6669,
    SECTION#6670(id=A, title=State Machine),
      BREAK#6671,
    CONTENT#6672(   This appendix provides a summary of the legal state transitions for),
    CONTENT#6673(   the client and server handshakes.  State names (in all capitals,),
    CONTENT#6674(   e.g., START) have no formal meaning but are provided for ease of),
    CONTENT#6675(   comprehension.  Actions which are taken only in certain circumstances),
    CONTENT#6676(   are indicated in [].  The notation "K_{send,recv} = foo" means "set),
    CONTENT#6677(   the send/recv key to the given key".),
      BREAK#6678,
    SECTION#6679(id=A.1, title=Client),
      BREAK#6680,
    CONTENT#6681(                              START <----+),
    CONTENT#6682(               Send ClientHello |        | Recv HelloRetryRequest),
    CONTENT#6683(          [K_send = early data] |        |),
    CONTENT#6684(                                v        |),
    CONTENT#6685(           /                 WAIT_SH ----+),
    CONTENT#6686(           |                    | Recv ServerHello),
    CONTENT#6687(           |                    | K_recv = handshake),
    CONTENT#6688(       Can |                    V),
    CONTENT#6689(      send |                 WAIT_EE),
    CONTENT#6690(     early |                    | Recv EncryptedExtensions),
    CONTENT#6691(      data |           +--------+--------+),
    CONTENT#6692(           |     Using |                 | Using certificate),
    CONTENT#6693(           |       PSK |                 v),
    CONTENT#6694(           |           |            WAIT_CERT_CR),
    CONTENT#6695(           |           |        Recv |       | Recv CertificateRequest),
    CONTENT#6696(           |           | Certificate |       v),
    CONTENT#6697(           |           |             |    WAIT_CERT),
    CONTENT#6698(           |           |             |       | Recv Certificate),
    CONTENT#6699(           |           |             v       v),
    CONTENT#6700(           |           |              WAIT_CV),
    CONTENT#6701(           |           |                 | Recv CertificateVerify),
    CONTENT#6702(           |           +> WAIT_FINISHED <+),
    CONTENT#6703(           |                  | Recv Finished),
    CONTENT#6704(           \                  | [Send EndOfEarlyData]),
    CONTENT#6705(                              | K_send = handshake),
    CONTENT#6706(                              | [Send Certificate [+ CertificateVerify]]),
    CONTENT#6707(    Can send                  | Send Finished),
    CONTENT#6708(    app data   -->            | K_send = K_recv = application),
    CONTENT#6709(    after here                v),
    CONTENT#6710(                          CONNECTED),
      BREAK#6711,
    CONTENT#6712(   Note that with the transitions as shown above, clients may send),
    CONTENT#6713(   alerts that derive from post-ServerHello messages in the clear or),
    CONTENT#6714(   with the early data keys.  If clients need to send such alerts, they),
    CONTENT#6715(   SHOULD first rekey to the handshake keys if possible.),
      BREAK#6716,
      BREAK#6717,
      BREAK#6718,
      BREAK#6719,
      BREAK#6720,
      BREAK#6722,
      BREAK#6724,
      BREAK#6725,
    SECTION#6726(id=A.2, title=Server),
      BREAK#6727,
    CONTENT#6728(                              START <-----+),
    CONTENT#6729(               Recv ClientHello |         | Send HelloRetryRequest),
    CONTENT#6730(                                v         |),
    CONTENT#6731(                             RECVD_CH ----+),
    CONTENT#6732(                                | Select parameters),
    CONTENT#6733(                                v),
    CONTENT#6734(                             NEGOTIATED),
    CONTENT#6735(                                | Send ServerHello),
    CONTENT#6736(                                | K_send = handshake),
    CONTENT#6737(                                | Send EncryptedExtensions),
    CONTENT#6738(                                | [Send CertificateRequest]),
    CONTENT#6739( Can send                       | [Send Certificate + CertificateVerify]),
    CONTENT#6740( app data                       | Send Finished),
    CONTENT#6741( after   -->                    | K_send = application),
    CONTENT#6742( here                  +--------+--------+),
    CONTENT#6743(              No 0-RTT |                 | 0-RTT),
    CONTENT#6744(                       |                 |),
    CONTENT#6745(   K_recv = handshake  |                 | K_recv = early data),
    CONTENT#6746( [Skip decrypt errors] |    +------> WAIT_EOED -+),
    CONTENT#6747(                       |    |       Recv |      | Recv EndOfEarlyData),
    CONTENT#6748(                       |    | early data |      | K_recv = handshake),
    CONTENT#6749(                       |    +------------+      |),
    CONTENT#6750(                       |                        |),
    CONTENT#6751(                       +> WAIT_FLIGHT2 <--------+),
    CONTENT#6752(                                |),
    CONTENT#6753(                       +--------+--------+),
    CONTENT#6754(               No auth |                 | Client auth),
    CONTENT#6755(                       |                 |),
    CONTENT#6756(                       |                 v),
    CONTENT#6757(                       |             WAIT_CERT),
    CONTENT#6758(                       |        Recv |       | Recv Certificate),
    CONTENT#6759(                       |       empty |       v),
    CONTENT#6760(                       | Certificate |    WAIT_CV),
    CONTENT#6761(                       |             |       | Recv),
    CONTENT#6762(                       |             v       | CertificateVerify),
    CONTENT#6763(                       +-> WAIT_FINISHED <---+),
    CONTENT#6764(                                | Recv Finished),
    CONTENT#6765(                                | K_recv = application),
    CONTENT#6766(                                v),
    CONTENT#6767(                            CONNECTED),
      BREAK#6768,
      BREAK#6769,
      BREAK#6770,
      BREAK#6771,
      BREAK#6772,
      BREAK#6773,
      BREAK#6774,
      BREAK#6775,
      BREAK#6776,
      BREAK#6778,
      BREAK#6780,
      BREAK#6781,
    SECTION#6782(id=B, title=Protocol Data Structures and Constant Values),
      BREAK#6783,
    CONTENT#6784(   This appendix provides the normative protocol types and the),
    CONTENT#6785(   definitions for constants.  Values listed as "_RESERVED" were used in),
    CONTENT#6786(   previous versions of TLS and are listed here for completeness.),
    CONTENT#6787(   TLS 1.3 implementations MUST NOT send them but might receive them),
    CONTENT#6788(   from older TLS implementations.),
      BREAK#6789,
    SECTION#6790(id=B.1, title=Record Layer),
      BREAK#6791,
    CONTENT#6792(      enum {),
    CONTENT#6793(          invalid(0),),
    CONTENT#6794(          change_cipher_spec(20),),
    CONTENT#6795(          alert(21),),
    CONTENT#6796(          handshake(22),),
    CONTENT#6797(          application_data(23),),
    CONTENT#6798(          heartbeat(24),  /* RFC 6520 */),
    CONTENT#6799(          (255)),
    CONTENT#6800(      } ContentType;),
      BREAK#6801,
    CONTENT#6802(      struct {),
    CONTENT#6803(          ContentType type;),
    CONTENT#6804(          ProtocolVersion legacy_record_version;),
    CONTENT#6805(          uint16 length;),
    CONTENT#6806(          opaque fragment[TLSPlaintext.length];),
    CONTENT#6807(      } TLSPlaintext;),
      BREAK#6808,
    CONTENT#6809(      struct {),
    CONTENT#6810(          opaque content[TLSPlaintext.length];),
    CONTENT#6811(          ContentType type;),
    CONTENT#6812(          uint8 zeros[length_of_padding];),
    CONTENT#6813(      } TLSInnerPlaintext;),
      BREAK#6814,
    CONTENT#6815(      struct {),
    CONTENT#6816(          ContentType opaque_type = application_data; /* 23 */),
    CONTENT#6817(          ProtocolVersion legacy_record_version = 0x0303; /* TLS v1.2 */),
    CONTENT#6818(          uint16 length;),
    CONTENT#6819(          opaque encrypted_record[TLSCiphertext.length];),
    CONTENT#6820(      } TLSCiphertext;),
      BREAK#6821,
      BREAK#6822,
      BREAK#6823,
      BREAK#6824,
      BREAK#6825,
      BREAK#6826,
      BREAK#6827,
      BREAK#6828,
      BREAK#6829,
      BREAK#6830,
      BREAK#6831,
      BREAK#6832,
      BREAK#6834,
      BREAK#6836,
      BREAK#6837,
    SECTION#6838(id=B.2, title=Alert Messages),
      BREAK#6839,
    CONTENT#6840(      enum { warning(1), fatal(2), (255) } AlertLevel;),
      BREAK#6841,
    CONTENT#6842(      enum {),
    CONTENT#6843(          close_notify(0),),
    CONTENT#6844(          unexpected_message(10),),
    CONTENT#6845(          bad_record_mac(20),),
    CONTENT#6846(          decryption_failed_RESERVED(21),),
    CONTENT#6847(          record_overflow(22),),
    CONTENT#6848(          decompression_failure_RESERVED(30),),
    CONTENT#6849(          handshake_failure(40),),
    CONTENT#6850(          no_certificate_RESERVED(41),),
    CONTENT#6851(          bad_certificate(42),),
    CONTENT#6852(          unsupported_certificate(43),),
    CONTENT#6853(          certificate_revoked(44),),
    CONTENT#6854(          certificate_expired(45),),
    CONTENT#6855(          certificate_unknown(46),),
    CONTENT#6856(          illegal_parameter(47),),
    CONTENT#6857(          unknown_ca(48),),
    CONTENT#6858(          access_denied(49),),
    CONTENT#6859(          decode_error(50),),
    CONTENT#6860(          decrypt_error(51),),
    CONTENT#6861(          export_restriction_RESERVED(60),),
    CONTENT#6862(          protocol_version(70),),
    CONTENT#6863(          insufficient_security(71),),
    CONTENT#6864(          internal_error(80),),
    CONTENT#6865(          inappropriate_fallback(86),),
    CONTENT#6866(          user_canceled(90),),
    CONTENT#6867(          no_renegotiation_RESERVED(100),),
    CONTENT#6868(          missing_extension(109),),
    CONTENT#6869(          unsupported_extension(110),),
    CONTENT#6870(          certificate_unobtainable_RESERVED(111),),
    CONTENT#6871(          unrecognized_name(112),),
    CONTENT#6872(          bad_certificate_status_response(113),),
    CONTENT#6873(          bad_certificate_hash_value_RESERVED(114),),
    CONTENT#6874(          unknown_psk_identity(115),),
    CONTENT#6875(          certificate_required(116),),
    CONTENT#6876(          no_application_protocol(120),),
    CONTENT#6877(          (255)),
    CONTENT#6878(      } AlertDescription;),
      BREAK#6879,
    CONTENT#6880(      struct {),
    CONTENT#6881(          AlertLevel level;),
    CONTENT#6882(          AlertDescription description;),
    CONTENT#6883(      } Alert;),
      BREAK#6884,
      BREAK#6885,
      BREAK#6886,
      BREAK#6887,
      BREAK#6888,
      BREAK#6890,
      BREAK#6892,
      BREAK#6893,
    SECTION#6894(id=B.3, title=Handshake Protocol),
      BREAK#6895,
    CONTENT#6896(      enum {),
    CONTENT#6897(          hello_request_RESERVED(0),),
    CONTENT#6898(          client_hello(1),),
    CONTENT#6899(          server_hello(2),),
    CONTENT#6900(          hello_verify_request_RESERVED(3),),
    CONTENT#6901(          new_session_ticket(4),),
    CONTENT#6902(          end_of_early_data(5),),
    CONTENT#6903(          hello_retry_request_RESERVED(6),),
    CONTENT#6904(          encrypted_extensions(8),),
    CONTENT#6905(          certificate(11),),
    CONTENT#6906(          server_key_exchange_RESERVED(12),),
    CONTENT#6907(          certificate_request(13),),
    CONTENT#6908(          server_hello_done_RESERVED(14),),
    CONTENT#6909(          certificate_verify(15),),
    CONTENT#6910(          client_key_exchange_RESERVED(16),),
    CONTENT#6911(          finished(20),),
    CONTENT#6912(          certificate_url_RESERVED(21),),
    CONTENT#6913(          certificate_status_RESERVED(22),),
    CONTENT#6914(          supplemental_data_RESERVED(23),),
    CONTENT#6915(          key_update(24),),
    CONTENT#6916(          message_hash(254),),
    CONTENT#6917(          (255)),
    CONTENT#6918(      } HandshakeType;),
      BREAK#6919,
    CONTENT#6920(      struct {),
    CONTENT#6921(          HandshakeType msg_type;    /* handshake type */),
    CONTENT#6922(          uint24 length;             /* bytes in message */),
    CONTENT#6923(          select (Handshake.msg_type) {),
    CONTENT#6924(              case client_hello:          ClientHello;),
    CONTENT#6925(              case server_hello:          ServerHello;),
    CONTENT#6926(              case end_of_early_data:     EndOfEarlyData;),
    CONTENT#6927(              case encrypted_extensions:  EncryptedExtensions;),
    CONTENT#6928(              case certificate_request:   CertificateRequest;),
    CONTENT#6929(              case certificate:           Certificate;),
    CONTENT#6930(              case certificate_verify:    CertificateVerify;),
    CONTENT#6931(              case finished:              Finished;),
    CONTENT#6932(              case new_session_ticket:    NewSessionTicket;),
    CONTENT#6933(              case key_update:            KeyUpdate;),
    CONTENT#6934(          };),
    CONTENT#6935(      } Handshake;),
      BREAK#6936,
      BREAK#6937,
      BREAK#6938,
      BREAK#6939,
      BREAK#6940,
      BREAK#6941,
      BREAK#6942,
      BREAK#6943,
      BREAK#6944,
      BREAK#6946,
      BREAK#6948,
      BREAK#6949,
    SECTION#6950(id=B.3.1, title=Key Exchange Messages),
      BREAK#6951,
    CONTENT#6952(    uint16 ProtocolVersion;),
    CONTENT#6953(    opaque Random[32];),
      BREAK#6954,
    CONTENT#6955(    uint8 CipherSuite[2];    /* Cryptographic suite selector */),
      BREAK#6956,
    CONTENT#6957(    struct {),
    CONTENT#6958(        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */),
    CONTENT#6959(        Random random;),
    CONTENT#6960(        opaque legacy_session_id<0..32>;),
    CONTENT#6961(        CipherSuite cipher_suites<2..2^16-2>;),
    CONTENT#6962(        opaque legacy_compression_methods<1..2^8-1>;),
    CONTENT#6963(        Extension extensions<8..2^16-1>;),
    CONTENT#6964(    } ClientHello;),
      BREAK#6965,
    CONTENT#6966(    struct {),
    CONTENT#6967(        ProtocolVersion legacy_version = 0x0303;    /* TLS v1.2 */),
    CONTENT#6968(        Random random;),
    CONTENT#6969(        opaque legacy_session_id_echo<0..32>;),
    CONTENT#6970(        CipherSuite cipher_suite;),
    CONTENT#6971(        uint8 legacy_compression_method = 0;),
    CONTENT#6972(        Extension extensions<6..2^16-1>;),
    CONTENT#6973(    } ServerHello;),
      BREAK#6974,
      BREAK#6975,
      BREAK#6976,
      BREAK#6977,
      BREAK#6978,
      BREAK#6979,
      BREAK#6980,
      BREAK#6981,
      BREAK#6982,
      BREAK#6983,
      BREAK#6984,
      BREAK#6985,
      BREAK#6986,
      BREAK#6987,
      BREAK#6988,
      BREAK#6989,
      BREAK#6990,
      BREAK#6991,
      BREAK#6992,
      BREAK#6993,
      BREAK#6994,
      BREAK#6995,
      BREAK#6996,
      BREAK#6997,
      BREAK#6998,
      BREAK#6999,
      BREAK#7000,
      BREAK#7002,
      BREAK#7004,
      BREAK#7005,
    CONTENT#7006(    struct {),
    CONTENT#7007(        ExtensionType extension_type;),
    CONTENT#7008(        opaque extension_data<0..2^16-1>;),
    CONTENT#7009(    } Extension;),
      BREAK#7010,
    CONTENT#7011(    enum {),
    CONTENT#7012(        server_name(0),                             /* RFC 6066 */),
    CONTENT#7013(        max_fragment_length(1),                     /* RFC 6066 */),
    CONTENT#7014(        status_request(5),                          /* RFC 6066 */),
    CONTENT#7015(        supported_groups(10),                       /* RFC 8422, 7919 */),
    CONTENT#7016(        signature_algorithms(13),                   /* RFC 8446 */),
    CONTENT#7017(        use_srtp(14),                               /* RFC 5764 */),
    CONTENT#7018(        heartbeat(15),                              /* RFC 6520 */),
    CONTENT#7019(        application_layer_protocol_negotiation(16), /* RFC 7301 */),
    CONTENT#7020(        signed_certificate_timestamp(18),           /* RFC 6962 */),
    CONTENT#7021(        client_certificate_type(19),                /* RFC 7250 */),
    CONTENT#7022(        server_certificate_type(20),                /* RFC 7250 */),
    CONTENT#7023(        padding(21),                                /* RFC 7685 */),
    CONTENT#7024(        RESERVED(40),                               /* Used but never),
    CONTENT#7025(                                                       assigned */),
    CONTENT#7026(        pre_shared_key(41),                         /* RFC 8446 */),
    CONTENT#7027(        early_data(42),                             /* RFC 8446 */),
    CONTENT#7028(        supported_versions(43),                     /* RFC 8446 */),
    CONTENT#7029(        cookie(44),                                 /* RFC 8446 */),
    CONTENT#7030(        psk_key_exchange_modes(45),                 /* RFC 8446 */),
    CONTENT#7031(        RESERVED(46),                               /* Used but never),
    CONTENT#7032(                                                       assigned */),
    CONTENT#7033(        certificate_authorities(47),                /* RFC 8446 */),
    CONTENT#7034(        oid_filters(48),                            /* RFC 8446 */),
    CONTENT#7035(        post_handshake_auth(49),                    /* RFC 8446 */),
    CONTENT#7036(        signature_algorithms_cert(50),              /* RFC 8446 */),
    CONTENT#7037(        key_share(51),                              /* RFC 8446 */),
    CONTENT#7038(        (65535)),
    CONTENT#7039(    } ExtensionType;),
      BREAK#7040,
    CONTENT#7041(    struct {),
    CONTENT#7042(        NamedGroup group;),
    CONTENT#7043(        opaque key_exchange<1..2^16-1>;),
    CONTENT#7044(    } KeyShareEntry;),
      BREAK#7045,
    CONTENT#7046(    struct {),
    CONTENT#7047(        KeyShareEntry client_shares<0..2^16-1>;),
    CONTENT#7048(    } KeyShareClientHello;),
      BREAK#7049,
    CONTENT#7050(    struct {),
    CONTENT#7051(        NamedGroup selected_group;),
    CONTENT#7052(    } KeyShareHelloRetryRequest;),
      BREAK#7053,
      BREAK#7054,
      BREAK#7055,
      BREAK#7056,
      BREAK#7058,
      BREAK#7060,
      BREAK#7061,
    CONTENT#7062(    struct {),
    CONTENT#7063(        KeyShareEntry server_share;),
    CONTENT#7064(    } KeyShareServerHello;),
      BREAK#7065,
    CONTENT#7066(    struct {),
    CONTENT#7067(        uint8 legacy_form = 4;),
    CONTENT#7068(        opaque X[coordinate_length];),
    CONTENT#7069(        opaque Y[coordinate_length];),
    CONTENT#7070(    } UncompressedPointRepresentation;),
      BREAK#7071,
    CONTENT#7072(    enum { psk_ke(0), psk_dhe_ke(1), (255) } PskKeyExchangeMode;),
      BREAK#7073,
    CONTENT#7074(    struct {),
    CONTENT#7075(        PskKeyExchangeMode ke_modes<1..255>;),
    CONTENT#7076(    } PskKeyExchangeModes;),
      BREAK#7077,
    CONTENT#7078(    struct {} Empty;),
      BREAK#7079,
    CONTENT#7080(    struct {),
    CONTENT#7081(        select (Handshake.msg_type) {),
    CONTENT#7082(            case new_session_ticket:   uint32 max_early_data_size;),
    CONTENT#7083(            case client_hello:         Empty;),
    CONTENT#7084(            case encrypted_extensions: Empty;),
    CONTENT#7085(        };),
    CONTENT#7086(    } EarlyDataIndication;),
      BREAK#7087,
    CONTENT#7088(    struct {),
    CONTENT#7089(        opaque identity<1..2^16-1>;),
    CONTENT#7090(        uint32 obfuscated_ticket_age;),
    CONTENT#7091(    } PskIdentity;),
      BREAK#7092,
    CONTENT#7093(    opaque PskBinderEntry<32..255>;),
      BREAK#7094,
    CONTENT#7095(    struct {),
    CONTENT#7096(        PskIdentity identities<7..2^16-1>;),
    CONTENT#7097(        PskBinderEntry binders<33..2^16-1>;),
    CONTENT#7098(    } OfferedPsks;),
      BREAK#7099,
    CONTENT#7100(    struct {),
    CONTENT#7101(        select (Handshake.msg_type) {),
    CONTENT#7102(            case client_hello: OfferedPsks;),
    CONTENT#7103(            case server_hello: uint16 selected_identity;),
    CONTENT#7104(        };),
    CONTENT#7105(    } PreSharedKeyExtension;),
      BREAK#7106,
      BREAK#7107,
      BREAK#7108,
      BREAK#7109,
      BREAK#7110,
      BREAK#7111,
      BREAK#7112,
      BREAK#7114,
      BREAK#7116,
      BREAK#7117,
    SECTION#7118(id=B.3.1.1, title=Version Extension),
      BREAK#7119,
    CONTENT#7120(      struct {),
    CONTENT#7121(          select (Handshake.msg_type) {),
    CONTENT#7122(              case client_hello:),
    CONTENT#7123(                   ProtocolVersion versions<2..254>;),
      BREAK#7124,
    CONTENT#7125(              case server_hello: /* and HelloRetryRequest */),
    CONTENT#7126(                   ProtocolVersion selected_version;),
    CONTENT#7127(          };),
    CONTENT#7128(      } SupportedVersions;),
      BREAK#7129,
    SECTION#7130(id=B.3.1.2, title=Cookie Extension),
      BREAK#7131,
    CONTENT#7132(      struct {),
    CONTENT#7133(          opaque cookie<1..2^16-1>;),
    CONTENT#7134(      } Cookie;),
      BREAK#7135,
      BREAK#7136,
      BREAK#7137,
      BREAK#7138,
      BREAK#7139,
      BREAK#7140,
      BREAK#7141,
      BREAK#7142,
      BREAK#7143,
      BREAK#7144,
      BREAK#7145,
      BREAK#7146,
      BREAK#7147,
      BREAK#7148,
      BREAK#7149,
      BREAK#7150,
      BREAK#7151,
      BREAK#7152,
      BREAK#7153,
      BREAK#7154,
      BREAK#7155,
      BREAK#7156,
      BREAK#7157,
      BREAK#7158,
      BREAK#7159,
      BREAK#7160,
      BREAK#7161,
      BREAK#7162,
      BREAK#7163,
      BREAK#7164,
      BREAK#7165,
      BREAK#7166,
      BREAK#7167,
      BREAK#7168,
      BREAK#7170,
      BREAK#7172,
      BREAK#7173,
    SECTION#7174(id=B.3.1.3, title=Signature Algorithm Extension),
      BREAK#7175,
    CONTENT#7176(      enum {),
    CONTENT#7177(          /* RSASSA-PKCS1-v1_5 algorithms */),
    CONTENT#7178(          rsa_pkcs1_sha256(0x0401),),
    CONTENT#7179(          rsa_pkcs1_sha384(0x0501),),
    CONTENT#7180(          rsa_pkcs1_sha512(0x0601),),
      BREAK#7181,
    CONTENT#7182(          /* ECDSA algorithms */),
    CONTENT#7183(          ecdsa_secp256r1_sha256(0x0403),),
    CONTENT#7184(          ecdsa_secp384r1_sha384(0x0503),),
    CONTENT#7185(          ecdsa_secp521r1_sha512(0x0603),),
      BREAK#7186,
    CONTENT#7187(          /* RSASSA-PSS algorithms with public key OID rsaEncryption */),
    CONTENT#7188(          rsa_pss_rsae_sha256(0x0804),),
    CONTENT#7189(          rsa_pss_rsae_sha384(0x0805),),
    CONTENT#7190(          rsa_pss_rsae_sha512(0x0806),),
      BREAK#7191,
    CONTENT#7192(          /* EdDSA algorithms */),
    CONTENT#7193(          ed25519(0x0807),),
    CONTENT#7194(          ed448(0x0808),),
      BREAK#7195,
    CONTENT#7196(          /* RSASSA-PSS algorithms with public key OID RSASSA-PSS */),
    CONTENT#7197(          rsa_pss_pss_sha256(0x0809),),
    CONTENT#7198(          rsa_pss_pss_sha384(0x080a),),
    CONTENT#7199(          rsa_pss_pss_sha512(0x080b),),
      BREAK#7200,
    CONTENT#7201(          /* Legacy algorithms */),
    CONTENT#7202(          rsa_pkcs1_sha1(0x0201),),
    CONTENT#7203(          ecdsa_sha1(0x0203),),
      BREAK#7204,
    CONTENT#7205(          /* Reserved Code Points */),
    CONTENT#7206(          obsolete_RESERVED(0x0000..0x0200),),
    CONTENT#7207(          dsa_sha1_RESERVED(0x0202),),
    CONTENT#7208(          obsolete_RESERVED(0x0204..0x0400),),
    CONTENT#7209(          dsa_sha256_RESERVED(0x0402),),
    CONTENT#7210(          obsolete_RESERVED(0x0404..0x0500),),
    CONTENT#7211(          dsa_sha384_RESERVED(0x0502),),
    CONTENT#7212(          obsolete_RESERVED(0x0504..0x0600),),
    CONTENT#7213(          dsa_sha512_RESERVED(0x0602),),
    CONTENT#7214(          obsolete_RESERVED(0x0604..0x06FF),),
    CONTENT#7215(          private_use(0xFE00..0xFFFF),),
    CONTENT#7216(          (0xFFFF)),
    CONTENT#7217(      } SignatureScheme;),
      BREAK#7218,
    CONTENT#7219(      struct {),
    CONTENT#7220(          SignatureScheme supported_signature_algorithms<2..2^16-2>;),
    CONTENT#7221(      } SignatureSchemeList;),
      BREAK#7222,
      BREAK#7223,
      BREAK#7224,
      BREAK#7226,
      BREAK#7228,
      BREAK#7229,
    SECTION#7230(id=B.3.1.4, title=Supported Groups Extension),
      BREAK#7231,
    CONTENT#7232(      enum {),
    CONTENT#7233(          unallocated_RESERVED(0x0000),),
      BREAK#7234,
    CONTENT#7235(          /* Elliptic Curve Groups (ECDHE) */),
    CONTENT#7236(          obsolete_RESERVED(0x0001..0x0016),),
    CONTENT#7237(          secp256r1(0x0017), secp384r1(0x0018), secp521r1(0x0019),),
    CONTENT#7238(          obsolete_RESERVED(0x001A..0x001C),),
    CONTENT#7239(          x25519(0x001D), x448(0x001E),),
      BREAK#7240,
    CONTENT#7241(          /* Finite Field Groups (DHE) */),
    CONTENT#7242(          ffdhe2048(0x0100), ffdhe3072(0x0101), ffdhe4096(0x0102),),
    CONTENT#7243(          ffdhe6144(0x0103), ffdhe8192(0x0104),),
      BREAK#7244,
    CONTENT#7245(          /* Reserved Code Points */),
    CONTENT#7246(          ffdhe_private_use(0x01FC..0x01FF),),
    CONTENT#7247(          ecdhe_private_use(0xFE00..0xFEFF),),
    CONTENT#7248(          obsolete_RESERVED(0xFF01..0xFF02),),
    CONTENT#7249(          (0xFFFF)),
    CONTENT#7250(      } NamedGroup;),
      BREAK#7251,
    CONTENT#7252(      struct {),
    CONTENT#7253(          NamedGroup named_group_list<2..2^16-1>;),
    CONTENT#7254(      } NamedGroupList;),
      BREAK#7255,
    CONTENT#7256(   Values within "obsolete_RESERVED" ranges are used in previous),
    CONTENT#7257(   versions of TLS and MUST NOT be offered or negotiated by TLS 1.3),
    CONTENT#7258(   implementations.  The obsolete curves have various known/theoretical),
    CONTENT#7259(   weaknesses or have had very little usage, in some cases only due to),
    CONTENT#7260(   unintentional server configuration issues.  They are no longer),
    CONTENT#7261(   considered appropriate for general use and should be assumed to be),
    CONTENT#7262(   potentially unsafe.  The set of curves specified here is sufficient),
    CONTENT#7263(   for interoperability with all currently deployed and properly),
    CONTENT#7264(   configured TLS implementations.),
      BREAK#7265,
      BREAK#7266,
      BREAK#7267,
      BREAK#7268,
      BREAK#7269,
      BREAK#7270,
      BREAK#7271,
      BREAK#7272,
      BREAK#7273,
      BREAK#7274,
      BREAK#7275,
      BREAK#7276,
      BREAK#7277,
      BREAK#7278,
      BREAK#7279,
      BREAK#7280,
      BREAK#7282,
      BREAK#7284,
      BREAK#7285,
    SECTION#7286(id=B.3.2, title=Server Parameters Messages),
      BREAK#7287,
    CONTENT#7288(      opaque DistinguishedName<1..2^16-1>;),
      BREAK#7289,
    CONTENT#7290(      struct {),
    CONTENT#7291(          DistinguishedName authorities<3..2^16-1>;),
    CONTENT#7292(      } CertificateAuthoritiesExtension;),
      BREAK#7293,
    CONTENT#7294(      struct {),
    CONTENT#7295(          opaque certificate_extension_oid<1..2^8-1>;),
    CONTENT#7296(          opaque certificate_extension_values<0..2^16-1>;),
    CONTENT#7297(      } OIDFilter;),
      BREAK#7298,
    CONTENT#7299(      struct {),
    CONTENT#7300(          OIDFilter filters<0..2^16-1>;),
    CONTENT#7301(      } OIDFilterExtension;),
      BREAK#7302,
    CONTENT#7303(      struct {} PostHandshakeAuth;),
      BREAK#7304,
    CONTENT#7305(      struct {),
    CONTENT#7306(          Extension extensions<0..2^16-1>;),
    CONTENT#7307(      } EncryptedExtensions;),
      BREAK#7308,
    CONTENT#7309(      struct {),
    CONTENT#7310(          opaque certificate_request_context<0..2^8-1>;),
    CONTENT#7311(          Extension extensions<2..2^16-1>;),
    CONTENT#7312(      } CertificateRequest;),
      BREAK#7313,
      BREAK#7314,
      BREAK#7315,
      BREAK#7316,
      BREAK#7317,
      BREAK#7318,
      BREAK#7319,
      BREAK#7320,
      BREAK#7321,
      BREAK#7322,
      BREAK#7323,
      BREAK#7324,
      BREAK#7325,
      BREAK#7326,
      BREAK#7327,
      BREAK#7328,
      BREAK#7329,
      BREAK#7330,
      BREAK#7331,
      BREAK#7332,
      BREAK#7333,
      BREAK#7334,
      BREAK#7335,
      BREAK#7336,
      BREAK#7338,
      BREAK#7340,
      BREAK#7341,
    SECTION#7342(id=B.3.3, title=Authentication Messages),
      BREAK#7343,
    CONTENT#7344(      enum {),
    CONTENT#7345(          X509(0),),
    CONTENT#7346(          OpenPGP_RESERVED(1),),
    CONTENT#7347(          RawPublicKey(2),),
    CONTENT#7348(          (255)),
    CONTENT#7349(      } CertificateType;),
      BREAK#7350,
    CONTENT#7351(      struct {),
    CONTENT#7352(          select (certificate_type) {),
    CONTENT#7353(              case RawPublicKey:),
    CONTENT#7354(                /* From RFC 7250 ASN.1_subjectPublicKeyInfo */),
    CONTENT#7355(                opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;),
      BREAK#7356,
    CONTENT#7357(              case X509:),
    CONTENT#7358(                opaque cert_data<1..2^24-1>;),
    CONTENT#7359(          };),
    CONTENT#7360(          Extension extensions<0..2^16-1>;),
    CONTENT#7361(      } CertificateEntry;),
      BREAK#7362,
    CONTENT#7363(      struct {),
    CONTENT#7364(          opaque certificate_request_context<0..2^8-1>;),
    CONTENT#7365(          CertificateEntry certificate_list<0..2^24-1>;),
    CONTENT#7366(      } Certificate;),
      BREAK#7367,
    CONTENT#7368(      struct {),
    CONTENT#7369(          SignatureScheme algorithm;),
    CONTENT#7370(          opaque signature<0..2^16-1>;),
    CONTENT#7371(      } CertificateVerify;),
      BREAK#7372,
    CONTENT#7373(      struct {),
    CONTENT#7374(          opaque verify_data[Hash.length];),
    CONTENT#7375(      } Finished;),
      BREAK#7376,
    SECTION#7377(id=B.3.4, title=Ticket Establishment),
      BREAK#7378,
    CONTENT#7379(      struct {),
    CONTENT#7380(          uint32 ticket_lifetime;),
    CONTENT#7381(          uint32 ticket_age_add;),
    CONTENT#7382(          opaque ticket_nonce<0..255>;),
    CONTENT#7383(          opaque ticket<1..2^16-1>;),
    CONTENT#7384(          Extension extensions<0..2^16-2>;),
    CONTENT#7385(      } NewSessionTicket;),
      BREAK#7386,
      BREAK#7387,
      BREAK#7388,
      BREAK#7389,
      BREAK#7390,
      BREAK#7391,
      BREAK#7392,
      BREAK#7394,
      BREAK#7396,
      BREAK#7397,
    SECTION#7398(id=B.3.5, title=Updating Keys),
      BREAK#7399,
    CONTENT#7400(      struct {} EndOfEarlyData;),
      BREAK#7401,
    CONTENT#7402(      enum {),
    CONTENT#7403(          update_not_requested(0), update_requested(1), (255)),
    CONTENT#7404(      } KeyUpdateRequest;),
      BREAK#7405,
    CONTENT#7406(      struct {),
    CONTENT#7407(          KeyUpdateRequest request_update;),
    CONTENT#7408(      } KeyUpdate;),
      BREAK#7409,
    SECTION#7410(id=B.4, title=Cipher Suites),
      BREAK#7411,
    CONTENT#7412(   A symmetric cipher suite defines the pair of the AEAD algorithm and),
    CONTENT#7413(   hash algorithm to be used with HKDF.  Cipher suite names follow the),
    CONTENT#7414(   naming convention:),
      BREAK#7415,
    CONTENT#7416(      CipherSuite TLS_AEAD_HASH = VALUE;),
      BREAK#7417,
    CONTENT#7418(      +-----------+------------------------------------------------+),
    CONTENT#7419(      | Component | Contents                                       |),
    CONTENT#7420(      +-----------+------------------------------------------------+),
    CONTENT#7421(      | TLS       | The string "TLS"                               |),
    CONTENT#7422(      |           |                                                |),
    CONTENT#7423(      | AEAD      | The AEAD algorithm used for record protection  |),
    CONTENT#7424(      |           |                                                |),
    CONTENT#7425(      | HASH      | The hash algorithm used with HKDF              |),
    CONTENT#7426(      |           |                                                |),
    CONTENT#7427(      | VALUE     | The two-byte ID assigned for this cipher suite |),
    CONTENT#7428(      +-----------+------------------------------------------------+),
      BREAK#7429,
    CONTENT#7430(   This specification defines the following cipher suites for use with),
    CONTENT#7431(   TLS 1.3.),
      BREAK#7432,
    CONTENT#7433(              +------------------------------+-------------+),
    CONTENT#7434(              | Description                  | Value       |),
    CONTENT#7435(              +------------------------------+-------------+),
    CONTENT#7436(              | TLS_AES_128_GCM_SHA256       | {0x13,0x01} |),
    CONTENT#7437(              |                              |             |),
    CONTENT#7438(              | TLS_AES_256_GCM_SHA384       | {0x13,0x02} |),
    CONTENT#7439(              |                              |             |),
    CONTENT#7440(              | TLS_CHACHA20_POLY1305_SHA256 | {0x13,0x03} |),
    CONTENT#7441(              |                              |             |),
    CONTENT#7442(              | TLS_AES_128_CCM_SHA256       | {0x13,0x04} |),
    CONTENT#7443(              |                              |             |),
    CONTENT#7444(              | TLS_AES_128_CCM_8_SHA256     | {0x13,0x05} |),
    CONTENT#7445(              +------------------------------+-------------+),
      BREAK#7446,
      BREAK#7447,
      BREAK#7448,
      BREAK#7450,
      BREAK#7452,
      BREAK#7453,
    CONTENT#7454(   The corresponding AEAD algorithms AEAD_AES_128_GCM, AEAD_AES_256_GCM,),
    CONTENT#7455(   and AEAD_AES_128_CCM are defined in [RFC5116].),
    CONTENT#7456(   AEAD_CHACHA20_POLY1305 is defined in [RFC8439].  AEAD_AES_128_CCM_8),
    CONTENT#7457(   is defined in [RFC6655].  The corresponding hash algorithms are),
    CONTENT#7458(   defined in [SHS].),
      BREAK#7459,
    CONTENT#7460(   Although TLS 1.3 uses the same cipher suite space as previous),
    CONTENT#7461(   versions of TLS, TLS 1.3 cipher suites are defined differently, only),
    CONTENT#7462(   specifying the symmetric ciphers, and cannot be used for TLS 1.2.),
    CONTENT#7463(   Similarly, cipher suites for TLS 1.2 and lower cannot be used with),
    CONTENT#7464(   TLS 1.3.),
      BREAK#7465,
    CONTENT#7466(   New cipher suite values are assigned by IANA as described in),
    CONTENT#7467(   Section 11.),
      BREAK#7468,
    SECTION#7469(id=C, title=Implementation Notes),
      BREAK#7470,
    CONTENT#7471(   The TLS protocol cannot prevent many common security mistakes.  This),
    CONTENT#7472(   appendix provides several recommendations to assist implementors.),
    CONTENT#7473(   [TLS13-TRACES] provides test vectors for TLS 1.3 handshakes.),
      BREAK#7474,
    SECTION#7475(id=C.1, title=Random Number Generation and Seeding),
      BREAK#7476,
    CONTENT#7477(   TLS requires a cryptographically secure pseudorandom number generator),
    CONTENT#7478(   (CSPRNG).  In most cases, the operating system provides an),
    CONTENT#7479(   appropriate facility such as /dev/urandom, which should be used),
    CONTENT#7480(   absent other (e.g., performance) concerns.  It is RECOMMENDED to use),
    CONTENT#7481(   an existing CSPRNG implementation in preference to crafting a new),
    CONTENT#7482(   one.  Many adequate cryptographic libraries are already available),
    CONTENT#7483(   under favorable license terms.  Should those prove unsatisfactory,),
    CONTENT#7484(   [RFC4086] provides guidance on the generation of random values.),
      BREAK#7485,
    CONTENT#7486(   TLS uses random values (1) in public protocol fields such as the),
    CONTENT#7487(   public Random values in the ClientHello and ServerHello and (2) to),
    CONTENT#7488(   generate keying material.  With a properly functioning CSPRNG, this),
    CONTENT#7489(   does not present a security problem, as it is not feasible to),
    CONTENT#7490(   determine the CSPRNG state from its output.  However, with a broken),
    CONTENT#7491(   CSPRNG, it may be possible for an attacker to use the public output),
    CONTENT#7492(   to determine the CSPRNG internal state and thereby predict the keying),
    CONTENT#7493(   material, as documented in [CHECKOWAY].  Implementations can provide),
    CONTENT#7494(   extra security against this form of attack by using separate CSPRNGs),
    CONTENT#7495(   to generate public and private values.),
      BREAK#7496,
      BREAK#7497,
      BREAK#7498,
      BREAK#7499,
      BREAK#7500,
      BREAK#7501,
      BREAK#7502,
      BREAK#7503,
      BREAK#7504,
      BREAK#7506,
      BREAK#7508,
      BREAK#7509,
    SECTION#7510(id=C.2, title=Certificates and Authentication),
      BREAK#7511,
    CONTENT#7512(   Implementations are responsible for verifying the integrity of),
    CONTENT#7513(   certificates and should generally support certificate revocation),
    CONTENT#7514(   messages.  Absent a specific indication from an application profile,),
    CONTENT#7515(   certificates should always be verified to ensure proper signing by a),
    CONTENT#7516(   trusted certificate authority (CA).  The selection and addition of),
    CONTENT#7517(   trust anchors should be done very carefully.  Users should be able to),
    CONTENT#7518(   view information about the certificate and trust anchor.),
    CONTENT#7519(   Applications SHOULD also enforce minimum and maximum key sizes.  For),
    CONTENT#7520(   example, certification paths containing keys or signatures weaker),
    CONTENT#7521(   than 2048-bit RSA or 224-bit ECDSA are not appropriate for secure),
    CONTENT#7522(   applications.),
      BREAK#7523,
    SECTION#7524(id=C.3, title=Implementation Pitfalls),
      BREAK#7525,
    CONTENT#7526(   Implementation experience has shown that certain parts of earlier TLS),
    CONTENT#7527(   specifications are not easy to understand and have been a source of),
    CONTENT#7528(   interoperability and security problems.  Many of these areas have),
    CONTENT#7529(   been clarified in this document, but this appendix contains a short),
    CONTENT#7530(   list of the most important things that require special attention from),
    CONTENT#7531(   implementors.),
      BREAK#7532,
    CONTENT#7533(   TLS protocol issues:),
      BREAK#7534,
    CONTENT#7535(   -  Do you correctly handle handshake messages that are fragmented to),
    CONTENT#7536(      multiple TLS records (see Section 5.1)?  Do you correctly handle),
    CONTENT#7537(      corner cases like a ClientHello that is split into several small),
    CONTENT#7538(      fragments?  Do you fragment handshake messages that exceed the),
    CONTENT#7539(      maximum fragment size?  In particular, the Certificate and),
    CONTENT#7540(      CertificateRequest handshake messages can be large enough to),
    CONTENT#7541(      require fragmentation.),
      BREAK#7542,
    CONTENT#7543(   -  Do you ignore the TLS record layer version number in all),
    CONTENT#7544(      unencrypted TLS records (see Appendix D)?),
      BREAK#7545,
    CONTENT#7546(   -  Have you ensured that all support for SSL, RC4, EXPORT ciphers,),
    CONTENT#7547(      and MD5 (via the "signature_algorithms" extension) is completely),
    CONTENT#7548(      removed from all possible configurations that support TLS 1.3 or),
    CONTENT#7549(      later, and that attempts to use these obsolete capabilities fail),
    CONTENT#7550(      correctly (see Appendix D)?),
      BREAK#7551,
    CONTENT#7552(   -  Do you handle TLS extensions in ClientHellos correctly, including),
    CONTENT#7553(      unknown extensions?),
      BREAK#7554,
      BREAK#7555,
      BREAK#7556,
      BREAK#7557,
      BREAK#7558,
      BREAK#7559,
      BREAK#7560,
      BREAK#7562,
      BREAK#7564,
      BREAK#7565,
    CONTENT#7566(   -  When the server has requested a client certificate but no suitable),
    CONTENT#7567(      certificate is available, do you correctly send an empty),
    CONTENT#7568(      Certificate message, instead of omitting the whole message (see),
    CONTENT#7569(      Section 4.4.2)?),
      BREAK#7570,
    CONTENT#7571(   -  When processing the plaintext fragment produced by AEAD-Decrypt),
    CONTENT#7572(      and scanning from the end for the ContentType, do you avoid),
    CONTENT#7573(      scanning past the start of the cleartext in the event that the),
    CONTENT#7574(      peer has sent a malformed plaintext of all zeros?),
      BREAK#7575,
    CONTENT#7576(   -  Do you properly ignore unrecognized cipher suites (Section 4.1.2),),
    CONTENT#7577(      hello extensions (Section 4.2), named groups (Section 4.2.7), key),
    CONTENT#7578(      shares (Section 4.2.8), supported versions (Section 4.2.1), and),
    CONTENT#7579(      signature algorithms (Section 4.2.3) in the ClientHello?),
      BREAK#7580,
    CONTENT#7581(   -  As a server, do you send a HelloRetryRequest to clients which),
    CONTENT#7582(      support a compatible (EC)DHE group but do not predict it in the),
    CONTENT#7583(      "key_share" extension?  As a client, do you correctly handle a),
    CONTENT#7584(      HelloRetryRequest from the server?),
      BREAK#7585,
    CONTENT#7586(   Cryptographic details:),
      BREAK#7587,
    CONTENT#7588(   -  What countermeasures do you use to prevent timing attacks),
    CONTENT#7589(      [TIMING]?),
      BREAK#7590,
    CONTENT#7591(   -  When using Diffie-Hellman key exchange, do you correctly preserve),
    CONTENT#7592(      leading zero bytes in the negotiated key (see Section 7.4.1)?),
      BREAK#7593,
    CONTENT#7594(   -  Does your TLS client check that the Diffie-Hellman parameters sent),
    CONTENT#7595(      by the server are acceptable (see Section 4.2.8.1)?),
      BREAK#7596,
    CONTENT#7597(   -  Do you use a strong and, most importantly, properly seeded random),
    CONTENT#7598(      number generator (see Appendix C.1) when generating Diffie-Hellman),
    CONTENT#7599(      private values, the ECDSA "k" parameter, and other security-),
    CONTENT#7600(      critical values?  It is RECOMMENDED that implementations implement),
    CONTENT#7601(      "deterministic ECDSA" as specified in [RFC6979].),
      BREAK#7602,
    CONTENT#7603(   -  Do you zero-pad Diffie-Hellman public key values and shared),
    CONTENT#7604(      secrets to the group size (see Section 4.2.8.1 and Section 7.4.1)?),
      BREAK#7605,
    CONTENT#7606(   -  Do you verify signatures after making them, to protect against),
    CONTENT#7607(      RSA-CRT key leaks [FW15]?),
      BREAK#7608,
      BREAK#7609,
      BREAK#7610,
      BREAK#7611,
      BREAK#7612,
      BREAK#7613,
      BREAK#7614,
      BREAK#7615,
      BREAK#7616,
      BREAK#7618,
      BREAK#7620,
      BREAK#7621,
    SECTION#7622(id=C.4, title=Client Tracking Prevention),
      BREAK#7623,
    CONTENT#7624(   Clients SHOULD NOT reuse a ticket for multiple connections.  Reuse of),
    CONTENT#7625(   a ticket allows passive observers to correlate different connections.),
    CONTENT#7626(   Servers that issue tickets SHOULD offer at least as many tickets as),
    CONTENT#7627(   the number of connections that a client might use; for example, a web),
    CONTENT#7628(   browser using HTTP/1.1 [RFC7230] might open six connections to a),
    CONTENT#7629(   server.  Servers SHOULD issue new tickets with every connection.),
    CONTENT#7630(   This ensures that clients are always able to use a new ticket when),
    CONTENT#7631(   creating a new connection.),
      BREAK#7632,
    SECTION#7633(id=C.5, title=Unauthenticated Operation),
      BREAK#7634,
    CONTENT#7635(   Previous versions of TLS offered explicitly unauthenticated cipher),
    CONTENT#7636(   suites based on anonymous Diffie-Hellman.  These modes have been),
    CONTENT#7637(   deprecated in TLS 1.3.  However, it is still possible to negotiate),
    CONTENT#7638(   parameters that do not provide verifiable server authentication by),
    CONTENT#7639(   several methods, including:),
      BREAK#7640,
    CONTENT#7641(   -  Raw public keys [RFC7250].),
      BREAK#7642,
    CONTENT#7643(   -  Using a public key contained in a certificate but without),
    CONTENT#7644(      validation of the certificate chain or any of its contents.),
      BREAK#7645,
    CONTENT#7646(   Either technique used alone is vulnerable to man-in-the-middle),
    CONTENT#7647(   attacks and therefore unsafe for general use.  However, it is also),
    CONTENT#7648(   possible to bind such connections to an external authentication),
    CONTENT#7649(   mechanism via out-of-band validation of the server's public key,),
    CONTENT#7650(   trust on first use, or a mechanism such as channel bindings (though),
    CONTENT#7651(   the channel bindings described in [RFC5929] are not defined for),
    CONTENT#7652(   TLS 1.3).  If no such mechanism is used, then the connection has no),
    CONTENT#7653(   protection against active man-in-the-middle attack; applications),
    CONTENT#7654(   MUST NOT use TLS in such a way absent explicit configuration or a),
    CONTENT#7655(   specific application profile.),
      BREAK#7656,
      BREAK#7657,
      BREAK#7658,
      BREAK#7659,
      BREAK#7660,
      BREAK#7661,
      BREAK#7662,
      BREAK#7663,
      BREAK#7664,
      BREAK#7665,
      BREAK#7666,
      BREAK#7667,
      BREAK#7668,
      BREAK#7669,
      BREAK#7670,
      BREAK#7671,
      BREAK#7672,
      BREAK#7674,
      BREAK#7676,
      BREAK#7677,
    SECTION#7678(id=D, title=Backward Compatibility),
      BREAK#7679,
    CONTENT#7680(   The TLS protocol provides a built-in mechanism for version),
    CONTENT#7681(   negotiation between endpoints potentially supporting different),
    CONTENT#7682(   versions of TLS.),
      BREAK#7683,
    CONTENT#7684(   TLS 1.x and SSL 3.0 use compatible ClientHello messages.  Servers can),
    CONTENT#7685(   also handle clients trying to use future versions of TLS as long as),
    CONTENT#7686(   the ClientHello format remains compatible and there is at least one),
    CONTENT#7687(   protocol version supported by both the client and the server.),
      BREAK#7688,
    CONTENT#7689(   Prior versions of TLS used the record layer version number),
    CONTENT#7690(   (TLSPlaintext.legacy_record_version and),
    CONTENT#7691(   TLSCiphertext.legacy_record_version) for various purposes.  As of),
    CONTENT#7692(   TLS 1.3, this field is deprecated.  The value of),
    CONTENT#7693(   TLSPlaintext.legacy_record_version MUST be ignored by all),
    CONTENT#7694(   implementations.  The value of TLSCiphertext.legacy_record_version is),
    CONTENT#7695(   included in the additional data for deprotection but MAY otherwise be),
    CONTENT#7696(   ignored or MAY be validated to match the fixed constant value.),
    CONTENT#7697(   Version negotiation is performed using only the handshake versions),
    CONTENT#7698(   (ClientHello.legacy_version and ServerHello.legacy_version, as well),
    CONTENT#7699(   as the ClientHello, HelloRetryRequest, and ServerHello),
    CONTENT#7700(   "supported_versions" extensions).  In order to maximize),
    CONTENT#7701(   interoperability with older endpoints, implementations that negotiate),
    CONTENT#7702(   the use of TLS 1.0-1.2 SHOULD set the record layer version number to),
    CONTENT#7703(   the negotiated version for the ServerHello and all records),
    CONTENT#7704(   thereafter.),
      BREAK#7705,
    CONTENT#7706(   For maximum compatibility with previously non-standard behavior and),
    CONTENT#7707(   misconfigured deployments, all implementations SHOULD support),
    CONTENT#7708(   validation of certification paths based on the expectations in this),
    CONTENT#7709(   document, even when handling prior TLS versions' handshakes (see),
    CONTENT#7710(   Section 4.4.2.2).),
      BREAK#7711,
    CONTENT#7712(   TLS 1.2 and prior supported an "Extended Master Secret" [RFC7627]),
    CONTENT#7713(   extension which digested large parts of the handshake transcript into),
    CONTENT#7714(   the master secret.  Because TLS 1.3 always hashes in the transcript),
    CONTENT#7715(   up to the server Finished, implementations which support both TLS 1.3),
    CONTENT#7716(   and earlier versions SHOULD indicate the use of the Extended Master),
    CONTENT#7717(   Secret extension in their APIs whenever TLS 1.3 is used.),
      BREAK#7718,
      BREAK#7719,
      BREAK#7720,
      BREAK#7721,
      BREAK#7722,
      BREAK#7723,
      BREAK#7724,
      BREAK#7725,
      BREAK#7726,
      BREAK#7727,
      BREAK#7728,
      BREAK#7730,
      BREAK#7732,
      BREAK#7733,
    SECTION#7734(id=D.1, title=Negotiating with an Older Server),
      BREAK#7735,
    CONTENT#7736(   A TLS 1.3 client who wishes to negotiate with servers that do not),
    CONTENT#7737(   support TLS 1.3 will send a normal TLS 1.3 ClientHello containing),
    CONTENT#7738(   0x0303 (TLS 1.2) in ClientHello.legacy_version but with the correct),
    CONTENT#7739(   version(s) in the "supported_versions" extension.  If the server does),
    CONTENT#7740(   not support TLS 1.3, it will respond with a ServerHello containing an),
    CONTENT#7741(   older version number.  If the client agrees to use this version, the),
    CONTENT#7742(   negotiation will proceed as appropriate for the negotiated protocol.),
    CONTENT#7743(   A client using a ticket for resumption SHOULD initiate the connection),
    CONTENT#7744(   using the version that was previously negotiated.),
      BREAK#7745,
    CONTENT#7746(   Note that 0-RTT data is not compatible with older servers and),
    CONTENT#7747(   SHOULD NOT be sent absent knowledge that the server supports TLS 1.3.),
    CONTENT#7748(   See Appendix D.3.),
      BREAK#7749,
    CONTENT#7750(   If the version chosen by the server is not supported by the client),
    CONTENT#7751(   (or is not acceptable), the client MUST abort the handshake with a),
    CONTENT#7752(   "protocol_version" alert.),
      BREAK#7753,
    CONTENT#7754(   Some legacy server implementations are known to not implement the TLS),
    CONTENT#7755(   specification properly and might abort connections upon encountering),
    CONTENT#7756(   TLS extensions or versions which they are not aware of.),
    CONTENT#7757(   Interoperability with buggy servers is a complex topic beyond the),
    CONTENT#7758(   scope of this document.  Multiple connection attempts may be required),
    CONTENT#7759(   in order to negotiate a backward-compatible connection; however, this),
    CONTENT#7760(   practice is vulnerable to downgrade attacks and is NOT RECOMMENDED.),
      BREAK#7761,
    SECTION#7762(id=D.2, title=Negotiating with an Older Client),
      BREAK#7763,
    CONTENT#7764(   A TLS server can also receive a ClientHello indicating a version),
    CONTENT#7765(   number smaller than its highest supported version.  If the),
    CONTENT#7766(   "supported_versions" extension is present, the server MUST negotiate),
    CONTENT#7767(   using that extension as described in Section 4.2.1.  If the),
    CONTENT#7768(   "supported_versions" extension is not present, the server MUST),
    CONTENT#7769(   negotiate the minimum of ClientHello.legacy_version and TLS 1.2.  For),
    CONTENT#7770(   example, if the server supports TLS 1.0, 1.1, and 1.2, and),
    CONTENT#7771(   legacy_version is TLS 1.0, the server will proceed with a TLS 1.0),
    CONTENT#7772(   ServerHello.  If the "supported_versions" extension is absent and the),
    CONTENT#7773(   server only supports versions greater than),
    CONTENT#7774(   ClientHello.legacy_version, the server MUST abort the handshake with),
    CONTENT#7775(   a "protocol_version" alert.),
      BREAK#7776,
    CONTENT#7777(   Note that earlier versions of TLS did not clearly specify the record),
    CONTENT#7778(   layer version number value in all cases),
    CONTENT#7779(   (TLSPlaintext.legacy_record_version).  Servers will receive various),
    CONTENT#7780(   TLS 1.x versions in this field, but its value MUST always be ignored.),
      BREAK#7781,
      BREAK#7782,
      BREAK#7783,
      BREAK#7784,
      BREAK#7786,
      BREAK#7788,
      BREAK#7789,
    SECTION#7790(id=D.3, title=0-RTT Backward Compatibility),
      BREAK#7791,
    CONTENT#7792(   0-RTT data is not compatible with older servers.  An older server),
    CONTENT#7793(   will respond to the ClientHello with an older ServerHello, but it),
    CONTENT#7794(   will not correctly skip the 0-RTT data and will fail to complete the),
    CONTENT#7795(   handshake.  This can cause issues when a client attempts to use),
    CONTENT#7796(   0-RTT, particularly against multi-server deployments.  For example, a),
    CONTENT#7797(   deployment could deploy TLS 1.3 gradually with some servers),
    CONTENT#7798(   implementing TLS 1.3 and some implementing TLS 1.2, or a TLS 1.3),
    CONTENT#7799(   deployment could be downgraded to TLS 1.2.),
      BREAK#7800,
    CONTENT#7801(   A client that attempts to send 0-RTT data MUST fail a connection if),
    CONTENT#7802(   it receives a ServerHello with TLS 1.2 or older.  It can then retry),
    CONTENT#7803(   the connection with 0-RTT disabled.  To avoid a downgrade attack, the),
    CONTENT#7804(   client SHOULD NOT disable TLS 1.3, only 0-RTT.),
      BREAK#7805,
    CONTENT#7806(   To avoid this error condition, multi-server deployments SHOULD ensure),
    CONTENT#7807(   a uniform and stable deployment of TLS 1.3 without 0-RTT prior to),
    CONTENT#7808(   enabling 0-RTT.),
      BREAK#7809,
    SECTION#7810(id=D.4, title=Middlebox Compatibility Mode),
      BREAK#7811,
    CONTENT#7812(   Field measurements [Ben17a] [Ben17b] [Res17a] [Res17b] have found),
    CONTENT#7813(   that a significant number of middleboxes misbehave when a TLS),
    CONTENT#7814(   client/server pair negotiates TLS 1.3.  Implementations can increase),
    CONTENT#7815(   the chance of making connections through those middleboxes by making),
    CONTENT#7816(   the TLS 1.3 handshake look more like a TLS 1.2 handshake:),
      BREAK#7817,
    CONTENT#7818(   -  The client always provides a non-empty session ID in the),
    CONTENT#7819(      ClientHello, as described in the legacy_session_id section of),
    CONTENT#7820(      Section 4.1.2.),
      BREAK#7821,
    CONTENT#7822(   -  If not offering early data, the client sends a dummy),
    CONTENT#7823(      change_cipher_spec record (see the third paragraph of Section 5)),
    CONTENT#7824(      immediately before its second flight.  This may either be before),
    CONTENT#7825(      its second ClientHello or before its encrypted handshake flight.),
    CONTENT#7826(      If offering early data, the record is placed immediately after the),
    CONTENT#7827(      first ClientHello.),
      BREAK#7828,
    CONTENT#7829(   -  The server sends a dummy change_cipher_spec record immediately),
    CONTENT#7830(      after its first handshake message.  This may either be after a),
    CONTENT#7831(      ServerHello or a HelloRetryRequest.),
      BREAK#7832,
    CONTENT#7833(   When put together, these changes make the TLS 1.3 handshake resemble),
    CONTENT#7834(   TLS 1.2 session resumption, which improves the chance of successfully),
    CONTENT#7835(   connecting through middleboxes.  This "compatibility mode" is),
    CONTENT#7836(   partially negotiated: the client can opt to provide a session ID or),
    CONTENT#7837(   not, and the server has to echo it.  Either side can send),
      BREAK#7838,
      BREAK#7839,
      BREAK#7840,
      BREAK#7842,
      BREAK#7844,
      BREAK#7845,
    CONTENT#7846(   change_cipher_spec at any time during the handshake, as they must be),
    CONTENT#7847(   ignored by the peer, but if the client sends a non-empty session ID,),
    CONTENT#7848(   the server MUST send the change_cipher_spec as described in this),
    CONTENT#7849(   appendix.),
      BREAK#7850,
    SECTION#7851(id=D.5, title=Security Restrictions Related to Backward Compatibility),
      BREAK#7852,
    CONTENT#7853(   Implementations negotiating the use of older versions of TLS SHOULD),
    CONTENT#7854(   prefer forward secret and AEAD cipher suites, when available.),
      BREAK#7855,
    CONTENT#7856(   The security of RC4 cipher suites is considered insufficient for the),
    CONTENT#7857(   reasons cited in [RFC7465].  Implementations MUST NOT offer or),
    CONTENT#7858(   negotiate RC4 cipher suites for any version of TLS for any reason.),
      BREAK#7859,
    CONTENT#7860(   Old versions of TLS permitted the use of very low strength ciphers.),
    CONTENT#7861(   Ciphers with a strength less than 112 bits MUST NOT be offered or),
    CONTENT#7862(   negotiated for any version of TLS for any reason.),
      BREAK#7863,
    CONTENT#7864(   The security of SSL 3.0 [RFC6101] is considered insufficient for the),
    CONTENT#7865(   reasons enumerated in [RFC7568], and it MUST NOT be negotiated for),
    CONTENT#7866(   any reason.),
      BREAK#7867,
    CONTENT#7868(   The security of SSL 2.0 [SSL2] is considered insufficient for the),
    CONTENT#7869(   reasons enumerated in [RFC6176], and it MUST NOT be negotiated for),
    CONTENT#7870(   any reason.),
      BREAK#7871,
    CONTENT#7872(   Implementations MUST NOT send an SSL version 2.0 compatible),
    CONTENT#7873(   CLIENT-HELLO.  Implementations MUST NOT negotiate TLS 1.3 or later),
    CONTENT#7874(   using an SSL version 2.0 compatible CLIENT-HELLO.  Implementations),
    CONTENT#7875(   are NOT RECOMMENDED to accept an SSL version 2.0 compatible),
    CONTENT#7876(   CLIENT-HELLO in order to negotiate older versions of TLS.),
      BREAK#7877,
    CONTENT#7878(   Implementations MUST NOT send a ClientHello.legacy_version or),
    CONTENT#7879(   ServerHello.legacy_version set to 0x0300 or less.  Any endpoint),
    CONTENT#7880(   receiving a Hello message with ClientHello.legacy_version or),
    CONTENT#7881(   ServerHello.legacy_version set to 0x0300 MUST abort the handshake),
    CONTENT#7882(   with a "protocol_version" alert.),
      BREAK#7883,
    CONTENT#7884(   Implementations MUST NOT send any records with a version less than),
    CONTENT#7885(   0x0300.  Implementations SHOULD NOT accept any records with a version),
    CONTENT#7886(   less than 0x0300 (but may inadvertently do so if the record version),
    CONTENT#7887(   number is ignored completely).),
      BREAK#7888,
    CONTENT#7889(   Implementations MUST NOT use the Truncated HMAC extension, defined in),
    CONTENT#7890(   Section 7 of [RFC6066], as it is not applicable to AEAD algorithms),
    CONTENT#7891(   and has been shown to be insecure in some scenarios.),
      BREAK#7892,
      BREAK#7893,
      BREAK#7894,
      BREAK#7895,
      BREAK#7896,
      BREAK#7898,
      BREAK#7900,
      BREAK#7901,
    SECTION#7902(id=E, title=Overview of Security Properties),
      BREAK#7903,
    CONTENT#7904(   A complete security analysis of TLS is outside the scope of this),
    CONTENT#7905(   document.  In this appendix, we provide an informal description of),
    CONTENT#7906(   the desired properties as well as references to more detailed work in),
    CONTENT#7907(   the research literature which provides more formal definitions.),
      BREAK#7908,
    CONTENT#7909(   We cover properties of the handshake separately from those of the),
    CONTENT#7910(   record layer.),
      BREAK#7911,
    SECTION#7912(id=E.1, title=Handshake),
      BREAK#7913,
    CONTENT#7914(   The TLS handshake is an Authenticated Key Exchange (AKE) protocol),
    CONTENT#7915(   which is intended to provide both one-way authenticated (server-only)),
    CONTENT#7916(   and mutually authenticated (client and server) functionality.  At the),
    CONTENT#7917(   completion of the handshake, each side outputs its view of the),
    CONTENT#7918(   following values:),
      BREAK#7919,
    CONTENT#7920(   -  A set of "session keys" (the various secrets derived from the),
    CONTENT#7921(      master secret) from which can be derived a set of working keys.),
      BREAK#7922,
    CONTENT#7923(   -  A set of cryptographic parameters (algorithms, etc.).),
      BREAK#7924,
    CONTENT#7925(   -  The identities of the communicating parties.),
      BREAK#7926,
    CONTENT#7927(   We assume the attacker to be an active network attacker, which means),
    CONTENT#7928(   it has complete control over the network used to communicate between),
    CONTENT#7929(   the parties [RFC3552].  Even under these conditions, the handshake),
    CONTENT#7930(   should provide the properties listed below.  Note that these),
    CONTENT#7931(   properties are not necessarily independent, but reflect the protocol),
    CONTENT#7932(   consumers' needs.),
      BREAK#7933,
    CONTENT#7934(   Establishing the same session keys:  The handshake needs to output),
    CONTENT#7935(      the same set of session keys on both sides of the handshake,),
    CONTENT#7936(      provided that it completes successfully on each endpoint (see),
    CONTENT#7937(      [CK01], Definition 1, part 1).),
      BREAK#7938,
    CONTENT#7939(   Secrecy of the session keys:  The shared session keys should be known),
    CONTENT#7940(      only to the communicating parties and not to the attacker (see),
    CONTENT#7941(      [CK01], Definition 1, part 2).  Note that in a unilaterally),
    CONTENT#7942(      authenticated connection, the attacker can establish its own),
    CONTENT#7943(      session keys with the server, but those session keys are distinct),
    CONTENT#7944(      from those established by the client.),
      BREAK#7945,
    CONTENT#7946(   Peer authentication:  The client's view of the peer identity should),
    CONTENT#7947(      reflect the server's identity.  If the client is authenticated,),
    CONTENT#7948(      the server's view of the peer identity should match the client's),
    CONTENT#7949(      identity.),
      BREAK#7950,
      BREAK#7951,
      BREAK#7952,
      BREAK#7954,
      BREAK#7956,
      BREAK#7957,
    CONTENT#7958(   Uniqueness of the session keys:  Any two distinct handshakes should),
    CONTENT#7959(      produce distinct, unrelated session keys.  Individual session keys),
    CONTENT#7960(      produced by a handshake should also be distinct and independent.),
      BREAK#7961,
    CONTENT#7962(   Downgrade protection:  The cryptographic parameters should be the),
    CONTENT#7963(      same on both sides and should be the same as if the peers had been),
    CONTENT#7964(      communicating in the absence of an attack (see [BBFGKZ16],),
    CONTENT#7965(      Definitions 8 and 9).),
      BREAK#7966,
    CONTENT#7967(   Forward secret with respect to long-term keys:  If the long-term),
    CONTENT#7968(      keying material (in this case the signature keys in certificate-),
    CONTENT#7969(      based authentication modes or the external/resumption PSK in PSK),
    CONTENT#7970(      with (EC)DHE modes) is compromised after the handshake is),
    CONTENT#7971(      complete, this does not compromise the security of the session key),
    CONTENT#7972(      (see [DOW92]), as long as the session key itself has been erased.),
    CONTENT#7973(      The forward secrecy property is not satisfied when PSK is used in),
    CONTENT#7974(      the "psk_ke" PskKeyExchangeMode.),
      BREAK#7975,
    CONTENT#7976(   Key Compromise Impersonation (KCI) resistance:  In a mutually),
    CONTENT#7977(      authenticated connection with certificates, compromising the),
    CONTENT#7978(      long-term secret of one actor should not break that actor's),
    CONTENT#7979(      authentication of their peer in the given connection (see),
    CONTENT#7980(      [HGFS15]).  For example, if a client's signature key is),
    CONTENT#7981(      compromised, it should not be possible to impersonate arbitrary),
    CONTENT#7982(      servers to that client in subsequent handshakes.),
      BREAK#7983,
    CONTENT#7984(   Protection of endpoint identities:  The server's identity),
    CONTENT#7985(      (certificate) should be protected against passive attackers.  The),
    CONTENT#7986(      client's identity should be protected against both passive and),
    CONTENT#7987(      active attackers.),
      BREAK#7988,
    CONTENT#7989(   Informally, the signature-based modes of TLS 1.3 provide for the),
    CONTENT#7990(   establishment of a unique, secret, shared key established by an),
    CONTENT#7991(   (EC)DHE key exchange and authenticated by the server's signature over),
    CONTENT#7992(   the handshake transcript, as well as tied to the server's identity by),
    CONTENT#7993(   a MAC.  If the client is authenticated by a certificate, it also),
    CONTENT#7994(   signs over the handshake transcript and provides a MAC tied to both),
    CONTENT#7995(   identities.  [SIGMA] describes the design and analysis of this type),
    CONTENT#7996(   of key exchange protocol.  If fresh (EC)DHE keys are used for each),
    CONTENT#7997(   connection, then the output keys are forward secret.),
      BREAK#7998,
    CONTENT#7999(   The external PSK and resumption PSK bootstrap from a long-term shared),
    CONTENT#8000(   secret into a unique per-connection set of short-term session keys.),
    CONTENT#8001(   This secret may have been established in a previous handshake.  If),
    CONTENT#8002(   PSK with (EC)DHE key establishment is used, these session keys will),
    CONTENT#8003(   also be forward secret.  The resumption PSK has been designed so that),
    CONTENT#8004(   the resumption master secret computed by connection N and needed to),
    CONTENT#8005(   form connection N+1 is separate from the traffic keys used by),
      BREAK#8006,
      BREAK#8007,
      BREAK#8008,
      BREAK#8010,
      BREAK#8012,
      BREAK#8013,
    CONTENT#8014(   connection N, thus providing forward secrecy between the connections.),
    CONTENT#8015(   In addition, if multiple tickets are established on the same),
    CONTENT#8016(   connection, they are associated with different keys, so compromise of),
    CONTENT#8017(   the PSK associated with one ticket does not lead to the compromise of),
    CONTENT#8018(   connections established with PSKs associated with other tickets.),
    CONTENT#8019(   This property is most interesting if tickets are stored in a database),
    CONTENT#8020(   (and so can be deleted) rather than if they are self-encrypted.),
      BREAK#8021,
    CONTENT#8022(   The PSK binder value forms a binding between a PSK and the current),
    CONTENT#8023(   handshake, as well as between the session where the PSK was),
    CONTENT#8024(   established and the current session.  This binding transitively),
    CONTENT#8025(   includes the original handshake transcript, because that transcript),
    CONTENT#8026(   is digested into the values which produce the resumption master),
    CONTENT#8027(   secret.  This requires that both the KDF used to produce the),
    CONTENT#8028(   resumption master secret and the MAC used to compute the binder be),
    CONTENT#8029(   collision resistant.  See Appendix E.1.1 for more on this.  Note: The),
    CONTENT#8030(   binder does not cover the binder values from other PSKs, though they),
    CONTENT#8031(   are included in the Finished MAC.),
      BREAK#8032,
    CONTENT#8033(   TLS does not currently permit the server to send a),
    CONTENT#8034(   certificate_request message in non-certificate-based handshakes),
    CONTENT#8035(   (e.g., PSK).  If this restriction were to be relaxed in future, the),
    CONTENT#8036(   client's signature would not cover the server's certificate directly.),
    CONTENT#8037(   However, if the PSK was established through a NewSessionTicket, the),
    CONTENT#8038(   client's signature would transitively cover the server's certificate),
    CONTENT#8039(   through the PSK binder.  [PSK-FINISHED] describes a concrete attack),
    CONTENT#8040(   on constructions that do not bind to the server's certificate (see),
    CONTENT#8041(   also [Kraw16]).  It is unsafe to use certificate-based client),
    CONTENT#8042(   authentication when the client might potentially share the same),
    CONTENT#8043(   PSK/key-id pair with two different endpoints.  Implementations),
    CONTENT#8044(   MUST NOT combine external PSKs with certificate-based authentication),
    CONTENT#8045(   of either the client or the server unless negotiated by some),
    CONTENT#8046(   extension.),
      BREAK#8047,
    CONTENT#8048(   If an exporter is used, then it produces values which are unique and),
    CONTENT#8049(   secret (because they are generated from a unique session key).),
    CONTENT#8050(   Exporters computed with different labels and contexts are),
    CONTENT#8051(   computationally independent, so it is not feasible to compute one),
    CONTENT#8052(   from another or the session secret from the exported value.),
    CONTENT#8053(   Note: Exporters can produce arbitrary-length values; if exporters are),
    CONTENT#8054(   to be used as channel bindings, the exported value MUST be large),
    CONTENT#8055(   enough to provide collision resistance.  The exporters provided in),
    CONTENT#8056(   TLS 1.3 are derived from the same Handshake Contexts as the early),
    CONTENT#8057(   traffic keys and the application traffic keys, respectively, and thus),
    CONTENT#8058(   have similar security properties.  Note that they do not include the),
    CONTENT#8059(   client's certificate; future applications which wish to bind to the),
    CONTENT#8060(   client's certificate may need to define a new exporter that includes),
    CONTENT#8061(   the full handshake transcript.),
      BREAK#8062,
      BREAK#8063,
      BREAK#8064,
      BREAK#8066,
      BREAK#8068,
      BREAK#8069,
    CONTENT#8070(   For all handshake modes, the Finished MAC (and, where present, the),
    CONTENT#8071(   signature) prevents downgrade attacks.  In addition, the use of),
    CONTENT#8072(   certain bytes in the random nonces as described in Section 4.1.3),
    CONTENT#8073(   allows the detection of downgrade to previous TLS versions.  See),
    CONTENT#8074(   [BBFGKZ16] for more details on TLS 1.3 and downgrade.),
      BREAK#8075,
    CONTENT#8076(   As soon as the client and the server have exchanged enough),
    CONTENT#8077(   information to establish shared keys, the remainder of the handshake),
    CONTENT#8078(   is encrypted, thus providing protection against passive attackers,),
    CONTENT#8079(   even if the computed shared key is not authenticated.  Because the),
    CONTENT#8080(   server authenticates before the client, the client can ensure that if),
    CONTENT#8081(   it authenticates to the server, it only reveals its identity to an),
    CONTENT#8082(   authenticated server.  Note that implementations must use the),
    CONTENT#8083(   provided record-padding mechanism during the handshake to avoid),
    CONTENT#8084(   leaking information about the identities due to length.  The client's),
    CONTENT#8085(   proposed PSK identities are not encrypted, nor is the one that the),
    CONTENT#8086(   server selects.),
      BREAK#8087,
    SECTION#8088(id=E.1.1, title=Key Derivation and HKDF),
      BREAK#8089,
    CONTENT#8090(   Key derivation in TLS 1.3 uses HKDF as defined in [RFC5869] and its),
    CONTENT#8091(   two components, HKDF-Extract and HKDF-Expand.  The full rationale for),
    CONTENT#8092(   the HKDF construction can be found in [Kraw10] and the rationale for),
    CONTENT#8093(   the way it is used in TLS 1.3 in [KW16].  Throughout this document,),
    CONTENT#8094(   each application of HKDF-Extract is followed by one or more),
    CONTENT#8095(   invocations of HKDF-Expand.  This ordering should always be followed),
    CONTENT#8096(   (including in future revisions of this document); in particular, one),
    CONTENT#8097(   SHOULD NOT use an output of HKDF-Extract as an input to another),
    CONTENT#8098(   application of HKDF-Extract without an HKDF-Expand in between.),
    CONTENT#8099(   Multiple applications of HKDF-Expand to some of the same inputs are),
    CONTENT#8100(   allowed as long as these are differentiated via the key and/or the),
    CONTENT#8101(   labels.),
      BREAK#8102,
    CONTENT#8103(   Note that HKDF-Expand implements a pseudorandom function (PRF) with),
    CONTENT#8104(   both inputs and outputs of variable length.  In some of the uses of),
    CONTENT#8105(   HKDF in this document (e.g., for generating exporters and the),
    CONTENT#8106(   resumption_master_secret), it is necessary that the application of),
    CONTENT#8107(   HKDF-Expand be collision resistant; namely, it should be infeasible),
    CONTENT#8108(   to find two different inputs to HKDF-Expand that output the same),
    CONTENT#8109(   value.  This requires the underlying hash function to be collision),
    CONTENT#8110(   resistant and the output length from HKDF-Expand to be of size at),
    CONTENT#8111(   least 256 bits (or as much as needed for the hash function to prevent),
    CONTENT#8112(   finding collisions).),
      BREAK#8113,
      BREAK#8114,
      BREAK#8115,
      BREAK#8116,
      BREAK#8117,
      BREAK#8118,
      BREAK#8119,
      BREAK#8120,
      BREAK#8122,
      BREAK#8124,
      BREAK#8125,
    SECTION#8126(id=E.1.2, title=Client Authentication),
      BREAK#8127,
    CONTENT#8128(   A client that has sent authentication data to a server, either during),
    CONTENT#8129(   the handshake or in post-handshake authentication, cannot be sure),
    CONTENT#8130(   whether the server afterwards considers the client to be),
    CONTENT#8131(   authenticated or not.  If the client needs to determine if the server),
    CONTENT#8132(   considers the connection to be unilaterally or mutually),
    CONTENT#8133(   authenticated, this has to be provisioned by the application layer.),
    CONTENT#8134(   See [CHHSV17] for details.  In addition, the analysis of),
    CONTENT#8135(   post-handshake authentication from [Kraw16] shows that the client),
    CONTENT#8136(   identified by the certificate sent in the post-handshake phase),
    CONTENT#8137(   possesses the traffic key.  This party is therefore the client that),
    CONTENT#8138(   participated in the original handshake or one to whom the original),
    CONTENT#8139(   client delegated the traffic key (assuming that the traffic key has),
    CONTENT#8140(   not been compromised).),
      BREAK#8141,
    SECTION#8142(id=E.1.3, title=0-RTT),
      BREAK#8143,
    CONTENT#8144(   The 0-RTT mode of operation generally provides security properties),
    CONTENT#8145(   similar to those of 1-RTT data, with the two exceptions that the),
    CONTENT#8146(   0-RTT encryption keys do not provide full forward secrecy and that),
    CONTENT#8147(   the server is not able to guarantee uniqueness of the handshake),
    CONTENT#8148(   (non-replayability) without keeping potentially undue amounts of),
    CONTENT#8149(   state.  See Section 8 for mechanisms to limit the exposure to replay.),
      BREAK#8150,
    SECTION#8151(id=E.1.4, title=Exporter Independence),
      BREAK#8152,
    CONTENT#8153(   The exporter_master_secret and early_exporter_master_secret are),
    CONTENT#8154(   derived to be independent of the traffic keys and therefore do not),
    CONTENT#8155(   represent a threat to the security of traffic encrypted with those),
    CONTENT#8156(   keys.  However, because these secrets can be used to compute any),
    CONTENT#8157(   exporter value, they SHOULD be erased as soon as possible.  If the),
    CONTENT#8158(   total set of exporter labels is known, then implementations SHOULD),
    CONTENT#8159(   pre-compute the inner Derive-Secret stage of the exporter computation),
    CONTENT#8160(   for all those labels, then erase the [early_]exporter_master_secret,),
    CONTENT#8161(   followed by each inner value as soon as it is known that it will not),
    CONTENT#8162(   be needed again.),
      BREAK#8163,
    SECTION#8164(id=E.1.5, title=Post-Compromise Security),
      BREAK#8165,
    CONTENT#8166(   TLS does not provide security for handshakes which take place after),
    CONTENT#8167(   the peer's long-term secret (signature key or external PSK) is),
    CONTENT#8168(   compromised.  It therefore does not provide post-compromise security),
    CONTENT#8169(   [CCG16], sometimes also referred to as backward or future secrecy.),
    CONTENT#8170(   This is in contrast to KCI resistance, which describes the security),
    CONTENT#8171(   guarantees that a party has after its own long-term secret has been),
    CONTENT#8172(   compromised.),
      BREAK#8173,
      BREAK#8174,
      BREAK#8175,
      BREAK#8176,
      BREAK#8178,
      BREAK#8180,
      BREAK#8181,
    SECTION#8182(id=E.1.6, title=External References),
      BREAK#8183,
    CONTENT#8184(   The reader should refer to the following references for analysis of),
    CONTENT#8185(   the TLS handshake: [DFGS15], [CHSV16], [DFGS16], [KW16], [Kraw16],),
    CONTENT#8186(   [FGSW16], [LXZFH16], [FG17], and [BBK17].),
      BREAK#8187,
    SECTION#8188(id=E.2, title=Record Layer),
      BREAK#8189,
    CONTENT#8190(   The record layer depends on the handshake producing strong traffic),
    CONTENT#8191(   secrets which can be used to derive bidirectional encryption keys and),
    CONTENT#8192(   nonces.  Assuming that is true, and the keys are used for no more),
    CONTENT#8193(   data than indicated in Section 5.5, then the record layer should),
    CONTENT#8194(   provide the following guarantees:),
      BREAK#8195,
    CONTENT#8196(   Confidentiality:  An attacker should not be able to determine the),
    CONTENT#8197(      plaintext contents of a given record.),
      BREAK#8198,
    CONTENT#8199(   Integrity:  An attacker should not be able to craft a new record),
    CONTENT#8200(      which is different from an existing record which will be accepted),
    CONTENT#8201(      by the receiver.),
      BREAK#8202,
    CONTENT#8203(   Order protection/non-replayability:  An attacker should not be able),
    CONTENT#8204(      to cause the receiver to accept a record which it has already),
    CONTENT#8205(      accepted or cause the receiver to accept record N+1 without having),
    CONTENT#8206(      first processed record N.),
      BREAK#8207,
    CONTENT#8208(   Length concealment:  Given a record with a given external length, the),
    CONTENT#8209(      attacker should not be able to determine the amount of the record),
    CONTENT#8210(      that is content versus padding.),
      BREAK#8211,
    CONTENT#8212(   Forward secrecy after key change:  If the traffic key update),
    CONTENT#8213(      mechanism described in Section 4.6.3 has been used and the),
    CONTENT#8214(      previous generation key is deleted, an attacker who compromises),
    CONTENT#8215(      the endpoint should not be able to decrypt traffic encrypted with),
    CONTENT#8216(      the old key.),
      BREAK#8217,
    CONTENT#8218(   Informally, TLS 1.3 provides these properties by AEAD-protecting the),
    CONTENT#8219(   plaintext with a strong key.  AEAD encryption [RFC5116] provides),
    CONTENT#8220(   confidentiality and integrity for the data.  Non-replayability is),
    CONTENT#8221(   provided by using a separate nonce for each record, with the nonce),
    CONTENT#8222(   being derived from the record sequence number (Section 5.3), with the),
    CONTENT#8223(   sequence number being maintained independently at both sides; thus,),
    CONTENT#8224(   records which are delivered out of order result in AEAD deprotection),
    CONTENT#8225(   failures.  In order to prevent mass cryptanalysis when the same),
    CONTENT#8226(   plaintext is repeatedly encrypted by different users under the same),
    CONTENT#8227(   key (as is commonly the case for HTTP), the nonce is formed by mixing),
      BREAK#8228,
      BREAK#8229,
      BREAK#8230,
      BREAK#8231,
      BREAK#8232,
      BREAK#8234,
      BREAK#8236,
      BREAK#8237,
    CONTENT#8238(   the sequence number with a secret per-connection initialization),
    CONTENT#8239(   vector derived along with the traffic keys.  See [BT16] for analysis),
    CONTENT#8240(   of this construction.),
      BREAK#8241,
    CONTENT#8242(   The rekeying technique in TLS 1.3 (see Section 7.2) follows the),
    CONTENT#8243(   construction of the serial generator as discussed in [REKEY], which),
    CONTENT#8244(   shows that rekeying can allow keys to be used for a larger number of),
    CONTENT#8245(   encryptions than without rekeying.  This relies on the security of),
    CONTENT#8246(   the HKDF-Expand-Label function as a pseudorandom function (PRF).  In),
    CONTENT#8247(   addition, as long as this function is truly one way, it is not),
    CONTENT#8248(   possible to compute traffic keys from prior to a key change (forward),
    CONTENT#8249(   secrecy).),
      BREAK#8250,
    CONTENT#8251(   TLS does not provide security for data which is communicated on a),
    CONTENT#8252(   connection after a traffic secret of that connection is compromised.),
    CONTENT#8253(   That is, TLS does not provide post-compromise security/future),
    CONTENT#8254(   secrecy/backward secrecy with respect to the traffic secret.  Indeed,),
    CONTENT#8255(   an attacker who learns a traffic secret can compute all future),
    CONTENT#8256(   traffic secrets on that connection.  Systems which want such),
    CONTENT#8257(   guarantees need to do a fresh handshake and establish a new),
    CONTENT#8258(   connection with an (EC)DHE exchange.),
      BREAK#8259,
    SECTION#8260(id=E.2.1, title=External References),
      BREAK#8261,
    CONTENT#8262(   The reader should refer to the following references for analysis of),
    CONTENT#8263(   the TLS record layer: [BMMRT15], [BT16], [BDFKPPRSZZ16], [BBK17], and),
    CONTENT#8264(   [PS18].),
      BREAK#8265,
    SECTION#8266(id=E.3, title=Traffic Analysis),
      BREAK#8267,
    CONTENT#8268(   TLS is susceptible to a variety of traffic analysis attacks based on),
    CONTENT#8269(   observing the length and timing of encrypted packets [CLINIC]),
    CONTENT#8270(   [HCJC16].  This is particularly easy when there is a small set of),
    CONTENT#8271(   possible messages to be distinguished, such as for a video server),
    CONTENT#8272(   hosting a fixed corpus of content, but still provides usable),
    CONTENT#8273(   information even in more complicated scenarios.),
      BREAK#8274,
    CONTENT#8275(   TLS does not provide any specific defenses against this form of),
    CONTENT#8276(   attack but does include a padding mechanism for use by applications:),
    CONTENT#8277(   The plaintext protected by the AEAD function consists of content plus),
    CONTENT#8278(   variable-length padding, which allows the application to produce),
    CONTENT#8279(   arbitrary-length encrypted records as well as padding-only cover),
    CONTENT#8280(   traffic to conceal the difference between periods of transmission and),
    CONTENT#8281(   periods of silence.  Because the padding is encrypted alongside the),
    CONTENT#8282(   actual content, an attacker cannot directly determine the length of),
    CONTENT#8283(   the padding but may be able to measure it indirectly by the use of),
    CONTENT#8284(   timing channels exposed during record processing (i.e., seeing how),
    CONTENT#8285(   long it takes to process a record or trickling in records to see),
      BREAK#8286,
      BREAK#8287,
      BREAK#8288,
      BREAK#8290,
      BREAK#8292,
      BREAK#8293,
    CONTENT#8294(   which ones elicit a response from the server).  In general, it is not),
    CONTENT#8295(   known how to remove all of these channels because even a),
    CONTENT#8296(   constant-time padding removal function will likely feed the content),
    CONTENT#8297(   into data-dependent functions.  At minimum, a fully constant-time),
    CONTENT#8298(   server or client would require close cooperation with the),
    CONTENT#8299(   application-layer protocol implementation, including making that),
    CONTENT#8300(   higher-level protocol constant time.),
      BREAK#8301,
    CONTENT#8302(   Note: Robust traffic analysis defenses will likely lead to inferior),
    CONTENT#8303(   performance due to delays in transmitting packets and increased),
    CONTENT#8304(   traffic volume.),
      BREAK#8305,
    SECTION#8306(id=E.4, title=Side-Channel Attacks),
      BREAK#8307,
    CONTENT#8308(   In general, TLS does not have specific defenses against side-channel),
    CONTENT#8309(   attacks (i.e., those which attack the communications via secondary),
    CONTENT#8310(   channels such as timing), leaving those to the implementation of the),
    CONTENT#8311(   relevant cryptographic primitives.  However, certain features of TLS),
    CONTENT#8312(   are designed to make it easier to write side-channel resistant code:),
      BREAK#8313,
    CONTENT#8314(   -  Unlike previous versions of TLS which used a composite MAC-then-),
    CONTENT#8315(      encrypt structure, TLS 1.3 only uses AEAD algorithms, allowing),
    CONTENT#8316(      implementations to use self-contained constant-time),
    CONTENT#8317(      implementations of those primitives.),
      BREAK#8318,
    CONTENT#8319(   -  TLS uses a uniform "bad_record_mac" alert for all decryption),
    CONTENT#8320(      errors, which is intended to prevent an attacker from gaining),
    CONTENT#8321(      piecewise insight into portions of the message.  Additional),
    CONTENT#8322(      resistance is provided by terminating the connection on such),
    CONTENT#8323(      errors; a new connection will have different cryptographic),
    CONTENT#8324(      material, preventing attacks against the cryptographic primitives),
    CONTENT#8325(      that require multiple trials.),
      BREAK#8326,
    CONTENT#8327(   Information leakage through side channels can occur at layers above),
    CONTENT#8328(   TLS, in application protocols and the applications that use them.),
    CONTENT#8329(   Resistance to side-channel attacks depends on applications and),
    CONTENT#8330(   application protocols separately ensuring that confidential),
    CONTENT#8331(   information is not inadvertently leaked.),
      BREAK#8332,
      BREAK#8333,
      BREAK#8334,
      BREAK#8335,
      BREAK#8336,
      BREAK#8337,
      BREAK#8338,
      BREAK#8339,
      BREAK#8340,
      BREAK#8341,
      BREAK#8342,
      BREAK#8343,
      BREAK#8344,
      BREAK#8346,
      BREAK#8348,
      BREAK#8349,
    SECTION#8350(id=E.5, title=Replay Attacks on 0-RTT),
      BREAK#8351,
    CONTENT#8352(   Replayable 0-RTT data presents a number of security threats to TLS-),
    CONTENT#8353(   using applications, unless those applications are specifically),
    CONTENT#8354(   engineered to be safe under replay (minimally, this means idempotent,),
    CONTENT#8355(   but in many cases may also require other stronger conditions, such as),
    CONTENT#8356(   constant-time response).  Potential attacks include:),
      BREAK#8357,
    CONTENT#8358(   -  Duplication of actions which cause side effects (e.g., purchasing),
    CONTENT#8359(      an item or transferring money) to be duplicated, thus harming the),
    CONTENT#8360(      site or the user.),
      BREAK#8361,
    CONTENT#8362(   -  Attackers can store and replay 0-RTT messages in order to reorder),
    CONTENT#8363(      them with respect to other messages (e.g., moving a delete to),
    CONTENT#8364(      after a create).),
      BREAK#8365,
    CONTENT#8366(   -  Exploiting cache timing behavior to discover the content of 0-RTT),
    CONTENT#8367(      messages by replaying a 0-RTT message to a different cache node),
    CONTENT#8368(      and then using a separate connection to measure request latency,),
    CONTENT#8369(      to see if the two requests address the same resource.),
      BREAK#8370,
    CONTENT#8371(   If data can be replayed a large number of times, additional attacks),
    CONTENT#8372(   become possible, such as making repeated measurements of the speed of),
    CONTENT#8373(   cryptographic operations.  In addition, they may be able to overload),
    CONTENT#8374(   rate-limiting systems.  For a further description of these attacks,),
    CONTENT#8375(   see [Mac17].),
      BREAK#8376,
    CONTENT#8377(   Ultimately, servers have the responsibility to protect themselves),
    CONTENT#8378(   against attacks employing 0-RTT data replication.  The mechanisms),
    CONTENT#8379(   described in Section 8 are intended to prevent replay at the TLS),
    CONTENT#8380(   layer but do not provide complete protection against receiving),
    CONTENT#8381(   multiple copies of client data.  TLS 1.3 falls back to the 1-RTT),
    CONTENT#8382(   handshake when the server does not have any information about the),
    CONTENT#8383(   client, e.g., because it is in a different cluster which does not),
    CONTENT#8384(   share state or because the ticket has been deleted as described in),
    CONTENT#8385(   Section 8.1.  If the application-layer protocol retransmits data in),
    CONTENT#8386(   this setting, then it is possible for an attacker to induce message),
    CONTENT#8387(   duplication by sending the ClientHello to both the original cluster),
    CONTENT#8388(   (which processes the data immediately) and another cluster which will),
    CONTENT#8389(   fall back to 1-RTT and process the data upon application-layer),
    CONTENT#8390(   replay.  The scale of this attack is limited by the client's),
    CONTENT#8391(   willingness to retry transactions and therefore only allows a limited),
    CONTENT#8392(   amount of duplication, with each copy appearing as a new connection),
    CONTENT#8393(   at the server.),
      BREAK#8394,
      BREAK#8395,
      BREAK#8396,
      BREAK#8397,
      BREAK#8398,
      BREAK#8399,
      BREAK#8400,
      BREAK#8402,
      BREAK#8404,
      BREAK#8405,
    CONTENT#8406(   If implemented correctly, the mechanisms described in Sections 8.1),
    CONTENT#8407(   and 8.2 prevent a replayed ClientHello and its associated 0-RTT data),
    CONTENT#8408(   from being accepted multiple times by any cluster with consistent),
    CONTENT#8409(   state; for servers which limit the use of 0-RTT to one cluster for a),
    CONTENT#8410(   single ticket, then a given ClientHello and its associated 0-RTT data),
    CONTENT#8411(   will only be accepted once.  However, if state is not completely),
    CONTENT#8412(   consistent, then an attacker might be able to have multiple copies of),
    CONTENT#8413(   the data be accepted during the replication window.  Because clients),
    CONTENT#8414(   do not know the exact details of server behavior, they MUST NOT send),
    CONTENT#8415(   messages in early data which are not safe to have replayed and which),
    CONTENT#8416(   they would not be willing to retry across multiple 1-RTT connections.),
      BREAK#8417,
    CONTENT#8418(   Application protocols MUST NOT use 0-RTT data without a profile that),
    CONTENT#8419(   defines its use.  That profile needs to identify which messages or),
    CONTENT#8420(   interactions are safe to use with 0-RTT and how to handle the),
    CONTENT#8421(   situation when the server rejects 0-RTT and falls back to 1-RTT.),
      BREAK#8422,
    CONTENT#8423(   In addition, to avoid accidental misuse, TLS implementations MUST NOT),
    CONTENT#8424(   enable 0-RTT (either sending or accepting) unless specifically),
    CONTENT#8425(   requested by the application and MUST NOT automatically resend 0-RTT),
    CONTENT#8426(   data if it is rejected by the server unless instructed by the),
    CONTENT#8427(   application.  Server-side applications may wish to implement special),
    CONTENT#8428(   processing for 0-RTT data for some kinds of application traffic),
    CONTENT#8429(   (e.g., abort the connection, request that data be resent at the),
    CONTENT#8430(   application layer, or delay processing until the handshake),
    CONTENT#8431(   completes).  In order to allow applications to implement this kind of),
    CONTENT#8432(   processing, TLS implementations MUST provide a way for the),
    CONTENT#8433(   application to determine if the handshake has completed.),
      BREAK#8434,
    SECTION#8435(id=E.5.1, title=Replay and Exporters),
      BREAK#8436,
    CONTENT#8437(   Replays of the ClientHello produce the same early exporter, thus),
    CONTENT#8438(   requiring additional care by applications which use these exporters.),
    CONTENT#8439(   In particular, if these exporters are used as an authentication),
    CONTENT#8440(   channel binding (e.g., by signing the output of the exporter), an),
    CONTENT#8441(   attacker who compromises the PSK can transplant authenticators),
    CONTENT#8442(   between connections without compromising the authentication key.),
      BREAK#8443,
    CONTENT#8444(   In addition, the early exporter SHOULD NOT be used to generate),
    CONTENT#8445(   server-to-client encryption keys because that would entail the reuse),
    CONTENT#8446(   of those keys.  This parallels the use of the early application),
    CONTENT#8447(   traffic keys only in the client-to-server direction.),
      BREAK#8448,
      BREAK#8449,
      BREAK#8450,
      BREAK#8451,
      BREAK#8452,
      BREAK#8453,
      BREAK#8454,
      BREAK#8455,
      BREAK#8456,
      BREAK#8458,
      BREAK#8460,
      BREAK#8461,
    SECTION#8462(id=E.6, title=PSK Identity Exposure),
      BREAK#8463,
    CONTENT#8464(   Because implementations respond to an invalid PSK binder by aborting),
    CONTENT#8465(   the handshake, it may be possible for an attacker to verify whether a),
    CONTENT#8466(   given PSK identity is valid.  Specifically, if a server accepts both),
    CONTENT#8467(   external-PSK handshakes and certificate-based handshakes, a valid PSK),
    CONTENT#8468(   identity will result in a failed handshake, whereas an invalid),
    CONTENT#8469(   identity will just be skipped and result in a successful certificate),
    CONTENT#8470(   handshake.  Servers which solely support PSK handshakes may be able),
    CONTENT#8471(   to resist this form of attack by treating the cases where there is no),
    CONTENT#8472(   valid PSK identity and where there is an identity but it has an),
    CONTENT#8473(   invalid binder identically.),
      BREAK#8474,
    SECTION#8475(id=E.7, title=Sharing PSKs),
      BREAK#8476,
    CONTENT#8477(   TLS 1.3 takes a conservative approach to PSKs by binding them to a),
    CONTENT#8478(   specific KDF.  By contrast, TLS 1.2 allows PSKs to be used with any),
    CONTENT#8479(   hash function and the TLS 1.2 PRF.  Thus, any PSK which is used with),
    CONTENT#8480(   both TLS 1.2 and TLS 1.3 must be used with only one hash in TLS 1.3,),
    CONTENT#8481(   which is less than optimal if users want to provision a single PSK.),
    CONTENT#8482(   The constructions in TLS 1.2 and TLS 1.3 are different, although they),
    CONTENT#8483(   are both based on HMAC.  While there is no known way in which the),
    CONTENT#8484(   same PSK might produce related output in both versions, only limited),
    CONTENT#8485(   analysis has been done.  Implementations can ensure safety from),
    CONTENT#8486(   cross-protocol related output by not reusing PSKs between TLS 1.3 and),
    CONTENT#8487(   TLS 1.2.),
      BREAK#8488,
    SECTION#8489(id=E.8, title=Attacks on Static RSA),
      BREAK#8490,
    CONTENT#8491(   Although TLS 1.3 does not use RSA key transport and so is not),
    CONTENT#8492(   directly susceptible to Bleichenbacher-type attacks [Blei98], if TLS),
    CONTENT#8493(   1.3 servers also support static RSA in the context of previous),
    CONTENT#8494(   versions of TLS, then it may be possible to impersonate the server),
    CONTENT#8495(   for TLS 1.3 connections [JSS15].  TLS 1.3 implementations can prevent),
    CONTENT#8496(   this attack by disabling support for static RSA across all versions),
    CONTENT#8497(   of TLS.  In principle, implementations might also be able to separate),
    CONTENT#8498(   certificates with different keyUsage bits for static RSA decryption),
    CONTENT#8499(   and RSA signature, but this technique relies on clients refusing to),
    CONTENT#8500(   accept signatures using keys in certificates that do not have the),
    CONTENT#8501(   digitalSignature bit set, and many clients do not enforce this),
    CONTENT#8502(   restriction.),
      BREAK#8503,
      BREAK#8504,
      BREAK#8505,
      BREAK#8506,
      BREAK#8507,
      BREAK#8508,
      BREAK#8509,
      BREAK#8510,
      BREAK#8511,
      BREAK#8512,
      BREAK#8514,
      BREAK#8516,
      BREAK#8517,
      BREAK#8519,
    CONTENT#8520(   Martin Abadi),
    CONTENT#8521(   University of California, Santa Cruz),
    CONTENT#8522(   abadi@cs.ucsc.edu),
      BREAK#8523,
    CONTENT#8524(   Christopher Allen),
    CONTENT#8525(   (co-editor of TLS 1.0)),
    CONTENT#8526(   Alacrity Ventures),
    CONTENT#8527(   ChristopherA@AlacrityManagement.com),
      BREAK#8528,
    CONTENT#8529(   Richard Barnes),
    CONTENT#8530(   Cisco),
    CONTENT#8531(   rlb@ipv.sx),
      BREAK#8532,
    CONTENT#8533(   Steven M. Bellovin),
    CONTENT#8534(   Columbia University),
    CONTENT#8535(   smb@cs.columbia.edu),
      BREAK#8536,
    CONTENT#8537(   David Benjamin),
    CONTENT#8538(   Google),
    CONTENT#8539(   davidben@google.com),
      BREAK#8540,
    CONTENT#8541(   Benjamin Beurdouche),
    CONTENT#8542(   INRIA & Microsoft Research),
    CONTENT#8543(   benjamin.beurdouche@ens.fr),
      BREAK#8544,
    CONTENT#8545(   Karthikeyan Bhargavan),
    CONTENT#8546(   (editor of [RFC7627])),
    CONTENT#8547(   INRIA),
    CONTENT#8548(   karthikeyan.bhargavan@inria.fr),
      BREAK#8549,
    CONTENT#8550(   Simon Blake-Wilson),
    CONTENT#8551(   (co-author of [RFC4492])),
    CONTENT#8552(   BCI),
    CONTENT#8553(   sblakewilson@bcisse.com),
      BREAK#8554,
    CONTENT#8555(   Nelson Bolyard),
    CONTENT#8556(   (co-author of [RFC4492])),
    CONTENT#8557(   Sun Microsystems, Inc.),
    CONTENT#8558(   nelson@bolyard.com),
      BREAK#8559,
    CONTENT#8560(   Ran Canetti),
    CONTENT#8561(   IBM),
    CONTENT#8562(   canetti@watson.ibm.com),
      BREAK#8563,
      BREAK#8564,
      BREAK#8565,
      BREAK#8566,
      BREAK#8567,
      BREAK#8568,
      BREAK#8570,
      BREAK#8572,
      BREAK#8573,
    CONTENT#8574(   Matt Caswell),
    CONTENT#8575(   OpenSSL),
    CONTENT#8576(   matt@openssl.org),
      BREAK#8577,
    CONTENT#8578(   Stephen Checkoway),
    CONTENT#8579(   University of Illinois at Chicago),
    CONTENT#8580(   sfc@uic.edu),
      BREAK#8581,
    CONTENT#8582(   Pete Chown),
    CONTENT#8583(   Skygate Technology Ltd),
    CONTENT#8584(   pc@skygate.co.uk),
      BREAK#8585,
    CONTENT#8586(   Katriel Cohn-Gordon),
    CONTENT#8587(   University of Oxford),
    CONTENT#8588(   me@katriel.co.uk),
      BREAK#8589,
    CONTENT#8590(   Cas Cremers),
    CONTENT#8591(   University of Oxford),
    CONTENT#8592(   cas.cremers@cs.ox.ac.uk),
      BREAK#8593,
    CONTENT#8594(   Antoine Delignat-Lavaud),
    CONTENT#8595(   (co-author of [RFC7627])),
    CONTENT#8596(   INRIA),
    CONTENT#8597(   antdl@microsoft.com),
      BREAK#8598,
    CONTENT#8599(   Tim Dierks),
    CONTENT#8600(   (co-author of TLS 1.0, co-editor of TLS 1.1 and 1.2)),
    CONTENT#8601(   Independent),
    CONTENT#8602(   tim@dierks.org),
      BREAK#8603,
    CONTENT#8604(   Roelof DuToit),
    CONTENT#8605(   Symantec Corporation),
    CONTENT#8606(   roelof_dutoit@symantec.com),
      BREAK#8607,
    CONTENT#8608(   Taher Elgamal),
    CONTENT#8609(   Securify),
    CONTENT#8610(   taher@securify.com),
      BREAK#8611,
    CONTENT#8612(   Pasi Eronen),
    CONTENT#8613(   Nokia),
    CONTENT#8614(   pasi.eronen@nokia.com),
      BREAK#8615,
    CONTENT#8616(   Cedric Fournet),
    CONTENT#8617(   Microsoft),
    CONTENT#8618(   fournet@microsoft.com),
      BREAK#8619,
      BREAK#8620,
      BREAK#8621,
      BREAK#8622,
      BREAK#8623,
      BREAK#8624,
      BREAK#8626,
      BREAK#8628,
      BREAK#8629,
    CONTENT#8630(   Anil Gangolli),
    CONTENT#8631(   anil@busybuddha.org),
      BREAK#8632,
    CONTENT#8633(   David M. Garrett),
    CONTENT#8634(   dave@nulldereference.com),
      BREAK#8635,
    CONTENT#8636(   Illya Gerasymchuk),
    CONTENT#8637(   Independent),
    CONTENT#8638(   illya@iluxonchik.me),
      BREAK#8639,
    CONTENT#8640(   Alessandro Ghedini),
    CONTENT#8641(   Cloudflare Inc.),
    CONTENT#8642(   alessandro@cloudflare.com),
      BREAK#8643,
    CONTENT#8644(   Daniel Kahn Gillmor),
    CONTENT#8645(   ACLU),
    CONTENT#8646(   dkg@fifthhorseman.net),
      BREAK#8647,
    CONTENT#8648(   Matthew Green),
    CONTENT#8649(   Johns Hopkins University),
    CONTENT#8650(   mgreen@cs.jhu.edu),
      BREAK#8651,
    CONTENT#8652(   Jens Guballa),
    CONTENT#8653(   ETAS),
    CONTENT#8654(   jens.guballa@etas.com),
      BREAK#8655,
    CONTENT#8656(   Felix Guenther),
    CONTENT#8657(   TU Darmstadt),
    CONTENT#8658(   mail@felixguenther.info),
      BREAK#8659,
    CONTENT#8660(   Vipul Gupta),
    CONTENT#8661(   (co-author of [RFC4492])),
    CONTENT#8662(   Sun Microsystems Laboratories),
    CONTENT#8663(   vipul.gupta@sun.com),
      BREAK#8664,
    CONTENT#8665(   Chris Hawk),
    CONTENT#8666(   (co-author of [RFC4492])),
    CONTENT#8667(   Corriente Networks LLC),
    CONTENT#8668(   chris@corriente.net),
      BREAK#8669,
    CONTENT#8670(   Kipp Hickman),
      BREAK#8671,
    CONTENT#8672(   Alfred Hoenes),
      BREAK#8673,
    CONTENT#8674(   David Hopwood),
    CONTENT#8675(   Independent Consultant),
    CONTENT#8676(   david.hopwood@blueyonder.co.uk),
      BREAK#8677,
      BREAK#8678,
      BREAK#8679,
      BREAK#8680,
      BREAK#8682,
      BREAK#8684,
      BREAK#8685,
    CONTENT#8686(   Marko Horvat),
    CONTENT#8687(   MPI-SWS),
    CONTENT#8688(   mhorvat@mpi-sws.org),
      BREAK#8689,
    CONTENT#8690(   Jonathan Hoyland),
    CONTENT#8691(   Royal Holloway, University of London),
    CONTENT#8692(   jonathan.hoyland@gmail.com),
      BREAK#8693,
    CONTENT#8694(   Subodh Iyengar),
    CONTENT#8695(   Facebook),
    CONTENT#8696(   subodh@fb.com),
      BREAK#8697,
    CONTENT#8698(   Benjamin Kaduk),
    CONTENT#8699(   Akamai Technologies),
    CONTENT#8700(   kaduk@mit.edu),
      BREAK#8701,
    CONTENT#8702(   Hubert Kario),
    CONTENT#8703(   Red Hat Inc.),
    CONTENT#8704(   hkario@redhat.com),
      BREAK#8705,
    CONTENT#8706(   Phil Karlton),
    CONTENT#8707(   (co-author of SSL 3.0)),
      BREAK#8708,
    CONTENT#8709(   Leon Klingele),
    CONTENT#8710(   Independent),
    CONTENT#8711(   mail@leonklingele.de),
      BREAK#8712,
    CONTENT#8713(   Paul Kocher),
    CONTENT#8714(   (co-author of SSL 3.0)),
    CONTENT#8715(   Cryptography Research),
    CONTENT#8716(   paul@cryptography.com),
      BREAK#8717,
    CONTENT#8718(   Hugo Krawczyk),
    CONTENT#8719(   IBM),
    CONTENT#8720(   hugokraw@us.ibm.com),
      BREAK#8721,
    CONTENT#8722(   Adam Langley),
    CONTENT#8723(   (co-author of [RFC7627])),
    CONTENT#8724(   Google),
    CONTENT#8725(   agl@google.com),
      BREAK#8726,
    CONTENT#8727(   Olivier Levillain),
    CONTENT#8728(   ANSSI),
    CONTENT#8729(   olivier.levillain@ssi.gouv.fr),
      BREAK#8730,
      BREAK#8731,
      BREAK#8732,
      BREAK#8733,
      BREAK#8734,
      BREAK#8735,
      BREAK#8736,
      BREAK#8738,
      BREAK#8740,
      BREAK#8741,
    CONTENT#8742(   Xiaoyin Liu),
    CONTENT#8743(   University of North Carolina at Chapel Hill),
    CONTENT#8744(   xiaoyin.l@outlook.com),
      BREAK#8745,
    CONTENT#8746(   Ilari Liusvaara),
    CONTENT#8747(   Independent),
    CONTENT#8748(   ilariliusvaara@welho.com),
      BREAK#8749,
    CONTENT#8750(   Atul Luykx),
    CONTENT#8751(   K.U. Leuven),
    CONTENT#8752(   atul.luykx@kuleuven.be),
      BREAK#8753,
    CONTENT#8754(   Colm MacCarthaigh),
    CONTENT#8755(   Amazon Web Services),
    CONTENT#8756(   colm@allcosts.net),
      BREAK#8757,
    CONTENT#8758(   Carl Mehner),
    CONTENT#8759(   USAA),
    CONTENT#8760(   carl.mehner@usaa.com),
      BREAK#8761,
    CONTENT#8762(   Jan Mikkelsen),
    CONTENT#8763(   Transactionware),
    CONTENT#8764(   janm@transactionware.com),
      BREAK#8765,
    CONTENT#8766(   Bodo Moeller),
    CONTENT#8767(   (co-author of [RFC4492])),
    CONTENT#8768(   Google),
    CONTENT#8769(   bodo@acm.org),
      BREAK#8770,
    CONTENT#8771(   Kyle Nekritz),
    CONTENT#8772(   Facebook),
    CONTENT#8773(   knekritz@fb.com),
      BREAK#8774,
    CONTENT#8775(   Erik Nygren),
    CONTENT#8776(   Akamai Technologies),
    CONTENT#8777(   erik+ietf@nygren.org),
      BREAK#8778,
    CONTENT#8779(   Magnus Nystrom),
    CONTENT#8780(   Microsoft),
    CONTENT#8781(   mnystrom@microsoft.com),
      BREAK#8782,
    CONTENT#8783(   Kazuho Oku),
    CONTENT#8784(   DeNA Co., Ltd.),
    CONTENT#8785(   kazuhooku@gmail.com),
      BREAK#8786,
      BREAK#8787,
      BREAK#8788,
      BREAK#8789,
      BREAK#8790,
      BREAK#8791,
      BREAK#8792,
      BREAK#8794,
      BREAK#8796,
      BREAK#8797,
    CONTENT#8798(   Kenny Paterson),
    CONTENT#8799(   Royal Holloway, University of London),
    CONTENT#8800(   kenny.paterson@rhul.ac.uk),
      BREAK#8801,
    CONTENT#8802(   Christopher Patton),
    CONTENT#8803(   University of Florida),
    CONTENT#8804(   cjpatton@ufl.edu),
      BREAK#8805,
    CONTENT#8806(   Alfredo Pironti),
    CONTENT#8807(   (co-author of [RFC7627])),
    CONTENT#8808(   INRIA),
    CONTENT#8809(   alfredo.pironti@inria.fr),
      BREAK#8810,
    CONTENT#8811(   Andrei Popov),
    CONTENT#8812(   Microsoft),
    CONTENT#8813(   andrei.popov@microsoft.com),
      BREAK#8814,
    CONTENT#8815(   Marsh Ray),
    CONTENT#8816(   (co-author of [RFC7627])),
    CONTENT#8817(   Microsoft),
    CONTENT#8818(   maray@microsoft.com),
      BREAK#8819,
    CONTENT#8820(   Robert Relyea),
    CONTENT#8821(   Netscape Communications),
    CONTENT#8822(   relyea@netscape.com),
      BREAK#8823,
    CONTENT#8824(   Kyle Rose),
    CONTENT#8825(   Akamai Technologies),
    CONTENT#8826(   krose@krose.org),
      BREAK#8827,
    CONTENT#8828(   Jim Roskind),
    CONTENT#8829(   Amazon),
    CONTENT#8830(   jroskind@amazon.com),
      BREAK#8831,
    CONTENT#8832(   Michael Sabin),
      BREAK#8833,
    CONTENT#8834(   Joe Salowey),
    CONTENT#8835(   Tableau Software),
    CONTENT#8836(   joe@salowey.net),
      BREAK#8837,
    CONTENT#8838(   Rich Salz),
    CONTENT#8839(   Akamai),
    CONTENT#8840(   rsalz@akamai.com),
      BREAK#8841,
    CONTENT#8842(   David Schinazi),
    CONTENT#8843(   Apple Inc.),
    CONTENT#8844(   dschinazi@apple.com),
      BREAK#8845,
      BREAK#8846,
      BREAK#8847,
      BREAK#8848,
      BREAK#8850,
      BREAK#8852,
      BREAK#8853,
    CONTENT#8854(   Sam Scott),
    CONTENT#8855(   Royal Holloway, University of London),
    CONTENT#8856(   me@samjs.co.uk),
      BREAK#8857,
    CONTENT#8858(   Thomas Shrimpton),
    CONTENT#8859(   University of Florida),
    CONTENT#8860(   teshrim@ufl.edu),
      BREAK#8861,
    CONTENT#8862(   Dan Simon),
    CONTENT#8863(   Microsoft, Inc.),
    CONTENT#8864(   dansimon@microsoft.com),
      BREAK#8865,
    CONTENT#8866(   Brian Smith),
    CONTENT#8867(   Independent),
    CONTENT#8868(   brian@briansmith.org),
      BREAK#8869,
    CONTENT#8870(   Brian Sniffen),
    CONTENT#8871(   Akamai Technologies),
    CONTENT#8872(   ietf@bts.evenmere.org),
      BREAK#8873,
    CONTENT#8874(   Nick Sullivan),
    CONTENT#8875(   Cloudflare Inc.),
    CONTENT#8876(   nick@cloudflare.com),
      BREAK#8877,
    CONTENT#8878(   Bjoern Tackmann),
    CONTENT#8879(   University of California, San Diego),
    CONTENT#8880(   btackmann@eng.ucsd.edu),
      BREAK#8881,
    CONTENT#8882(   Tim Taubert),
    CONTENT#8883(   Mozilla),
    CONTENT#8884(   ttaubert@mozilla.com),
      BREAK#8885,
    CONTENT#8886(   Martin Thomson),
    CONTENT#8887(   Mozilla),
    CONTENT#8888(   mt@mozilla.com),
      BREAK#8889,
    CONTENT#8890(   Hannes Tschofenig),
    CONTENT#8891(   Arm Limited),
    CONTENT#8892(   Hannes.Tschofenig@arm.com),
      BREAK#8893,
    CONTENT#8894(   Sean Turner),
    CONTENT#8895(   sn3rd),
    CONTENT#8896(   sean@sn3rd.com),
      BREAK#8897,
    CONTENT#8898(   Steven Valdez),
    CONTENT#8899(   Google),
    CONTENT#8900(   svaldez@google.com),
      BREAK#8901,
      BREAK#8902,
      BREAK#8903,
      BREAK#8904,
      BREAK#8906,
      BREAK#8908,
      BREAK#8909,
    CONTENT#8910(   Filippo Valsorda),
    CONTENT#8911(   Cloudflare Inc.),
    CONTENT#8912(   filippo@cloudflare.com),
      BREAK#8913,
    CONTENT#8914(   Thyla van der Merwe),
    CONTENT#8915(   Royal Holloway, University of London),
    CONTENT#8916(   tjvdmerwe@gmail.com),
      BREAK#8917,
    CONTENT#8918(   Victor Vasiliev),
    CONTENT#8919(   Google),
    CONTENT#8920(   vasilvv@google.com),
      BREAK#8921,
    CONTENT#8922(   Hoeteck Wee),
    CONTENT#8923(   Ecole Normale Superieure, Paris),
    CONTENT#8924(   hoeteck@alum.mit.edu),
      BREAK#8925,
    CONTENT#8926(   Tom Weinstein),
      BREAK#8927,
    CONTENT#8928(   David Wong),
    CONTENT#8929(   NCC Group),
    CONTENT#8930(   david.wong@nccgroup.trust),
      BREAK#8931,
    CONTENT#8932(   Christopher A. Wood),
    CONTENT#8933(   Apple Inc.),
    CONTENT#8934(   cawood@apple.com),
      BREAK#8935,
    CONTENT#8936(   Tim Wright),
    CONTENT#8937(   Vodafone),
    CONTENT#8938(   timothy.wright@vodafone.com),
      BREAK#8939,
    CONTENT#8940(   Peter Wu),
    CONTENT#8941(   Independent),
    CONTENT#8942(   peter@lekensteyn.nl),
      BREAK#8943,
    CONTENT#8944(   Kazu Yamamoto),
    CONTENT#8945(   Internet Initiative Japan Inc.),
    CONTENT#8946(   kazu@iij.ad.jp),
      BREAK#8947,
      BREAK#8949,
    CONTENT#8950(   Eric Rescorla),
    CONTENT#8951(   Mozilla),
      BREAK#8952,
    CONTENT#8953(   Email: ekr@rtfm.com),
      BREAK#8954,
      BREAK#8955,
      BREAK#8956,
      BREAK#8957,
      BREAK#8958,
      BREAK#8959,
      BREAK#8960,
      BREAK#8962,
]
