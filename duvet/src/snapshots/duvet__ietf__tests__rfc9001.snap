---
source: duvet/src/ietf.rs
expression: "Tokenizer::new(&rfc9001).collect::<Vec<_>>()"

---
[
      BREAK#1,
      BREAK#2,
      BREAK#3,
    CONTENT#8(                                                                May 2021),
      BREAK#9,
      BREAK#10,
    CONTENT#11(                        Using TLS to Secure QUIC),
      BREAK#12,
      BREAK#14,
    CONTENT#15(   This document describes how Transport Layer Security (TLS) is used to),
    CONTENT#16(   secure QUIC.),
      BREAK#17,
      BREAK#19,
    CONTENT#20(   This is an Internet Standards Track document.),
      BREAK#21,
    CONTENT#22(   This document is a product of the Internet Engineering Task Force),
    CONTENT#23(   (IETF).  It represents the consensus of the IETF community.  It has),
    CONTENT#24(   received public review and has been approved for publication by the),
    CONTENT#25(   Internet Engineering Steering Group (IESG).  Further information on),
    CONTENT#26(   Internet Standards is available in Section 2 of RFC 7841.),
      BREAK#27,
    CONTENT#28(   Information about the current status of this document, any errata,),
    CONTENT#29(   and how to provide feedback on it may be obtained at),
    CONTENT#30(   https://www.rfc-editor.org/info/rfc9001.),
      BREAK#31,
      BREAK#33,
    CONTENT#34(   Copyright (c) 2021 IETF Trust and the persons identified as the),
    CONTENT#35(   document authors.  All rights reserved.),
      BREAK#36,
    CONTENT#37(   This document is subject to BCP 78 and the IETF Trust's Legal),
    CONTENT#38(   Provisions Relating to IETF Documents),
    CONTENT#39(   (https://trustee.ietf.org/license-info) in effect on the date of),
    CONTENT#40(   publication of this document.  Please review these documents),
    CONTENT#41(   carefully, as they describe your rights and restrictions with respect),
    CONTENT#42(   to this document.  Code Components extracted from this document must),
    CONTENT#43(   include Simplified BSD License text as described in Section 4.e of),
    CONTENT#44(   the Trust Legal Provisions and are provided without warranty as),
    CONTENT#45(   described in the Simplified BSD License.),
      BREAK#46,
      BREAK#48,
    CONTENT#49(   1.  Introduction),
    CONTENT#50(   2.  Notational Conventions),
    CONTENT#51(     2.1.  TLS Overview),
    CONTENT#52(   3.  Protocol Overview),
    CONTENT#53(   4.  Carrying TLS Messages),
    CONTENT#54(     4.1.  Interface to TLS),
    CONTENT#55(       4.1.1.  Handshake Complete),
    CONTENT#56(       4.1.2.  Handshake Confirmed),
    CONTENT#57(       4.1.3.  Sending and Receiving Handshake Messages),
    CONTENT#58(       4.1.4.  Encryption Level Changes),
    CONTENT#59(       4.1.5.  TLS Interface Summary),
    CONTENT#60(     4.2.  TLS Version),
    CONTENT#61(     4.3.  ClientHello Size),
    CONTENT#62(     4.4.  Peer Authentication),
    CONTENT#63(     4.5.  Session Resumption),
    CONTENT#64(     4.6.  0-RTT),
    CONTENT#65(       4.6.1.  Enabling 0-RTT),
    CONTENT#66(       4.6.2.  Accepting and Rejecting 0-RTT),
    CONTENT#67(       4.6.3.  Validating 0-RTT Configuration),
    CONTENT#68(     4.7.  HelloRetryRequest),
    CONTENT#69(     4.8.  TLS Errors),
    CONTENT#70(     4.9.  Discarding Unused Keys),
    CONTENT#71(       4.9.1.  Discarding Initial Keys),
    CONTENT#72(       4.9.2.  Discarding Handshake Keys),
    CONTENT#73(       4.9.3.  Discarding 0-RTT Keys),
    CONTENT#74(   5.  Packet Protection),
    CONTENT#75(     5.1.  Packet Protection Keys),
    CONTENT#76(     5.2.  Initial Secrets),
    CONTENT#77(     5.3.  AEAD Usage),
    CONTENT#78(     5.4.  Header Protection),
    CONTENT#79(       5.4.1.  Header Protection Application),
    CONTENT#80(       5.4.2.  Header Protection Sample),
    CONTENT#81(       5.4.3.  AES-Based Header Protection),
    CONTENT#82(       5.4.4.  ChaCha20-Based Header Protection),
    CONTENT#83(     5.5.  Receiving Protected Packets),
    CONTENT#84(     5.6.  Use of 0-RTT Keys),
    CONTENT#85(     5.7.  Receiving Out-of-Order Protected Packets),
    CONTENT#86(     5.8.  Retry Packet Integrity),
    CONTENT#87(   6.  Key Update),
    CONTENT#88(     6.1.  Initiating a Key Update),
    CONTENT#89(     6.2.  Responding to a Key Update),
    CONTENT#90(     6.3.  Timing of Receive Key Generation),
    CONTENT#91(     6.4.  Sending with Updated Keys),
    CONTENT#92(     6.5.  Receiving with Different Keys),
    CONTENT#93(     6.6.  Limits on AEAD Usage),
    CONTENT#94(     6.7.  Key Update Error Code),
    CONTENT#95(   7.  Security of Initial Messages),
    CONTENT#96(   8.  QUIC-Specific Adjustments to the TLS Handshake),
    CONTENT#97(     8.1.  Protocol Negotiation),
    CONTENT#98(     8.2.  QUIC Transport Parameters Extension),
    CONTENT#99(     8.3.  Removing the EndOfEarlyData Message),
    CONTENT#100(     8.4.  Prohibit TLS Middlebox Compatibility Mode),
    CONTENT#101(   9.  Security Considerations),
    CONTENT#102(     9.1.  Session Linkability),
    CONTENT#103(     9.2.  Replay Attacks with 0-RTT),
    CONTENT#104(     9.3.  Packet Reflection Attack Mitigation),
    CONTENT#105(     9.4.  Header Protection Analysis),
    CONTENT#106(     9.5.  Header Protection Timing Side Channels),
    CONTENT#107(     9.6.  Key Diversity),
    CONTENT#108(     9.7.  Randomness),
    CONTENT#109(   10. IANA Considerations),
    CONTENT#110(   11. References),
    CONTENT#111(     11.1.  Normative References),
    CONTENT#112(     11.2.  Informative References),
    CONTENT#113(   Appendix A.  Sample Packet Protection),
    CONTENT#114(     A.1.  Keys),
    CONTENT#115(     A.2.  Client Initial),
    CONTENT#116(     A.3.  Server Initial),
    CONTENT#117(     A.4.  Retry),
    CONTENT#118(     A.5.  ChaCha20-Poly1305 Short Header Packet),
    CONTENT#119(   Appendix B.  AEAD Algorithm Analysis),
    CONTENT#120(     B.1.  Analysis of AEAD_AES_128_GCM and AEAD_AES_256_GCM Usage),
    CONTENT#121(           Limits),
    CONTENT#122(       B.1.1.  Confidentiality Limit),
    CONTENT#123(       B.1.2.  Integrity Limit),
    CONTENT#124(     B.2.  Analysis of AEAD_AES_128_CCM Usage Limits),
    CONTENT#125(   Contributors),
    CONTENT#126(   Authors' Addresses),
      BREAK#127,
    SECTION#128(id=1, title=Introduction),
      BREAK#129,
    CONTENT#130(   This document describes how QUIC [QUIC-TRANSPORT] is secured using),
    CONTENT#131(   TLS [TLS13].),
      BREAK#132,
    CONTENT#133(   TLS 1.3 provides critical latency improvements for connection),
    CONTENT#134(   establishment over previous versions.  Absent packet loss, most new),
    CONTENT#135(   connections can be established and secured within a single round),
    CONTENT#136(   trip; on subsequent connections between the same client and server,),
    CONTENT#137(   the client can often send application data immediately, that is,),
    CONTENT#138(   using a zero round-trip setup.),
      BREAK#139,
    CONTENT#140(   This document describes how TLS acts as a security component of QUIC.),
      BREAK#141,
    SECTION#142(id=2, title=Notational Conventions),
      BREAK#143,
    CONTENT#144(   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",),
    CONTENT#145(   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and),
    CONTENT#146(   "OPTIONAL" in this document are to be interpreted as described in BCP),
    CONTENT#147(   14 [RFC2119] [RFC8174] when, and only when, they appear in all),
    CONTENT#148(   capitals, as shown here.),
      BREAK#149,
    CONTENT#150(   This document uses the terminology established in [QUIC-TRANSPORT].),
      BREAK#151,
    CONTENT#152(   For brevity, the acronym TLS is used to refer to TLS 1.3, though a),
    CONTENT#153(   newer version could be used; see Section 4.2.),
      BREAK#154,
    SECTION#155(id=2.1, title=TLS Overview),
      BREAK#156,
    CONTENT#157(   TLS provides two endpoints with a way to establish a means of),
    CONTENT#158(   communication over an untrusted medium (for example, the Internet).),
    CONTENT#159(   TLS enables authentication of peers and provides confidentiality and),
    CONTENT#160(   integrity protection for messages that endpoints exchange.),
      BREAK#161,
    CONTENT#162(   Internally, TLS is a layered protocol, with the structure shown in),
    CONTENT#163(   Figure 1.),
      BREAK#164,
    CONTENT#165(             +-------------+------------+--------------+---------+),
    CONTENT#166(   Content   |             |            |  Application |         |),
    CONTENT#167(   Layer     |  Handshake  |   Alerts   |     Data     |   ...   |),
    CONTENT#168(             |             |            |              |         |),
    CONTENT#169(             +-------------+------------+--------------+---------+),
    CONTENT#170(   Record    |                                                   |),
    CONTENT#171(   Layer     |                      Records                      |),
    CONTENT#172(             |                                                   |),
    CONTENT#173(             +---------------------------------------------------+),
      BREAK#174,
    CONTENT#175(                            Figure 1: TLS Layers),
      BREAK#176,
    CONTENT#177(   Each content-layer message (e.g., handshake, alerts, and application),
    CONTENT#178(   data) is carried as a series of typed TLS records by the record),
    CONTENT#179(   layer.  Records are individually cryptographically protected and then),
    CONTENT#180(   transmitted over a reliable transport (typically TCP), which provides),
    CONTENT#181(   sequencing and guaranteed delivery.),
      BREAK#182,
    CONTENT#183(   The TLS authenticated key exchange occurs between two endpoints:),
    CONTENT#184(   client and server.  The client initiates the exchange and the server),
    CONTENT#185(   responds.  If the key exchange completes successfully, both client),
    CONTENT#186(   and server will agree on a secret.  TLS supports both pre-shared key),
    CONTENT#187(   (PSK) and Diffie-Hellman over either finite fields or elliptic curves),
    CONTENT#188(   ((EC)DHE) key exchanges.  PSK is the basis for Early Data (0-RTT);),
    CONTENT#189(   the latter provides forward secrecy (FS) when the (EC)DHE keys are),
    CONTENT#190(   destroyed.  The two modes can also be combined to provide forward),
    CONTENT#191(   secrecy while using the PSK for authentication.),
      BREAK#192,
    CONTENT#193(   After completing the TLS handshake, the client will have learned and),
    CONTENT#194(   authenticated an identity for the server, and the server is),
    CONTENT#195(   optionally able to learn and authenticate an identity for the client.),
    CONTENT#196(   TLS supports X.509 [RFC5280] certificate-based authentication for),
    CONTENT#197(   both server and client.  When PSK key exchange is used (as in),
    CONTENT#198(   resumption), knowledge of the PSK serves to authenticate the peer.),
      BREAK#199,
    CONTENT#200(   The TLS key exchange is resistant to tampering by attackers, and it),
    CONTENT#201(   produces shared secrets that cannot be controlled by either),
    CONTENT#202(   participating peer.),
      BREAK#203,
    CONTENT#204(   TLS provides two basic handshake modes of interest to QUIC:),
      BREAK#205,
    CONTENT#206(   *  A full 1-RTT handshake, in which the client is able to send),
    CONTENT#207(      application data after one round trip and the server immediately),
    CONTENT#208(      responds after receiving the first handshake message from the),
    CONTENT#209(      client.),
      BREAK#210,
    CONTENT#211(   *  A 0-RTT handshake, in which the client uses information it has),
    CONTENT#212(      previously learned about the server to send application data),
    CONTENT#213(      immediately.  This application data can be replayed by an),
    CONTENT#214(      attacker, so 0-RTT is not suitable for carrying instructions that),
    CONTENT#215(      might initiate any action that could cause unwanted effects if),
    CONTENT#216(      replayed.),
      BREAK#217,
    CONTENT#218(   A simplified TLS handshake with 0-RTT application data is shown in),
    CONTENT#219(   Figure 2.),
      BREAK#220,
    CONTENT#221(       Client                                             Server),
      BREAK#222,
    CONTENT#223(       ClientHello),
    CONTENT#224(      (0-RTT Application Data)  -------->),
    CONTENT#225(                                                     ServerHello),
    CONTENT#226(                                            {EncryptedExtensions}),
    CONTENT#227(                                                       {Finished}),
    CONTENT#228(                                <--------      [Application Data]),
    CONTENT#229(      {Finished}                -------->),
      BREAK#230,
    CONTENT#231(      [Application Data]        <------->      [Application Data]),
      BREAK#232,
    CONTENT#233(       () Indicates messages protected by Early Data (0-RTT) Keys),
    CONTENT#234(       {} Indicates messages protected using Handshake Keys),
    CONTENT#235(       [] Indicates messages protected using Application Data),
    CONTENT#236(          (1-RTT) Keys),
      BREAK#237,
    CONTENT#238(                     Figure 2: TLS Handshake with 0-RTT),
      BREAK#239,
    CONTENT#240(   Figure 2 omits the EndOfEarlyData message, which is not used in QUIC;),
    CONTENT#241(   see Section 8.3.  Likewise, neither ChangeCipherSpec nor KeyUpdate),
    CONTENT#242(   messages are used by QUIC.  ChangeCipherSpec is redundant in TLS 1.3;),
    CONTENT#243(   see Section 8.4.  QUIC has its own key update mechanism; see),
    CONTENT#244(   Section 6.),
      BREAK#245,
    CONTENT#246(   Data is protected using a number of encryption levels:),
      BREAK#247,
    CONTENT#248(   *  Initial keys),
      BREAK#249,
    CONTENT#250(   *  Early data (0-RTT) keys),
      BREAK#251,
    CONTENT#252(   *  Handshake keys),
      BREAK#253,
    CONTENT#254(   *  Application data (1-RTT) keys),
      BREAK#255,
    CONTENT#256(   Application data can only appear in the early data and application),
    CONTENT#257(   data levels.  Handshake and alert messages may appear in any level.),
      BREAK#258,
    CONTENT#259(   The 0-RTT handshake can be used if the client and server have),
    CONTENT#260(   previously communicated.  In the 1-RTT handshake, the client is),
    CONTENT#261(   unable to send protected application data until it has received all),
    CONTENT#262(   of the handshake messages sent by the server.),
      BREAK#263,
    SECTION#264(id=3, title=Protocol Overview),
      BREAK#265,
    CONTENT#266(   QUIC [QUIC-TRANSPORT] assumes responsibility for the confidentiality),
    CONTENT#267(   and integrity protection of packets.  For this it uses keys derived),
    CONTENT#268(   from a TLS handshake [TLS13], but instead of carrying TLS records),
    CONTENT#269(   over QUIC (as with TCP), TLS handshake and alert messages are carried),
    CONTENT#270(   directly over the QUIC transport, which takes over the),
    CONTENT#271(   responsibilities of the TLS record layer, as shown in Figure 3.),
      BREAK#272,
    CONTENT#273(   +--------------+--------------+ +-------------+),
    CONTENT#274(   |     TLS      |     TLS      | |    QUIC     |),
    CONTENT#275(   |  Handshake   |    Alerts    | | Applications|),
    CONTENT#276(   |              |              | |  (h3, etc.) |),
    CONTENT#277(   +--------------+--------------+-+-------------+),
    CONTENT#278(   |                                             |),
    CONTENT#279(   |                QUIC Transport               |),
    CONTENT#280(   |   (streams, reliability, congestion, etc.)  |),
    CONTENT#281(   |                                             |),
    CONTENT#282(   +---------------------------------------------+),
    CONTENT#283(   |                                             |),
    CONTENT#284(   |            QUIC Packet Protection           |),
    CONTENT#285(   |                                             |),
    CONTENT#286(   +---------------------------------------------+),
      BREAK#287,
    CONTENT#288(                           Figure 3: QUIC Layers),
      BREAK#289,
    CONTENT#290(   QUIC also relies on TLS for authentication and negotiation of),
    CONTENT#291(   parameters that are critical to security and performance.),
      BREAK#292,
    CONTENT#293(   Rather than a strict layering, these two protocols cooperate: QUIC),
    CONTENT#294(   uses the TLS handshake; TLS uses the reliability, ordered delivery,),
    CONTENT#295(   and record layer provided by QUIC.),
      BREAK#296,
    CONTENT#297(   At a high level, there are two main interactions between the TLS and),
    CONTENT#298(   QUIC components:),
      BREAK#299,
    CONTENT#300(   *  The TLS component sends and receives messages via the QUIC),
    CONTENT#301(      component, with QUIC providing a reliable stream abstraction to),
    CONTENT#302(      TLS.),
      BREAK#303,
    CONTENT#304(   *  The TLS component provides a series of updates to the QUIC),
    CONTENT#305(      component, including (a) new packet protection keys to install and),
    CONTENT#306(      (b) state changes such as handshake completion, the server),
    CONTENT#307(      certificate, etc.),
      BREAK#308,
    CONTENT#309(   Figure 4 shows these interactions in more detail, with the QUIC),
    CONTENT#310(   packet protection being called out specially.),
      BREAK#311,
    CONTENT#312(   +------------+                               +------------+),
    CONTENT#313(   |            |<---- Handshake Messages ----->|            |),
    CONTENT#314(   |            |<- Validate 0-RTT Parameters ->|            |),
    CONTENT#315(   |            |<--------- 0-RTT Keys ---------|            |),
    CONTENT#316(   |    QUIC    |<------- Handshake Keys -------|    TLS     |),
    CONTENT#317(   |            |<--------- 1-RTT Keys ---------|            |),
    CONTENT#318(   |            |<------- Handshake Done -------|            |),
    CONTENT#319(   +------------+                               +------------+),
    CONTENT#320(    |         ^),
    CONTENT#321(    | Protect | Protected),
    CONTENT#322(    v         | Packet),
    CONTENT#323(   +------------+),
    CONTENT#324(   |   QUIC     |),
    CONTENT#325(   |  Packet    |),
    CONTENT#326(   | Protection |),
    CONTENT#327(   +------------+),
      BREAK#328,
    CONTENT#329(                    Figure 4: QUIC and TLS Interactions),
      BREAK#330,
    CONTENT#331(   Unlike TLS over TCP, QUIC applications that want to send data do not),
    CONTENT#332(   send it using TLS Application Data records.  Rather, they send it as),
    CONTENT#333(   QUIC STREAM frames or other frame types, which are then carried in),
    CONTENT#334(   QUIC packets.),
      BREAK#335,
    SECTION#336(id=4, title=Carrying TLS Messages),
      BREAK#337,
    CONTENT#338(   QUIC carries TLS handshake data in CRYPTO frames, each of which),
    CONTENT#339(   consists of a contiguous block of handshake data identified by an),
    CONTENT#340(   offset and length.  Those frames are packaged into QUIC packets and),
    CONTENT#341(   encrypted under the current encryption level.  As with TLS over TCP,),
    CONTENT#342(   once TLS handshake data has been delivered to QUIC, it is QUIC's),
    CONTENT#343(   responsibility to deliver it reliably.  Each chunk of data that is),
    CONTENT#344(   produced by TLS is associated with the set of keys that TLS is),
    CONTENT#345(   currently using.  If QUIC needs to retransmit that data, it MUST use),
    CONTENT#346(   the same keys even if TLS has already updated to newer keys.),
      BREAK#347,
    CONTENT#348(   Each encryption level corresponds to a packet number space.  The),
    CONTENT#349(   packet number space that is used determines the semantics of frames.),
    CONTENT#350(   Some frames are prohibited in different packet number spaces; see),
    CONTENT#351(   Section 12.5 of [QUIC-TRANSPORT].),
      BREAK#352,
    CONTENT#353(   Because packets could be reordered on the wire, QUIC uses the packet),
    CONTENT#354(   type to indicate which keys were used to protect a given packet, as),
    CONTENT#355(   shown in Table 1.  When packets of different types need to be sent,),
    CONTENT#356(   endpoints SHOULD use coalesced packets to send them in the same UDP),
    CONTENT#357(   datagram.),
      BREAK#358,
    CONTENT#359(       +=====================+=================+==================+),
    CONTENT#360(       | Packet Type         | Encryption Keys | PN Space         |),
    CONTENT#361(       +=====================+=================+==================+),
    CONTENT#362(       | Initial             | Initial secrets | Initial          |),
    CONTENT#363(       +=====================+-----------------+------------------+),
    CONTENT#364(       | 0-RTT Protected     | 0-RTT           | Application data |),
    CONTENT#365(       +=====================+-----------------+------------------+),
    CONTENT#366(       | Handshake           | Handshake       | Handshake        |),
    CONTENT#367(       +=====================+-----------------+------------------+),
    CONTENT#368(       | Retry               | Retry           | N/A              |),
    CONTENT#369(       +=====================+-----------------+------------------+),
    CONTENT#370(       | Version Negotiation | N/A             | N/A              |),
    CONTENT#371(       +=====================+-----------------+------------------+),
    CONTENT#372(       | Short Header        | 1-RTT           | Application data |),
    CONTENT#373(       +=====================+-----------------+------------------+),
      BREAK#374,
    CONTENT#375(                 Table 1: Encryption Keys by Packet Type),
      BREAK#376,
    CONTENT#377(   Section 17 of [QUIC-TRANSPORT] shows how packets at the various),
    CONTENT#378(   encryption levels fit into the handshake process.),
      BREAK#379,
    SECTION#380(id=4.1, title=Interface to TLS),
      BREAK#381,
    CONTENT#382(   As shown in Figure 4, the interface from QUIC to TLS consists of four),
    CONTENT#383(   primary functions:),
      BREAK#384,
    CONTENT#385(   *  Sending and receiving handshake messages),
      BREAK#386,
    CONTENT#387(   *  Processing stored transport and application state from a resumed),
    CONTENT#388(      session and determining if it is valid to generate or accept 0-RTT),
    CONTENT#389(      data),
      BREAK#390,
    CONTENT#391(   *  Rekeying (both transmit and receive)),
      BREAK#392,
    CONTENT#393(   *  Updating handshake state),
      BREAK#394,
    CONTENT#395(   Additional functions might be needed to configure TLS.  In),
    CONTENT#396(   particular, QUIC and TLS need to agree on which is responsible for),
    CONTENT#397(   validation of peer credentials, such as certificate validation),
    CONTENT#398(   [RFC5280].),
      BREAK#399,
    SECTION#400(id=4.1.1, title=Handshake Complete),
      BREAK#401,
    CONTENT#402(   In this document, the TLS handshake is considered complete when the),
    CONTENT#403(   TLS stack has reported that the handshake is complete.  This happens),
    CONTENT#404(   when the TLS stack has both sent a Finished message and verified the),
    CONTENT#405(   peer's Finished message.  Verifying the peer's Finished message),
    CONTENT#406(   provides the endpoints with an assurance that previous handshake),
    CONTENT#407(   messages have not been modified.  Note that the handshake does not),
    CONTENT#408(   complete at both endpoints simultaneously.  Consequently, any),
    CONTENT#409(   requirement that is based on the completion of the handshake depends),
    CONTENT#410(   on the perspective of the endpoint in question.),
      BREAK#411,
    SECTION#412(id=4.1.2, title=Handshake Confirmed),
      BREAK#413,
    CONTENT#414(   In this document, the TLS handshake is considered confirmed at the),
    CONTENT#415(   server when the handshake completes.  The server MUST send a),
    CONTENT#416(   HANDSHAKE_DONE frame as soon as the handshake is complete.  At the),
    CONTENT#417(   client, the handshake is considered confirmed when a HANDSHAKE_DONE),
    CONTENT#418(   frame is received.),
      BREAK#419,
    CONTENT#420(   Additionally, a client MAY consider the handshake to be confirmed),
    CONTENT#421(   when it receives an acknowledgment for a 1-RTT packet.  This can be),
    CONTENT#422(   implemented by recording the lowest packet number sent with 1-RTT),
    CONTENT#423(   keys and comparing it to the Largest Acknowledged field in any),
    CONTENT#424(   received 1-RTT ACK frame: once the latter is greater than or equal to),
    CONTENT#425(   the former, the handshake is confirmed.),
      BREAK#426,
    SECTION#427(id=4.1.3, title=Sending and Receiving Handshake Messages),
      BREAK#428,
    CONTENT#429(   In order to drive the handshake, TLS depends on being able to send),
    CONTENT#430(   and receive handshake messages.  There are two basic functions on),
    CONTENT#431(   this interface: one where QUIC requests handshake messages and one),
    CONTENT#432(   where QUIC provides bytes that comprise handshake messages.),
      BREAK#433,
    CONTENT#434(   Before starting the handshake, QUIC provides TLS with the transport),
    CONTENT#435(   parameters (see Section 8.2) that it wishes to carry.),
      BREAK#436,
    CONTENT#437(   A QUIC client starts TLS by requesting TLS handshake bytes from TLS.),
    CONTENT#438(   The client acquires handshake bytes before sending its first packet.),
    CONTENT#439(   A QUIC server starts the process by providing TLS with the client's),
    CONTENT#440(   handshake bytes.),
      BREAK#441,
    CONTENT#442(   At any time, the TLS stack at an endpoint will have a current sending),
    CONTENT#443(   encryption level and a receiving encryption level.  TLS encryption),
    CONTENT#444(   levels determine the QUIC packet type and keys that are used for),
    CONTENT#445(   protecting data.),
      BREAK#446,
    CONTENT#447(   Each encryption level is associated with a different sequence of),
    CONTENT#448(   bytes, which is reliably transmitted to the peer in CRYPTO frames.),
    CONTENT#449(   When TLS provides handshake bytes to be sent, they are appended to),
    CONTENT#450(   the handshake bytes for the current encryption level.  The encryption),
    CONTENT#451(   level then determines the type of packet that the resulting CRYPTO),
    CONTENT#452(   frame is carried in; see Table 1.),
      BREAK#453,
    CONTENT#454(   Four encryption levels are used, producing keys for Initial, 0-RTT,),
    CONTENT#455(   Handshake, and 1-RTT packets.  CRYPTO frames are carried in just),
    CONTENT#456(   three of these levels, omitting the 0-RTT level.  These four levels),
    CONTENT#457(   correspond to three packet number spaces: Initial and Handshake),
    CONTENT#458(   encrypted packets use their own separate spaces; 0-RTT and 1-RTT),
    CONTENT#459(   packets use the application data packet number space.),
      BREAK#460,
    CONTENT#461(   QUIC takes the unprotected content of TLS handshake records as the),
    CONTENT#462(   content of CRYPTO frames.  TLS record protection is not used by QUIC.),
    CONTENT#463(   QUIC assembles CRYPTO frames into QUIC packets, which are protected),
    CONTENT#464(   using QUIC packet protection.),
      BREAK#465,
    CONTENT#466(   QUIC CRYPTO frames only carry TLS handshake messages.  TLS alerts are),
    CONTENT#467(   turned into QUIC CONNECTION_CLOSE error codes; see Section 4.8.  TLS),
    CONTENT#468(   application data and other content types cannot be carried by QUIC at),
    CONTENT#469(   any encryption level; it is an error if they are received from the),
    CONTENT#470(   TLS stack.),
      BREAK#471,
    CONTENT#472(   When an endpoint receives a QUIC packet containing a CRYPTO frame),
    CONTENT#473(   from the network, it proceeds as follows:),
      BREAK#474,
    CONTENT#475(   *  If the packet uses the current TLS receiving encryption level,),
    CONTENT#476(      sequence the data into the input flow as usual.  As with STREAM),
    CONTENT#477(      frames, the offset is used to find the proper location in the data),
    CONTENT#478(      sequence.  If the result of this process is that new data is),
    CONTENT#479(      available, then it is delivered to TLS in order.),
      BREAK#480,
    CONTENT#481(   *  If the packet is from a previously installed encryption level, it),
    CONTENT#482(      MUST NOT contain data that extends past the end of previously),
    CONTENT#483(      received data in that flow.  Implementations MUST treat any),
    CONTENT#484(      violations of this requirement as a connection error of type),
    CONTENT#485(      PROTOCOL_VIOLATION.),
      BREAK#486,
    CONTENT#487(   *  If the packet is from a new encryption level, it is saved for),
    CONTENT#488(      later processing by TLS.  Once TLS moves to receiving from this),
    CONTENT#489(      encryption level, saved data can be provided to TLS.  When TLS),
    CONTENT#490(      provides keys for a higher encryption level, if there is data from),
    CONTENT#491(      a previous encryption level that TLS has not consumed, this MUST),
    CONTENT#492(      be treated as a connection error of type PROTOCOL_VIOLATION.),
      BREAK#493,
    CONTENT#494(   Each time that TLS is provided with new data, new handshake bytes are),
    CONTENT#495(   requested from TLS.  TLS might not provide any bytes if the handshake),
    CONTENT#496(   messages it has received are incomplete or it has no data to send.),
      BREAK#497,
    CONTENT#498(   The content of CRYPTO frames might either be processed incrementally),
    CONTENT#499(   by TLS or buffered until complete messages or flights are available.),
    CONTENT#500(   TLS is responsible for buffering handshake bytes that have arrived in),
    CONTENT#501(   order.  QUIC is responsible for buffering handshake bytes that arrive),
    CONTENT#502(   out of order or for encryption levels that are not yet ready.  QUIC),
    CONTENT#503(   does not provide any means of flow control for CRYPTO frames; see),
    CONTENT#504(   Section 7.5 of [QUIC-TRANSPORT].),
      BREAK#505,
    CONTENT#506(   Once the TLS handshake is complete, this is indicated to QUIC along),
    CONTENT#507(   with any final handshake bytes that TLS needs to send.  At this),
    CONTENT#508(   stage, the transport parameters that the peer advertised during the),
    CONTENT#509(   handshake are authenticated; see Section 8.2.),
      BREAK#510,
    CONTENT#511(   Once the handshake is complete, TLS becomes passive.  TLS can still),
    CONTENT#512(   receive data from its peer and respond in kind, but it will not need),
    CONTENT#513(   to send more data unless specifically requested -- either by an),
    CONTENT#514(   application or QUIC.  One reason to send data is that the server),
    CONTENT#515(   might wish to provide additional or updated session tickets to a),
    CONTENT#516(   client.),
      BREAK#517,
    CONTENT#518(   When the handshake is complete, QUIC only needs to provide TLS with),
    CONTENT#519(   any data that arrives in CRYPTO streams.  In the same manner that is),
    CONTENT#520(   used during the handshake, new data is requested from TLS after),
    CONTENT#521(   providing received data.),
      BREAK#522,
    SECTION#523(id=4.1.4, title=Encryption Level Changes),
      BREAK#524,
    CONTENT#525(   As keys at a given encryption level become available to TLS, TLS),
    CONTENT#526(   indicates to QUIC that reading or writing keys at that encryption),
    CONTENT#527(   level are available.),
      BREAK#528,
    CONTENT#529(   The availability of new keys is always a result of providing inputs),
    CONTENT#530(   to TLS.  TLS only provides new keys after being initialized (by a),
    CONTENT#531(   client) or when provided with new handshake data.),
      BREAK#532,
    CONTENT#533(   However, a TLS implementation could perform some of its processing),
    CONTENT#534(   asynchronously.  In particular, the process of validating a),
    CONTENT#535(   certificate can take some time.  While waiting for TLS processing to),
    CONTENT#536(   complete, an endpoint SHOULD buffer received packets if they might be),
    CONTENT#537(   processed using keys that are not yet available.  These packets can),
    CONTENT#538(   be processed once keys are provided by TLS.  An endpoint SHOULD),
    CONTENT#539(   continue to respond to packets that can be processed during this),
    CONTENT#540(   time.),
      BREAK#541,
    CONTENT#542(   After processing inputs, TLS might produce handshake bytes, keys for),
    CONTENT#543(   new encryption levels, or both.),
      BREAK#544,
    CONTENT#545(   TLS provides QUIC with three items as a new encryption level becomes),
    CONTENT#546(   available:),
      BREAK#547,
    CONTENT#548(   *  A secret),
      BREAK#549,
    CONTENT#550(   *  An Authenticated Encryption with Associated Data (AEAD) function),
      BREAK#551,
    CONTENT#552(   *  A Key Derivation Function (KDF)),
      BREAK#553,
    CONTENT#554(   These values are based on the values that TLS negotiates and are used),
    CONTENT#555(   by QUIC to generate packet and header protection keys; see Section 5),
    CONTENT#556(   and Section 5.4.),
      BREAK#557,
    CONTENT#558(   If 0-RTT is possible, it is ready after the client sends a TLS),
    CONTENT#559(   ClientHello message or the server receives that message.  After),
    CONTENT#560(   providing a QUIC client with the first handshake bytes, the TLS stack),
    CONTENT#561(   might signal the change to 0-RTT keys.  On the server, after),
    CONTENT#562(   receiving handshake bytes that contain a ClientHello message, a TLS),
    CONTENT#563(   server might signal that 0-RTT keys are available.),
      BREAK#564,
    CONTENT#565(   Although TLS only uses one encryption level at a time, QUIC may use),
    CONTENT#566(   more than one level.  For instance, after sending its Finished),
    CONTENT#567(   message (using a CRYPTO frame at the Handshake encryption level) an),
    CONTENT#568(   endpoint can send STREAM data (in 1-RTT encryption).  If the Finished),
    CONTENT#569(   message is lost, the endpoint uses the Handshake encryption level to),
    CONTENT#570(   retransmit the lost message.  Reordering or loss of packets can mean),
    CONTENT#571(   that QUIC will need to handle packets at multiple encryption levels.),
    CONTENT#572(   During the handshake, this means potentially handling packets at),
    CONTENT#573(   higher and lower encryption levels than the current encryption level),
    CONTENT#574(   used by TLS.),
      BREAK#575,
    CONTENT#576(   In particular, server implementations need to be able to read packets),
    CONTENT#577(   at the Handshake encryption level at the same time as the 0-RTT),
    CONTENT#578(   encryption level.  A client could interleave ACK frames that are),
    CONTENT#579(   protected with Handshake keys with 0-RTT data, and the server needs),
    CONTENT#580(   to process those acknowledgments in order to detect lost Handshake),
    CONTENT#581(   packets.),
      BREAK#582,
    CONTENT#583(   QUIC also needs access to keys that might not ordinarily be available),
    CONTENT#584(   to a TLS implementation.  For instance, a client might need to),
    CONTENT#585(   acknowledge Handshake packets before it is ready to send CRYPTO),
    CONTENT#586(   frames at that encryption level.  TLS therefore needs to provide keys),
    CONTENT#587(   to QUIC before it might produce them for its own use.),
      BREAK#588,
    SECTION#589(id=4.1.5, title=TLS Interface Summary),
      BREAK#590,
    CONTENT#591(   Figure 5 summarizes the exchange between QUIC and TLS for both client),
    CONTENT#592(   and server.  Solid arrows indicate packets that carry handshake data;),
    CONTENT#593(   dashed arrows show where application data can be sent.  Each arrow is),
    CONTENT#594(   tagged with the encryption level used for that transmission.),
      BREAK#595,
    CONTENT#596(   Client                                                    Server),
    CONTENT#597(   ======                                                    ======),
      BREAK#598,
    CONTENT#599(   Get Handshake),
    CONTENT#600(                        Initial ------------->),
    CONTENT#601(   Install tx 0-RTT keys),
    CONTENT#602(                        0-RTT - - - - - - - ->),
      BREAK#603,
    CONTENT#604(                                                 Handshake Received),
    CONTENT#605(                                                      Get Handshake),
    CONTENT#606(                        <------------- Initial),
    CONTENT#607(                                              Install rx 0-RTT keys),
    CONTENT#608(                                             Install Handshake keys),
    CONTENT#609(                                                      Get Handshake),
    CONTENT#610(                        <----------- Handshake),
    CONTENT#611(                                              Install tx 1-RTT keys),
    CONTENT#612(                        <- - - - - - - - 1-RTT),
      BREAK#613,
    CONTENT#614(   Handshake Received (Initial)),
    CONTENT#615(   Install Handshake keys),
    CONTENT#616(   Handshake Received (Handshake)),
    CONTENT#617(   Get Handshake),
    CONTENT#618(                        Handshake ----------->),
    CONTENT#619(   Handshake Complete),
    CONTENT#620(   Install 1-RTT keys),
    CONTENT#621(                        1-RTT - - - - - - - ->),
      BREAK#622,
    CONTENT#623(                                                 Handshake Received),
    CONTENT#624(                                                 Handshake Complete),
    CONTENT#625(                                                Handshake Confirmed),
    CONTENT#626(                                              Install rx 1-RTT keys),
    CONTENT#627(                        <--------------- 1-RTT),
    CONTENT#628(                              (HANDSHAKE_DONE)),
    CONTENT#629(   Handshake Confirmed),
      BREAK#630,
    CONTENT#631(             Figure 5: Interaction Summary between QUIC and TLS),
      BREAK#632,
    CONTENT#633(   Figure 5 shows the multiple packets that form a single "flight" of),
    CONTENT#634(   messages being processed individually, to show what incoming messages),
    CONTENT#635(   trigger different actions.  This shows multiple "Get Handshake"),
    CONTENT#636(   invocations to retrieve handshake messages at different encryption),
    CONTENT#637(   levels.  New handshake messages are requested after incoming packets),
    CONTENT#638(   have been processed.),
      BREAK#639,
    CONTENT#640(   Figure 5 shows one possible structure for a simple handshake),
    CONTENT#641(   exchange.  The exact process varies based on the structure of),
    CONTENT#642(   endpoint implementations and the order in which packets arrive.),
    CONTENT#643(   Implementations could use a different number of operations or execute),
    CONTENT#644(   them in other orders.),
      BREAK#645,
    SECTION#646(id=4.2, title=TLS Version),
      BREAK#647,
    CONTENT#648(   This document describes how TLS 1.3 [TLS13] is used with QUIC.),
      BREAK#649,
    CONTENT#650(   In practice, the TLS handshake will negotiate a version of TLS to),
    CONTENT#651(   use.  This could result in a version of TLS newer than 1.3 being),
    CONTENT#652(   negotiated if both endpoints support that version.  This is),
    CONTENT#653(   acceptable provided that the features of TLS 1.3 that are used by),
    CONTENT#654(   QUIC are supported by the newer version.),
      BREAK#655,
    CONTENT#656(   Clients MUST NOT offer TLS versions older than 1.3.  A badly),
    CONTENT#657(   configured TLS implementation could negotiate TLS 1.2 or another),
    CONTENT#658(   older version of TLS.  An endpoint MUST terminate the connection if a),
    CONTENT#659(   version of TLS older than 1.3 is negotiated.),
      BREAK#660,
    SECTION#661(id=4.3, title=ClientHello Size),
      BREAK#662,
    CONTENT#663(   The first Initial packet from a client contains the start or all of),
    CONTENT#664(   its first cryptographic handshake message, which for TLS is the),
    CONTENT#665(   ClientHello.  Servers might need to parse the entire ClientHello),
    CONTENT#666(   (e.g., to access extensions such as Server Name Identification (SNI)),
    CONTENT#667(   or Application-Layer Protocol Negotiation (ALPN)) in order to decide),
    CONTENT#668(   whether to accept the new incoming QUIC connection.  If the),
    CONTENT#669(   ClientHello spans multiple Initial packets, such servers would need),
    CONTENT#670(   to buffer the first received fragments, which could consume excessive),
    CONTENT#671(   resources if the client's address has not yet been validated.  To),
    CONTENT#672(   avoid this, servers MAY use the Retry feature (see Section 8.1 of),
    CONTENT#673(   [QUIC-TRANSPORT]) to only buffer partial ClientHello messages from),
    CONTENT#674(   clients with a validated address.),
      BREAK#675,
    CONTENT#676(   QUIC packet and framing add at least 36 bytes of overhead to the),
    CONTENT#677(   ClientHello message.  That overhead increases if the client chooses a),
    CONTENT#678(   Source Connection ID field longer than zero bytes.  Overheads also do),
    CONTENT#679(   not include the token or a Destination Connection ID longer than 8),
    CONTENT#680(   bytes, both of which might be required if a server sends a Retry),
    CONTENT#681(   packet.),
      BREAK#682,
    CONTENT#683(   A typical TLS ClientHello can easily fit into a 1200-byte packet.),
    CONTENT#684(   However, in addition to the overheads added by QUIC, there are),
    CONTENT#685(   several variables that could cause this limit to be exceeded.  Large),
    CONTENT#686(   session tickets, multiple or large key shares, and long lists of),
    CONTENT#687(   supported ciphers, signature algorithms, versions, QUIC transport),
    CONTENT#688(   parameters, and other negotiable parameters and extensions could),
    CONTENT#689(   cause this message to grow.),
      BREAK#690,
    CONTENT#691(   For servers, in addition to connection IDs and tokens, the size of),
    CONTENT#692(   TLS session tickets can have an effect on a client's ability to),
    CONTENT#693(   connect efficiently.  Minimizing the size of these values increases),
    CONTENT#694(   the probability that clients can use them and still fit their entire),
    CONTENT#695(   ClientHello message in their first Initial packet.),
      BREAK#696,
    CONTENT#697(   The TLS implementation does not need to ensure that the ClientHello),
    CONTENT#698(   is large enough to meet QUIC's requirements for datagrams that carry),
    CONTENT#699(   Initial packets; see Section 14.1 of [QUIC-TRANSPORT].  QUIC),
    CONTENT#700(   implementations use PADDING frames or packet coalescing to ensure),
    CONTENT#701(   that datagrams are large enough.),
      BREAK#702,
    SECTION#703(id=4.4, title=Peer Authentication),
      BREAK#704,
    CONTENT#705(   The requirements for authentication depend on the application),
    CONTENT#706(   protocol that is in use.  TLS provides server authentication and),
    CONTENT#707(   permits the server to request client authentication.),
      BREAK#708,
    CONTENT#709(   A client MUST authenticate the identity of the server.  This),
    CONTENT#710(   typically involves verification that the identity of the server is),
    CONTENT#711(   included in a certificate and that the certificate is issued by a),
    CONTENT#712(   trusted entity (see for example [RFC2818]).),
      BREAK#713,
    CONTENT#714(      |  Note: Where servers provide certificates for authentication,),
    CONTENT#715(      |  the size of the certificate chain can consume a large number of),
    CONTENT#716(      |  bytes.  Controlling the size of certificate chains is critical),
    CONTENT#717(      |  to performance in QUIC as servers are limited to sending 3),
    CONTENT#718(      |  bytes for every byte received prior to validating the client),
    CONTENT#719(      |  address; see Section 8.1 of [QUIC-TRANSPORT].  The size of a),
    CONTENT#720(      |  certificate chain can be managed by limiting the number of),
    CONTENT#721(      |  names or extensions; using keys with small public key),
    CONTENT#722(      |  representations, like ECDSA; or by using certificate),
    CONTENT#723(      |  compression [COMPRESS].),
      BREAK#724,
    CONTENT#725(   A server MAY request that the client authenticate during the),
    CONTENT#726(   handshake.  A server MAY refuse a connection if the client is unable),
    CONTENT#727(   to authenticate when requested.  The requirements for client),
    CONTENT#728(   authentication vary based on application protocol and deployment.),
      BREAK#729,
    CONTENT#730(   A server MUST NOT use post-handshake client authentication (as),
    CONTENT#731(   defined in Section 4.6.2 of [TLS13]) because the multiplexing offered),
    CONTENT#732(   by QUIC prevents clients from correlating the certificate request),
    CONTENT#733(   with the application-level event that triggered it (see),
    CONTENT#734(   [HTTP2-TLS13]).  More specifically, servers MUST NOT send post-),
    CONTENT#735(   handshake TLS CertificateRequest messages, and clients MUST treat),
    CONTENT#736(   receipt of such messages as a connection error of type),
    CONTENT#737(   PROTOCOL_VIOLATION.),
      BREAK#738,
    SECTION#739(id=4.5, title=Session Resumption),
      BREAK#740,
    CONTENT#741(   QUIC can use the session resumption feature of TLS 1.3.  It does this),
    CONTENT#742(   by carrying NewSessionTicket messages in CRYPTO frames after the),
    CONTENT#743(   handshake is complete.  Session resumption can be used to provide),
    CONTENT#744(   0-RTT and can also be used when 0-RTT is disabled.),
      BREAK#745,
    CONTENT#746(   Endpoints that use session resumption might need to remember some),
    CONTENT#747(   information about the current connection when creating a resumed),
    CONTENT#748(   connection.  TLS requires that some information be retained; see),
    CONTENT#749(   Section 4.6.1 of [TLS13].  QUIC itself does not depend on any state),
    CONTENT#750(   being retained when resuming a connection unless 0-RTT is also used;),
    CONTENT#751(   see Section 7.4.1 of [QUIC-TRANSPORT] and Section 4.6.1.  Application),
    CONTENT#752(   protocols could depend on state that is retained between resumed),
    CONTENT#753(   connections.),
      BREAK#754,
    CONTENT#755(   Clients can store any state required for resumption along with the),
    CONTENT#756(   session ticket.  Servers can use the session ticket to help carry),
    CONTENT#757(   state.),
      BREAK#758,
    CONTENT#759(   Session resumption allows servers to link activity on the original),
    CONTENT#760(   connection with the resumed connection, which might be a privacy),
    CONTENT#761(   issue for clients.  Clients can choose not to enable resumption to),
    CONTENT#762(   avoid creating this correlation.  Clients SHOULD NOT reuse tickets as),
    CONTENT#763(   that allows entities other than the server to correlate connections;),
    CONTENT#764(   see Appendix C.4 of [TLS13].),
      BREAK#765,
    SECTION#766(id=4.6, title=0-RTT),
      BREAK#767,
    CONTENT#768(   The 0-RTT feature in QUIC allows a client to send application data),
    CONTENT#769(   before the handshake is complete.  This is made possible by reusing),
    CONTENT#770(   negotiated parameters from a previous connection.  To enable this,),
    CONTENT#771(   0-RTT depends on the client remembering critical parameters and),
    CONTENT#772(   providing the server with a TLS session ticket that allows the server),
    CONTENT#773(   to recover the same information.),
      BREAK#774,
    CONTENT#775(   This information includes parameters that determine TLS state, as),
    CONTENT#776(   governed by [TLS13], QUIC transport parameters, the chosen),
    CONTENT#777(   application protocol, and any information the application protocol),
    CONTENT#778(   might need; see Section 4.6.3.  This information determines how 0-RTT),
    CONTENT#779(   packets and their contents are formed.),
      BREAK#780,
    CONTENT#781(   To ensure that the same information is available to both endpoints,),
    CONTENT#782(   all information used to establish 0-RTT comes from the same),
    CONTENT#783(   connection.  Endpoints cannot selectively disregard information that),
    CONTENT#784(   might alter the sending or processing of 0-RTT.),
      BREAK#785,
    CONTENT#786(   [TLS13] sets a limit of seven days on the time between the original),
    CONTENT#787(   connection and any attempt to use 0-RTT.  There are other constraints),
    CONTENT#788(   on 0-RTT usage, notably those caused by the potential exposure to),
    CONTENT#789(   replay attack; see Section 9.2.),
      BREAK#790,
    SECTION#791(id=4.6.1, title=Enabling 0-RTT),
      BREAK#792,
    CONTENT#793(   The TLS early_data extension in the NewSessionTicket message is),
    CONTENT#794(   defined to convey (in the max_early_data_size parameter) the amount),
    CONTENT#795(   of TLS 0-RTT data the server is willing to accept.  QUIC does not use),
    CONTENT#796(   TLS early data.  QUIC uses 0-RTT packets to carry early data.),
    CONTENT#797(   Accordingly, the max_early_data_size parameter is repurposed to hold),
    CONTENT#798(   a sentinel value 0xffffffff to indicate that the server is willing to),
    CONTENT#799(   accept QUIC 0-RTT data.  To indicate that the server does not accept),
    CONTENT#800(   0-RTT data, the early_data extension is omitted from the),
    CONTENT#801(   NewSessionTicket.  The amount of data that the client can send in),
    CONTENT#802(   QUIC 0-RTT is controlled by the initial_max_data transport parameter),
    CONTENT#803(   supplied by the server.),
      BREAK#804,
    CONTENT#805(   Servers MUST NOT send the early_data extension with a),
    CONTENT#806(   max_early_data_size field set to any value other than 0xffffffff.  A),
    CONTENT#807(   client MUST treat receipt of a NewSessionTicket that contains an),
    CONTENT#808(   early_data extension with any other value as a connection error of),
    CONTENT#809(   type PROTOCOL_VIOLATION.),
      BREAK#810,
    CONTENT#811(   A client that wishes to send 0-RTT packets uses the early_data),
    CONTENT#812(   extension in the ClientHello message of a subsequent handshake; see),
    CONTENT#813(   Section 4.2.10 of [TLS13].  It then sends application data in 0-RTT),
    CONTENT#814(   packets.),
      BREAK#815,
    CONTENT#816(   A client that attempts 0-RTT might also provide an address validation),
    CONTENT#817(   token if the server has sent a NEW_TOKEN frame; see Section 8.1 of),
    CONTENT#818(   [QUIC-TRANSPORT].),
      BREAK#819,
    SECTION#820(id=4.6.2, title=Accepting and Rejecting 0-RTT),
      BREAK#821,
    CONTENT#822(   A server accepts 0-RTT by sending an early_data extension in the),
    CONTENT#823(   EncryptedExtensions; see Section 4.2.10 of [TLS13].  The server then),
    CONTENT#824(   processes and acknowledges the 0-RTT packets that it receives.),
      BREAK#825,
    CONTENT#826(   A server rejects 0-RTT by sending the EncryptedExtensions without an),
    CONTENT#827(   early_data extension.  A server will always reject 0-RTT if it sends),
    CONTENT#828(   a TLS HelloRetryRequest.  When rejecting 0-RTT, a server MUST NOT),
    CONTENT#829(   process any 0-RTT packets, even if it could.  When 0-RTT was),
    CONTENT#830(   rejected, a client SHOULD treat receipt of an acknowledgment for a),
    CONTENT#831(   0-RTT packet as a connection error of type PROTOCOL_VIOLATION, if it),
    CONTENT#832(   is able to detect the condition.),
      BREAK#833,
    CONTENT#834(   When 0-RTT is rejected, all connection characteristics that the),
    CONTENT#835(   client assumed might be incorrect.  This includes the choice of),
    CONTENT#836(   application protocol, transport parameters, and any application),
    CONTENT#837(   configuration.  The client therefore MUST reset the state of all),
    CONTENT#838(   streams, including application state bound to those streams.),
      BREAK#839,
    CONTENT#840(   A client MAY reattempt 0-RTT if it receives a Retry or Version),
    CONTENT#841(   Negotiation packet.  These packets do not signify rejection of 0-RTT.),
      BREAK#842,
    SECTION#843(id=4.6.3, title=Validating 0-RTT Configuration),
      BREAK#844,
    CONTENT#845(   When a server receives a ClientHello with the early_data extension,),
    CONTENT#846(   it has to decide whether to accept or reject 0-RTT data from the),
    CONTENT#847(   client.  Some of this decision is made by the TLS stack (e.g.,),
    CONTENT#848(   checking that the cipher suite being resumed was included in the),
    CONTENT#849(   ClientHello; see Section 4.2.10 of [TLS13]).  Even when the TLS stack),
    CONTENT#850(   has no reason to reject 0-RTT data, the QUIC stack or the application),
    CONTENT#851(   protocol using QUIC might reject 0-RTT data because the configuration),
    CONTENT#852(   of the transport or application associated with the resumed session),
    CONTENT#853(   is not compatible with the server's current configuration.),
      BREAK#854,
    CONTENT#855(   QUIC requires additional transport state to be associated with a),
    CONTENT#856(   0-RTT session ticket.  One common way to implement this is using),
    CONTENT#857(   stateless session tickets and storing this state in the session),
    CONTENT#858(   ticket.  Application protocols that use QUIC might have similar),
    CONTENT#859(   requirements regarding associating or storing state.  This associated),
    CONTENT#860(   state is used for deciding whether 0-RTT data must be rejected.  For),
    CONTENT#861(   example, HTTP/3 settings [QUIC-HTTP] determine how 0-RTT data from),
    CONTENT#862(   the client is interpreted.  Other applications using QUIC could have),
    CONTENT#863(   different requirements for determining whether to accept or reject),
    CONTENT#864(   0-RTT data.),
      BREAK#865,
    SECTION#866(id=4.7, title=HelloRetryRequest),
      BREAK#867,
    CONTENT#868(   The HelloRetryRequest message (see Section 4.1.4 of [TLS13]) can be),
    CONTENT#869(   used to request that a client provide new information, such as a key),
    CONTENT#870(   share, or to validate some characteristic of the client.  From the),
    CONTENT#871(   perspective of QUIC, HelloRetryRequest is not differentiated from),
    CONTENT#872(   other cryptographic handshake messages that are carried in Initial),
    CONTENT#873(   packets.  Although it is in principle possible to use this feature),
    CONTENT#874(   for address verification, QUIC implementations SHOULD instead use the),
    CONTENT#875(   Retry feature; see Section 8.1 of [QUIC-TRANSPORT].),
      BREAK#876,
    SECTION#877(id=4.8, title=TLS Errors),
      BREAK#878,
    CONTENT#879(   If TLS experiences an error, it generates an appropriate alert as),
    CONTENT#880(   defined in Section 6 of [TLS13].),
      BREAK#881,
    CONTENT#882(   A TLS alert is converted into a QUIC connection error.  The),
    CONTENT#883(   AlertDescription value is added to 0x0100 to produce a QUIC error),
    CONTENT#884(   code from the range reserved for CRYPTO_ERROR; see Section 20.1 of),
    CONTENT#885(   [QUIC-TRANSPORT].  The resulting value is sent in a QUIC),
    CONTENT#886(   CONNECTION_CLOSE frame of type 0x1c.),
      BREAK#887,
    CONTENT#888(   QUIC is only able to convey an alert level of "fatal".  In TLS 1.3,),
    CONTENT#889(   the only existing uses for the "warning" level are to signal),
    CONTENT#890(   connection close; see Section 6.1 of [TLS13].  As QUIC provides),
    CONTENT#891(   alternative mechanisms for connection termination and the TLS),
    CONTENT#892(   connection is only closed if an error is encountered, a QUIC endpoint),
    CONTENT#893(   MUST treat any alert from TLS as if it were at the "fatal" level.),
      BREAK#894,
    CONTENT#895(   QUIC permits the use of a generic code in place of a specific error),
    CONTENT#896(   code; see Section 11 of [QUIC-TRANSPORT].  For TLS alerts, this),
    CONTENT#897(   includes replacing any alert with a generic alert, such as),
    CONTENT#898(   handshake_failure (0x0128 in QUIC).  Endpoints MAY use a generic),
    CONTENT#899(   error code to avoid possibly exposing confidential information.),
      BREAK#900,
    SECTION#901(id=4.9, title=Discarding Unused Keys),
      BREAK#902,
    CONTENT#903(   After QUIC has completed a move to a new encryption level, packet),
    CONTENT#904(   protection keys for previous encryption levels can be discarded.),
    CONTENT#905(   This occurs several times during the handshake, as well as when keys),
    CONTENT#906(   are updated; see Section 6.),
      BREAK#907,
    CONTENT#908(   Packet protection keys are not discarded immediately when new keys),
    CONTENT#909(   are available.  If packets from a lower encryption level contain),
    CONTENT#910(   CRYPTO frames, frames that retransmit that data MUST be sent at the),
    CONTENT#911(   same encryption level.  Similarly, an endpoint generates),
    CONTENT#912(   acknowledgments for packets at the same encryption level as the),
    CONTENT#913(   packet being acknowledged.  Thus, it is possible that keys for a),
    CONTENT#914(   lower encryption level are needed for a short time after keys for a),
    CONTENT#915(   newer encryption level are available.),
      BREAK#916,
    CONTENT#917(   An endpoint cannot discard keys for a given encryption level unless),
    CONTENT#918(   it has received all the cryptographic handshake messages from its),
    CONTENT#919(   peer at that encryption level and its peer has done the same.),
    CONTENT#920(   Different methods for determining this are provided for Initial keys),
    CONTENT#921(   (Section 4.9.1) and Handshake keys (Section 4.9.2).  These methods do),
    CONTENT#922(   not prevent packets from being received or sent at that encryption),
    CONTENT#923(   level because a peer might not have received all the acknowledgments),
    CONTENT#924(   necessary.),
      BREAK#925,
    CONTENT#926(   Though an endpoint might retain older keys, new data MUST be sent at),
    CONTENT#927(   the highest currently available encryption level.  Only ACK frames),
    CONTENT#928(   and retransmissions of data in CRYPTO frames are sent at a previous),
    CONTENT#929(   encryption level.  These packets MAY also include PADDING frames.),
      BREAK#930,
    SECTION#931(id=4.9.1, title=Discarding Initial Keys),
      BREAK#932,
    CONTENT#933(   Packets protected with Initial secrets (Section 5.2) are not),
    CONTENT#934(   authenticated, meaning that an attacker could spoof packets with the),
    CONTENT#935(   intent to disrupt a connection.  To limit these attacks, Initial),
    CONTENT#936(   packet protection keys are discarded more aggressively than other),
    CONTENT#937(   keys.),
      BREAK#938,
    CONTENT#939(   The successful use of Handshake packets indicates that no more),
    CONTENT#940(   Initial packets need to be exchanged, as these keys can only be),
    CONTENT#941(   produced after receiving all CRYPTO frames from Initial packets.),
    CONTENT#942(   Thus, a client MUST discard Initial keys when it first sends a),
    CONTENT#943(   Handshake packet and a server MUST discard Initial keys when it first),
    CONTENT#944(   successfully processes a Handshake packet.  Endpoints MUST NOT send),
    CONTENT#945(   Initial packets after this point.),
      BREAK#946,
    CONTENT#947(   This results in abandoning loss recovery state for the Initial),
    CONTENT#948(   encryption level and ignoring any outstanding Initial packets.),
      BREAK#949,
    SECTION#950(id=4.9.2, title=Discarding Handshake Keys),
      BREAK#951,
    CONTENT#952(   An endpoint MUST discard its Handshake keys when the TLS handshake is),
    CONTENT#953(   confirmed (Section 4.1.2).),
      BREAK#954,
    SECTION#955(id=4.9.3, title=Discarding 0-RTT Keys),
      BREAK#956,
    CONTENT#957(   0-RTT and 1-RTT packets share the same packet number space, and),
    CONTENT#958(   clients do not send 0-RTT packets after sending a 1-RTT packet),
    CONTENT#959(   (Section 5.6).),
      BREAK#960,
    CONTENT#961(   Therefore, a client SHOULD discard 0-RTT keys as soon as it installs),
    CONTENT#962(   1-RTT keys as they have no use after that moment.),
      BREAK#963,
    CONTENT#964(   Additionally, a server MAY discard 0-RTT keys as soon as it receives),
    CONTENT#965(   a 1-RTT packet.  However, due to packet reordering, a 0-RTT packet),
    CONTENT#966(   could arrive after a 1-RTT packet.  Servers MAY temporarily retain),
    CONTENT#967(   0-RTT keys to allow decrypting reordered packets without requiring),
    CONTENT#968(   their contents to be retransmitted with 1-RTT keys.  After receiving),
    CONTENT#969(   a 1-RTT packet, servers MUST discard 0-RTT keys within a short time;),
    CONTENT#970(   the RECOMMENDED time period is three times the Probe Timeout (PTO,),
    CONTENT#971(   see [QUIC-RECOVERY]).  A server MAY discard 0-RTT keys earlier if it),
    CONTENT#972(   determines that it has received all 0-RTT packets, which can be done),
    CONTENT#973(   by keeping track of missing packet numbers.),
      BREAK#974,
    SECTION#975(id=5, title=Packet Protection),
      BREAK#976,
    CONTENT#977(   As with TLS over TCP, QUIC protects packets with keys derived from),
    CONTENT#978(   the TLS handshake, using the AEAD algorithm [AEAD] negotiated by TLS.),
      BREAK#979,
    CONTENT#980(   QUIC packets have varying protections depending on their type:),
      BREAK#981,
    CONTENT#982(   *  Version Negotiation packets have no cryptographic protection.),
      BREAK#983,
    CONTENT#984(   *  Retry packets use AEAD_AES_128_GCM to provide protection against),
    CONTENT#985(      accidental modification and to limit the entities that can produce),
    CONTENT#986(      a valid Retry; see Section 5.8.),
      BREAK#987,
    CONTENT#988(   *  Initial packets use AEAD_AES_128_GCM with keys derived from the),
    CONTENT#989(      Destination Connection ID field of the first Initial packet sent),
    CONTENT#990(      by the client; see Section 5.2.),
      BREAK#991,
    CONTENT#992(   *  All other packets have strong cryptographic protections for),
    CONTENT#993(      confidentiality and integrity, using keys and algorithms),
    CONTENT#994(      negotiated by TLS.),
      BREAK#995,
    CONTENT#996(   This section describes how packet protection is applied to Handshake),
    CONTENT#997(   packets, 0-RTT packets, and 1-RTT packets.  The same packet),
    CONTENT#998(   protection process is applied to Initial packets.  However, as it is),
    CONTENT#999(   trivial to determine the keys used for Initial packets, these packets),
    CONTENT#1000(   are not considered to have confidentiality or integrity protection.),
    CONTENT#1001(   Retry packets use a fixed key and so similarly lack confidentiality),
    CONTENT#1002(   and integrity protection.),
      BREAK#1003,
    SECTION#1004(id=5.1, title=Packet Protection Keys),
      BREAK#1005,
    CONTENT#1006(   QUIC derives packet protection keys in the same way that TLS derives),
    CONTENT#1007(   record protection keys.),
      BREAK#1008,
    CONTENT#1009(   Each encryption level has separate secret values for protection of),
    CONTENT#1010(   packets sent in each direction.  These traffic secrets are derived by),
    CONTENT#1011(   TLS (see Section 7.1 of [TLS13]) and are used by QUIC for all),
    CONTENT#1012(   encryption levels except the Initial encryption level.  The secrets),
    CONTENT#1013(   for the Initial encryption level are computed based on the client's),
    CONTENT#1014(   initial Destination Connection ID, as described in Section 5.2.),
      BREAK#1015,
    CONTENT#1016(   The keys used for packet protection are computed from the TLS secrets),
    CONTENT#1017(   using the KDF provided by TLS.  In TLS 1.3, the HKDF-Expand-Label),
    CONTENT#1018(   function described in Section 7.1 of [TLS13] is used with the hash),
    CONTENT#1019(   function from the negotiated cipher suite.  All uses of HKDF-Expand-),
    CONTENT#1020(   Label in QUIC use a zero-length Context.),
      BREAK#1021,
    CONTENT#1022(   Note that labels, which are described using strings, are encoded as),
    CONTENT#1023(   bytes using ASCII [ASCII] without quotes or any trailing NUL byte.),
      BREAK#1024,
    CONTENT#1025(   Other versions of TLS MUST provide a similar function in order to be),
    CONTENT#1026(   used with QUIC.),
      BREAK#1027,
    CONTENT#1028(   The current encryption level secret and the label "quic key" are),
    CONTENT#1029(   input to the KDF to produce the AEAD key; the label "quic iv" is used),
    CONTENT#1030(   to derive the Initialization Vector (IV); see Section 5.3.  The),
    CONTENT#1031(   header protection key uses the "quic hp" label; see Section 5.4.),
    CONTENT#1032(   Using these labels provides key separation between QUIC and TLS; see),
    CONTENT#1033(   Section 9.6.),
      BREAK#1034,
    CONTENT#1035(   Both "quic key" and "quic hp" are used to produce keys, so the Length),
    CONTENT#1036(   provided to HKDF-Expand-Label along with these labels is determined),
    CONTENT#1037(   by the size of keys in the AEAD or header protection algorithm.  The),
    CONTENT#1038(   Length provided with "quic iv" is the minimum length of the AEAD),
    CONTENT#1039(   nonce or 8 bytes if that is larger; see [AEAD].),
      BREAK#1040,
    CONTENT#1041(   The KDF used for initial secrets is always the HKDF-Expand-Label),
    CONTENT#1042(   function from TLS 1.3; see Section 5.2.),
      BREAK#1043,
    SECTION#1044(id=5.2, title=Initial Secrets),
      BREAK#1045,
    CONTENT#1046(   Initial packets apply the packet protection process, but use a secret),
    CONTENT#1047(   derived from the Destination Connection ID field from the client's),
    CONTENT#1048(   first Initial packet.),
      BREAK#1049,
    CONTENT#1050(   This secret is determined by using HKDF-Extract (see Section 2.2 of),
    CONTENT#1051(   [HKDF]) with a salt of 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a and),
    CONTENT#1052(   the input keying material (IKM) of the Destination Connection ID),
    CONTENT#1053(   field.  This produces an intermediate pseudorandom key (PRK) that is),
    CONTENT#1054(   used to derive two separate secrets for sending and receiving.),
      BREAK#1055,
    CONTENT#1056(   The secret used by clients to construct Initial packets uses the PRK),
    CONTENT#1057(   and the label "client in" as input to the HKDF-Expand-Label function),
    CONTENT#1058(   from TLS [TLS13] to produce a 32-byte secret.  Packets constructed by),
    CONTENT#1059(   the server use the same process with the label "server in".  The hash),
    CONTENT#1060(   function for HKDF when deriving initial secrets and keys is SHA-256),
    CONTENT#1061(   [SHA].),
      BREAK#1062,
    CONTENT#1063(   This process in pseudocode is:),
      BREAK#1064,
    CONTENT#1065(   initial_salt = 0x38762cf7f55934b34d179ae6a4c80cadccbb7f0a),
    CONTENT#1066(   initial_secret = HKDF-Extract(initial_salt,),
    CONTENT#1067(                                 client_dst_connection_id)),
      BREAK#1068,
    CONTENT#1069(   client_initial_secret = HKDF-Expand-Label(initial_secret,),
    CONTENT#1070(                                             "client in", "",),
    CONTENT#1071(                                             Hash.length)),
    CONTENT#1072(   server_initial_secret = HKDF-Expand-Label(initial_secret,),
    CONTENT#1073(                                             "server in", "",),
    CONTENT#1074(                                             Hash.length)),
      BREAK#1075,
    CONTENT#1076(   The connection ID used with HKDF-Expand-Label is the Destination),
    CONTENT#1077(   Connection ID in the Initial packet sent by the client.  This will be),
    CONTENT#1078(   a randomly selected value unless the client creates the Initial),
    CONTENT#1079(   packet after receiving a Retry packet, where the Destination),
    CONTENT#1080(   Connection ID is selected by the server.),
      BREAK#1081,
    CONTENT#1082(   Future versions of QUIC SHOULD generate a new salt value, thus),
    CONTENT#1083(   ensuring that the keys are different for each version of QUIC.  This),
    CONTENT#1084(   prevents a middlebox that recognizes only one version of QUIC from),
    CONTENT#1085(   seeing or modifying the contents of packets from future versions.),
      BREAK#1086,
    CONTENT#1087(   The HKDF-Expand-Label function defined in TLS 1.3 MUST be used for),
    CONTENT#1088(   Initial packets even where the TLS versions offered do not include),
    CONTENT#1089(   TLS 1.3.),
      BREAK#1090,
    CONTENT#1091(   The secrets used for constructing subsequent Initial packets change),
    CONTENT#1092(   when a server sends a Retry packet to use the connection ID value),
    CONTENT#1093(   selected by the server.  The secrets do not change when a client),
    CONTENT#1094(   changes the Destination Connection ID it uses in response to an),
    CONTENT#1095(   Initial packet from the server.),
      BREAK#1096,
    CONTENT#1097(      |  Note: The Destination Connection ID field could be any length),
    CONTENT#1098(      |  up to 20 bytes, including zero length if the server sends a),
    CONTENT#1099(      |  Retry packet with a zero-length Source Connection ID field.),
    CONTENT#1100(      |  After a Retry, the Initial keys provide the client no assurance),
    CONTENT#1101(      |  that the server received its packet, so the client has to rely),
    CONTENT#1102(      |  on the exchange that included the Retry packet to validate the),
    CONTENT#1103(      |  server address; see Section 8.1 of [QUIC-TRANSPORT].),
      BREAK#1104,
    CONTENT#1105(   Appendix A contains sample Initial packets.),
      BREAK#1106,
    SECTION#1107(id=5.3, title=AEAD Usage),
      BREAK#1108,
    CONTENT#1109(   The Authenticated Encryption with Associated Data (AEAD) function),
    CONTENT#1110(   (see [AEAD]) used for QUIC packet protection is the AEAD that is),
    CONTENT#1111(   negotiated for use with the TLS connection.  For example, if TLS is),
    CONTENT#1112(   using the TLS_AES_128_GCM_SHA256 cipher suite, the AEAD_AES_128_GCM),
    CONTENT#1113(   function is used.),
      BREAK#1114,
    CONTENT#1115(   QUIC can use any of the cipher suites defined in [TLS13] with the),
    CONTENT#1116(   exception of TLS_AES_128_CCM_8_SHA256.  A cipher suite MUST NOT be),
    CONTENT#1117(   negotiated unless a header protection scheme is defined for the),
    CONTENT#1118(   cipher suite.  This document defines a header protection scheme for),
    CONTENT#1119(   all cipher suites defined in [TLS13] aside from),
    CONTENT#1120(   TLS_AES_128_CCM_8_SHA256.  These cipher suites have a 16-byte),
    CONTENT#1121(   authentication tag and produce an output 16 bytes larger than their),
    CONTENT#1122(   input.),
      BREAK#1123,
    CONTENT#1124(   An endpoint MUST NOT reject a ClientHello that offers a cipher suite),
    CONTENT#1125(   that it does not support, or it would be impossible to deploy a new),
    CONTENT#1126(   cipher suite.  This also applies to TLS_AES_128_CCM_8_SHA256.),
      BREAK#1127,
    CONTENT#1128(   When constructing packets, the AEAD function is applied prior to),
    CONTENT#1129(   applying header protection; see Section 5.4.  The unprotected packet),
    CONTENT#1130(   header is part of the associated data (A).  When processing packets,),
    CONTENT#1131(   an endpoint first removes the header protection.),
      BREAK#1132,
    CONTENT#1133(   The key and IV for the packet are computed as described in),
    CONTENT#1134(   Section 5.1.  The nonce, N, is formed by combining the packet),
    CONTENT#1135(   protection IV with the packet number.  The 62 bits of the),
    CONTENT#1136(   reconstructed QUIC packet number in network byte order are left-),
    CONTENT#1137(   padded with zeros to the size of the IV.  The exclusive OR of the),
    CONTENT#1138(   padded packet number and the IV forms the AEAD nonce.),
      BREAK#1139,
    CONTENT#1140(   The associated data, A, for the AEAD is the contents of the QUIC),
    CONTENT#1141(   header, starting from the first byte of either the short or long),
    CONTENT#1142(   header, up to and including the unprotected packet number.),
      BREAK#1143,
    CONTENT#1144(   The input plaintext, P, for the AEAD is the payload of the QUIC),
    CONTENT#1145(   packet, as described in [QUIC-TRANSPORT].),
      BREAK#1146,
    CONTENT#1147(   The output ciphertext, C, of the AEAD is transmitted in place of P.),
      BREAK#1148,
    CONTENT#1149(   Some AEAD functions have limits for how many packets can be encrypted),
    CONTENT#1150(   under the same key and IV; see Section 6.6.  This might be lower than),
    CONTENT#1151(   the packet number limit.  An endpoint MUST initiate a key update),
    CONTENT#1152(   (Section 6) prior to exceeding any limit set for the AEAD that is in),
    CONTENT#1153(   use.),
      BREAK#1154,
    SECTION#1155(id=5.4, title=Header Protection),
      BREAK#1156,
    CONTENT#1157(   Parts of QUIC packet headers, in particular the Packet Number field,),
    CONTENT#1158(   are protected using a key that is derived separately from the packet),
    CONTENT#1159(   protection key and IV.  The key derived using the "quic hp" label is),
    CONTENT#1160(   used to provide confidentiality protection for those fields that are),
    CONTENT#1161(   not exposed to on-path elements.),
      BREAK#1162,
    CONTENT#1163(   This protection applies to the least significant bits of the first),
    CONTENT#1164(   byte, plus the Packet Number field.  The four least significant bits),
    CONTENT#1165(   of the first byte are protected for packets with long headers; the),
    CONTENT#1166(   five least significant bits of the first byte are protected for),
    CONTENT#1167(   packets with short headers.  For both header forms, this covers the),
    CONTENT#1168(   reserved bits and the Packet Number Length field; the Key Phase bit),
    CONTENT#1169(   is also protected for packets with a short header.),
      BREAK#1170,
    CONTENT#1171(   The same header protection key is used for the duration of the),
    CONTENT#1172(   connection, with the value not changing after a key update (see),
    CONTENT#1173(   Section 6).  This allows header protection to be used to protect the),
    CONTENT#1174(   key phase.),
      BREAK#1175,
    CONTENT#1176(   This process does not apply to Retry or Version Negotiation packets,),
    CONTENT#1177(   which do not contain a protected payload or any of the fields that),
    CONTENT#1178(   are protected by this process.),
      BREAK#1179,
    SECTION#1180(id=5.4.1, title=Header Protection Application),
      BREAK#1181,
    CONTENT#1182(   Header protection is applied after packet protection is applied (see),
    CONTENT#1183(   Section 5.3).  The ciphertext of the packet is sampled and used as),
    CONTENT#1184(   input to an encryption algorithm.  The algorithm used depends on the),
    CONTENT#1185(   negotiated AEAD.),
      BREAK#1186,
    CONTENT#1187(   The output of this algorithm is a 5-byte mask that is applied to the),
    CONTENT#1188(   protected header fields using exclusive OR.  The least significant),
    CONTENT#1189(   bits of the first byte of the packet are masked by the least),
    CONTENT#1190(   significant bits of the first mask byte, and the packet number is),
    CONTENT#1191(   masked with the remaining bytes.  Any unused bytes of mask that might),
    CONTENT#1192(   result from a shorter packet number encoding are unused.),
      BREAK#1193,
    CONTENT#1194(   Figure 6 shows a sample algorithm for applying header protection.),
    CONTENT#1195(   Removing header protection only differs in the order in which the),
    CONTENT#1196(   packet number length (pn_length) is determined (here "^" is used to),
    CONTENT#1197(   represent exclusive OR).),
      BREAK#1198,
    CONTENT#1199(   mask = header_protection(hp_key, sample)),
      BREAK#1200,
    CONTENT#1201(   pn_length = (packet[0] & 0x03) + 1),
    CONTENT#1202(   if (packet[0] & 0x80) == 0x80:),
    CONTENT#1203(      # Long header: 4 bits masked),
    CONTENT#1204(      packet[0] ^= mask[0] & 0x0f),
    CONTENT#1205(   else:),
    CONTENT#1206(      # Short header: 5 bits masked),
    CONTENT#1207(      packet[0] ^= mask[0] & 0x1f),
      BREAK#1208,
    CONTENT#1209(   # pn_offset is the start of the Packet Number field.),
    CONTENT#1210(   packet[pn_offset:pn_offset+pn_length] ^= mask[1:1+pn_length]),
      BREAK#1211,
    CONTENT#1212(                   Figure 6: Header Protection Pseudocode),
      BREAK#1213,
    CONTENT#1214(   Specific header protection functions are defined based on the),
    CONTENT#1215(   selected cipher suite; see Section 5.4.3 and Section 5.4.4.),
      BREAK#1216,
    CONTENT#1217(   Figure 7 shows an example long header packet (Initial) and a short),
    CONTENT#1218(   header packet (1-RTT).  Figure 7 shows the fields in each header that),
    CONTENT#1219(   are covered by header protection and the portion of the protected),
    CONTENT#1220(   packet payload that is sampled.),
      BREAK#1221,
    CONTENT#1222(   Initial Packet {),
    CONTENT#1223(     Header Form (1) = 1,),
    CONTENT#1224(     Fixed Bit (1) = 1,),
    CONTENT#1225(     Long Packet Type (2) = 0,),
    CONTENT#1226(     Reserved Bits (2),         # Protected),
    CONTENT#1227(     Packet Number Length (2),  # Protected),
    CONTENT#1228(     Version (32),),
    CONTENT#1229(     DCID Len (8),),
    CONTENT#1230(     Destination Connection ID (0..160),),
    CONTENT#1231(     SCID Len (8),),
    CONTENT#1232(     Source Connection ID (0..160),),
    CONTENT#1233(     Token Length (i),),
    CONTENT#1234(     Token (..),),
    CONTENT#1235(     Length (i),),
    CONTENT#1236(     Packet Number (8..32),     # Protected),
    CONTENT#1237(     Protected Payload (0..24), # Skipped Part),
    CONTENT#1238(     Protected Payload (128),   # Sampled Part),
    CONTENT#1239(     Protected Payload (..)     # Remainder),
    CONTENT#1240(   }),
      BREAK#1241,
    CONTENT#1242(   1-RTT Packet {),
    CONTENT#1243(     Header Form (1) = 0,),
    CONTENT#1244(     Fixed Bit (1) = 1,),
    CONTENT#1245(     Spin Bit (1),),
    CONTENT#1246(     Reserved Bits (2),         # Protected),
    CONTENT#1247(     Key Phase (1),             # Protected),
    CONTENT#1248(     Packet Number Length (2),  # Protected),
    CONTENT#1249(     Destination Connection ID (0..160),),
    CONTENT#1250(     Packet Number (8..32),     # Protected),
    CONTENT#1251(     Protected Payload (0..24), # Skipped Part),
    CONTENT#1252(     Protected Payload (128),   # Sampled Part),
    CONTENT#1253(     Protected Payload (..),    # Remainder),
    CONTENT#1254(   }),
      BREAK#1255,
    CONTENT#1256(             Figure 7: Header Protection and Ciphertext Sample),
      BREAK#1257,
    CONTENT#1258(   Before a TLS cipher suite can be used with QUIC, a header protection),
    CONTENT#1259(   algorithm MUST be specified for the AEAD used with that cipher suite.),
    CONTENT#1260(   This document defines algorithms for AEAD_AES_128_GCM,),
    CONTENT#1261(   AEAD_AES_128_CCM, AEAD_AES_256_GCM (all these AES AEADs are defined),
    CONTENT#1262(   in [AEAD]), and AEAD_CHACHA20_POLY1305 (defined in [CHACHA]).  Prior),
    CONTENT#1263(   to TLS selecting a cipher suite, AES header protection is used),
    CONTENT#1264(   (Section 5.4.3), matching the AEAD_AES_128_GCM packet protection.),
      BREAK#1265,
    SECTION#1266(id=5.4.2, title=Header Protection Sample),
      BREAK#1267,
    CONTENT#1268(   The header protection algorithm uses both the header protection key),
    CONTENT#1269(   and a sample of the ciphertext from the packet Payload field.),
      BREAK#1270,
    CONTENT#1271(   The same number of bytes are always sampled, but an allowance needs),
    CONTENT#1272(   to be made for the removal of protection by a receiving endpoint,),
    CONTENT#1273(   which will not know the length of the Packet Number field.  The),
    CONTENT#1274(   sample of ciphertext is taken starting from an offset of 4 bytes),
    CONTENT#1275(   after the start of the Packet Number field.  That is, in sampling),
    CONTENT#1276(   packet ciphertext for header protection, the Packet Number field is),
    CONTENT#1277(   assumed to be 4 bytes long (its maximum possible encoded length).),
      BREAK#1278,
    CONTENT#1279(   An endpoint MUST discard packets that are not long enough to contain),
    CONTENT#1280(   a complete sample.),
      BREAK#1281,
    CONTENT#1282(   To ensure that sufficient data is available for sampling, packets are),
    CONTENT#1283(   padded so that the combined lengths of the encoded packet number and),
    CONTENT#1284(   protected payload is at least 4 bytes longer than the sample required),
    CONTENT#1285(   for header protection.  The cipher suites defined in [TLS13] -- other),
    CONTENT#1286(   than TLS_AES_128_CCM_8_SHA256, for which a header protection scheme),
    CONTENT#1287(   is not defined in this document -- have 16-byte expansions and),
    CONTENT#1288(   16-byte header protection samples.  This results in needing at least),
    CONTENT#1289(   3 bytes of frames in the unprotected payload if the packet number is),
    CONTENT#1290(   encoded on a single byte, or 2 bytes of frames for a 2-byte packet),
    CONTENT#1291(   number encoding.),
      BREAK#1292,
    CONTENT#1293(   The sampled ciphertext can be determined by the following pseudocode:),
      BREAK#1294,
    CONTENT#1295(   # pn_offset is the start of the Packet Number field.),
    CONTENT#1296(   sample_offset = pn_offset + 4),
      BREAK#1297,
    CONTENT#1298(   sample = packet[sample_offset..sample_offset+sample_length]),
      BREAK#1299,
    CONTENT#1300(   Where the packet number offset of a short header packet can be),
    CONTENT#1301(   calculated as:),
      BREAK#1302,
    CONTENT#1303(   pn_offset = 1 + len(connection_id)),
      BREAK#1304,
    CONTENT#1305(   And the packet number offset of a long header packet can be),
    CONTENT#1306(   calculated as:),
      BREAK#1307,
    CONTENT#1308(   pn_offset = 7 + len(destination_connection_id) +),
    CONTENT#1309(                   len(source_connection_id) +),
    CONTENT#1310(                   len(payload_length)),
    CONTENT#1311(   if packet_type == Initial:),
    CONTENT#1312(       pn_offset += len(token_length) +),
    CONTENT#1313(                    len(token)),
      BREAK#1314,
    CONTENT#1315(   For example, for a packet with a short header, an 8-byte connection),
    CONTENT#1316(   ID, and protected with AEAD_AES_128_GCM, the sample takes bytes 13 to),
    CONTENT#1317(   28 inclusive (using zero-based indexing).),
      BREAK#1318,
    CONTENT#1319(   Multiple QUIC packets might be included in the same UDP datagram.),
    CONTENT#1320(   Each packet is handled separately.),
      BREAK#1321,
    SECTION#1322(id=5.4.3, title=AES-Based Header Protection),
      BREAK#1323,
    CONTENT#1324(   This section defines the packet protection algorithm for),
    CONTENT#1325(   AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM.),
    CONTENT#1326(   AEAD_AES_128_GCM and AEAD_AES_128_CCM use 128-bit AES in Electronic),
    CONTENT#1327(   Codebook (ECB) mode.  AEAD_AES_256_GCM uses 256-bit AES in ECB mode.),
    CONTENT#1328(   AES is defined in [AES].),
      BREAK#1329,
    CONTENT#1330(   This algorithm samples 16 bytes from the packet ciphertext.  This),
    CONTENT#1331(   value is used as the input to AES-ECB.  In pseudocode, the header),
    CONTENT#1332(   protection function is defined as:),
      BREAK#1333,
    CONTENT#1334(   header_protection(hp_key, sample):),
    CONTENT#1335(     mask = AES-ECB(hp_key, sample)),
      BREAK#1336,
    SECTION#1337(id=5.4.4, title=ChaCha20-Based Header Protection),
      BREAK#1338,
    CONTENT#1339(   When AEAD_CHACHA20_POLY1305 is in use, header protection uses the raw),
    CONTENT#1340(   ChaCha20 function as defined in Section 2.4 of [CHACHA].  This uses a),
    CONTENT#1341(   256-bit key and 16 bytes sampled from the packet protection output.),
      BREAK#1342,
    CONTENT#1343(   The first 4 bytes of the sampled ciphertext are the block counter.  A),
    CONTENT#1344(   ChaCha20 implementation could take a 32-bit integer in place of a),
    CONTENT#1345(   byte sequence, in which case, the byte sequence is interpreted as a),
    CONTENT#1346(   little-endian value.),
      BREAK#1347,
    CONTENT#1348(   The remaining 12 bytes are used as the nonce.  A ChaCha20),
    CONTENT#1349(   implementation might take an array of three 32-bit integers in place),
    CONTENT#1350(   of a byte sequence, in which case, the nonce bytes are interpreted as),
    CONTENT#1351(   a sequence of 32-bit little-endian integers.),
      BREAK#1352,
    CONTENT#1353(   The encryption mask is produced by invoking ChaCha20 to protect 5),
    CONTENT#1354(   zero bytes.  In pseudocode, the header protection function is defined),
    CONTENT#1355(   as:),
      BREAK#1356,
    CONTENT#1357(   header_protection(hp_key, sample):),
    CONTENT#1358(     counter = sample[0..3]),
    CONTENT#1359(     nonce = sample[4..15]),
    CONTENT#1360(     mask = ChaCha20(hp_key, counter, nonce, {0,0,0,0,0})),
      BREAK#1361,
    SECTION#1362(id=5.5, title=Receiving Protected Packets),
      BREAK#1363,
    CONTENT#1364(   Once an endpoint successfully receives a packet with a given packet),
    CONTENT#1365(   number, it MUST discard all packets in the same packet number space),
    CONTENT#1366(   with higher packet numbers if they cannot be successfully unprotected),
    CONTENT#1367(   with either the same key, or -- if there is a key update -- a),
    CONTENT#1368(   subsequent packet protection key; see Section 6.  Similarly, a packet),
    CONTENT#1369(   that appears to trigger a key update but cannot be unprotected),
    CONTENT#1370(   successfully MUST be discarded.),
      BREAK#1371,
    CONTENT#1372(   Failure to unprotect a packet does not necessarily indicate the),
    CONTENT#1373(   existence of a protocol error in a peer or an attack.  The truncated),
    CONTENT#1374(   packet number encoding used in QUIC can cause packet numbers to be),
    CONTENT#1375(   decoded incorrectly if they are delayed significantly.),
      BREAK#1376,
    SECTION#1377(id=5.6, title=Use of 0-RTT Keys),
      BREAK#1378,
    CONTENT#1379(   If 0-RTT keys are available (see Section 4.6.1), the lack of replay),
    CONTENT#1380(   protection means that restrictions on their use are necessary to),
    CONTENT#1381(   avoid replay attacks on the protocol.),
      BREAK#1382,
    CONTENT#1383(   Of the frames defined in [QUIC-TRANSPORT], the STREAM, RESET_STREAM,),
    CONTENT#1384(   STOP_SENDING, and CONNECTION_CLOSE frames are potentially unsafe for),
    CONTENT#1385(   use with 0-RTT as they carry application data.  Application data that),
    CONTENT#1386(   is received in 0-RTT could cause an application at the server to),
    CONTENT#1387(   process the data multiple times rather than just once.  Additional),
    CONTENT#1388(   actions taken by a server as a result of processing replayed),
    CONTENT#1389(   application data could have unwanted consequences.  A client),
    CONTENT#1390(   therefore MUST NOT use 0-RTT for application data unless specifically),
    CONTENT#1391(   requested by the application that is in use.),
      BREAK#1392,
    CONTENT#1393(   An application protocol that uses QUIC MUST include a profile that),
    CONTENT#1394(   defines acceptable use of 0-RTT; otherwise, 0-RTT can only be used to),
    CONTENT#1395(   carry QUIC frames that do not carry application data.  For example, a),
    CONTENT#1396(   profile for HTTP is described in [HTTP-REPLAY] and used for HTTP/3;),
    CONTENT#1397(   see Section 10.9 of [QUIC-HTTP].),
      BREAK#1398,
    CONTENT#1399(   Though replaying packets might result in additional connection),
    CONTENT#1400(   attempts, the effect of processing replayed frames that do not carry),
    CONTENT#1401(   application data is limited to changing the state of the affected),
    CONTENT#1402(   connection.  A TLS handshake cannot be successfully completed using),
    CONTENT#1403(   replayed packets.),
      BREAK#1404,
    CONTENT#1405(   A client MAY wish to apply additional restrictions on what data it),
    CONTENT#1406(   sends prior to the completion of the TLS handshake.),
      BREAK#1407,
    CONTENT#1408(   A client otherwise treats 0-RTT keys as equivalent to 1-RTT keys,),
    CONTENT#1409(   except that it cannot send certain frames with 0-RTT keys; see),
    CONTENT#1410(   Section 12.5 of [QUIC-TRANSPORT].),
      BREAK#1411,
    CONTENT#1412(   A client that receives an indication that its 0-RTT data has been),
    CONTENT#1413(   accepted by a server can send 0-RTT data until it receives all of the),
    CONTENT#1414(   server's handshake messages.  A client SHOULD stop sending 0-RTT data),
    CONTENT#1415(   if it receives an indication that 0-RTT data has been rejected.),
      BREAK#1416,
    CONTENT#1417(   A server MUST NOT use 0-RTT keys to protect packets; it uses 1-RTT),
    CONTENT#1418(   keys to protect acknowledgments of 0-RTT packets.  A client MUST NOT),
    CONTENT#1419(   attempt to decrypt 0-RTT packets it receives and instead MUST discard),
    CONTENT#1420(   them.),
      BREAK#1421,
    CONTENT#1422(   Once a client has installed 1-RTT keys, it MUST NOT send any more),
    CONTENT#1423(   0-RTT packets.),
      BREAK#1424,
    CONTENT#1425(      |  Note: 0-RTT data can be acknowledged by the server as it),
    CONTENT#1426(      |  receives it, but any packets containing acknowledgments of),
    CONTENT#1427(      |  0-RTT data cannot have packet protection removed by the client),
    CONTENT#1428(      |  until the TLS handshake is complete.  The 1-RTT keys necessary),
    CONTENT#1429(      |  to remove packet protection cannot be derived until the client),
    CONTENT#1430(      |  receives all server handshake messages.),
      BREAK#1431,
    SECTION#1432(id=5.7, title=Receiving Out-of-Order Protected Packets),
      BREAK#1433,
    CONTENT#1434(   Due to reordering and loss, protected packets might be received by an),
    CONTENT#1435(   endpoint before the final TLS handshake messages are received.  A),
    CONTENT#1436(   client will be unable to decrypt 1-RTT packets from the server,),
    CONTENT#1437(   whereas a server will be able to decrypt 1-RTT packets from the),
    CONTENT#1438(   client.  Endpoints in either role MUST NOT decrypt 1-RTT packets from),
    CONTENT#1439(   their peer prior to completing the handshake.),
      BREAK#1440,
    CONTENT#1441(   Even though 1-RTT keys are available to a server after receiving the),
    CONTENT#1442(   first handshake messages from a client, it is missing assurances on),
    CONTENT#1443(   the client state:),
      BREAK#1444,
    CONTENT#1445(   *  The client is not authenticated, unless the server has chosen to),
    CONTENT#1446(      use a pre-shared key and validated the client's pre-shared key),
    CONTENT#1447(      binder; see Section 4.2.11 of [TLS13].),
      BREAK#1448,
    CONTENT#1449(   *  The client has not demonstrated liveness, unless the server has),
    CONTENT#1450(      validated the client's address with a Retry packet or other means;),
    CONTENT#1451(      see Section 8.1 of [QUIC-TRANSPORT].),
      BREAK#1452,
    CONTENT#1453(   *  Any received 0-RTT data that the server responds to might be due),
    CONTENT#1454(      to a replay attack.),
      BREAK#1455,
    CONTENT#1456(   Therefore, the server's use of 1-RTT keys before the handshake is),
    CONTENT#1457(   complete is limited to sending data.  A server MUST NOT process),
    CONTENT#1458(   incoming 1-RTT protected packets before the TLS handshake is),
    CONTENT#1459(   complete.  Because sending acknowledgments indicates that all frames),
    CONTENT#1460(   in a packet have been processed, a server cannot send acknowledgments),
    CONTENT#1461(   for 1-RTT packets until the TLS handshake is complete.  Received),
    CONTENT#1462(   packets protected with 1-RTT keys MAY be stored and later decrypted),
    CONTENT#1463(   and used once the handshake is complete.),
      BREAK#1464,
    CONTENT#1465(      |  Note: TLS implementations might provide all 1-RTT secrets prior),
    CONTENT#1466(      |  to handshake completion.  Even where QUIC implementations have),
    CONTENT#1467(      |  1-RTT read keys, those keys are not to be used prior to),
    CONTENT#1468(      |  completing the handshake.),
      BREAK#1469,
    CONTENT#1470(   The requirement for the server to wait for the client Finished),
    CONTENT#1471(   message creates a dependency on that message being delivered.  A),
    CONTENT#1472(   client can avoid the potential for head-of-line blocking that this),
    CONTENT#1473(   implies by sending its 1-RTT packets coalesced with a Handshake),
    CONTENT#1474(   packet containing a copy of the CRYPTO frame that carries the),
    CONTENT#1475(   Finished message, until one of the Handshake packets is acknowledged.),
    CONTENT#1476(   This enables immediate server processing for those packets.),
      BREAK#1477,
    CONTENT#1478(   A server could receive packets protected with 0-RTT keys prior to),
    CONTENT#1479(   receiving a TLS ClientHello.  The server MAY retain these packets for),
    CONTENT#1480(   later decryption in anticipation of receiving a ClientHello.),
      BREAK#1481,
    CONTENT#1482(   A client generally receives 1-RTT keys at the same time as the),
    CONTENT#1483(   handshake completes.  Even if it has 1-RTT secrets, a client MUST NOT),
    CONTENT#1484(   process incoming 1-RTT protected packets before the TLS handshake is),
    CONTENT#1485(   complete.),
      BREAK#1486,
    SECTION#1487(id=5.8, title=Retry Packet Integrity),
      BREAK#1488,
    CONTENT#1489(   Retry packets (see Section 17.2.5 of [QUIC-TRANSPORT]) carry a Retry),
    CONTENT#1490(   Integrity Tag that provides two properties: it allows the discarding),
    CONTENT#1491(   of packets that have accidentally been corrupted by the network, and),
    CONTENT#1492(   only an entity that observes an Initial packet can send a valid Retry),
    CONTENT#1493(   packet.),
      BREAK#1494,
    CONTENT#1495(   The Retry Integrity Tag is a 128-bit field that is computed as the),
    CONTENT#1496(   output of AEAD_AES_128_GCM [AEAD] used with the following inputs:),
      BREAK#1497,
    CONTENT#1498(   *  The secret key, K, is 128 bits equal to),
    CONTENT#1499(      0xbe0c690b9f66575a1d766b54e368c84e.),
      BREAK#1500,
    CONTENT#1501(   *  The nonce, N, is 96 bits equal to 0x461599d35d632bf2239825bb.),
      BREAK#1502,
    CONTENT#1503(   *  The plaintext, P, is empty.),
      BREAK#1504,
    CONTENT#1505(   *  The associated data, A, is the contents of the Retry Pseudo-),
    CONTENT#1506(      Packet, as illustrated in Figure 8:),
      BREAK#1507,
    CONTENT#1508(   The secret key and the nonce are values derived by calling HKDF-),
    CONTENT#1509(   Expand-Label using),
    CONTENT#1510(   0xd9c9943e6101fd200021506bcc02814c73030f25c79d71ce876eca876e6fca8e as),
    CONTENT#1511(   the secret, with labels being "quic key" and "quic iv" (Section 5.1).),
      BREAK#1512,
    CONTENT#1513(   Retry Pseudo-Packet {),
    CONTENT#1514(     ODCID Length (8),),
    CONTENT#1515(     Original Destination Connection ID (0..160),),
    CONTENT#1516(     Header Form (1) = 1,),
    CONTENT#1517(     Fixed Bit (1) = 1,),
    CONTENT#1518(     Long Packet Type (2) = 3,),
    CONTENT#1519(     Unused (4),),
    CONTENT#1520(     Version (32),),
    CONTENT#1521(     DCID Len (8),),
    CONTENT#1522(     Destination Connection ID (0..160),),
    CONTENT#1523(     SCID Len (8),),
    CONTENT#1524(     Source Connection ID (0..160),),
    CONTENT#1525(     Retry Token (..),),
    CONTENT#1526(   }),
      BREAK#1527,
    CONTENT#1528(                       Figure 8: Retry Pseudo-Packet),
      BREAK#1529,
    CONTENT#1530(   The Retry Pseudo-Packet is not sent over the wire.  It is computed by),
    CONTENT#1531(   taking the transmitted Retry packet, removing the Retry Integrity),
    CONTENT#1532(   Tag, and prepending the two following fields:),
      BREAK#1533,
    CONTENT#1534(   ODCID Length:  The ODCID Length field contains the length in bytes of),
    CONTENT#1535(      the Original Destination Connection ID field that follows it,),
    CONTENT#1536(      encoded as an 8-bit unsigned integer.),
      BREAK#1537,
    CONTENT#1538(   Original Destination Connection ID:  The Original Destination),
    CONTENT#1539(      Connection ID contains the value of the Destination Connection ID),
    CONTENT#1540(      from the Initial packet that this Retry is in response to.  The),
    CONTENT#1541(      length of this field is given in ODCID Length.  The presence of),
    CONTENT#1542(      this field ensures that a valid Retry packet can only be sent by),
    CONTENT#1543(      an entity that observes the Initial packet.),
      BREAK#1544,
    SECTION#1545(id=6, title=Key Update),
      BREAK#1546,
    CONTENT#1547(   Once the handshake is confirmed (see Section 4.1.2), an endpoint MAY),
    CONTENT#1548(   initiate a key update.),
      BREAK#1549,
    CONTENT#1550(   The Key Phase bit indicates which packet protection keys are used to),
    CONTENT#1551(   protect the packet.  The Key Phase bit is initially set to 0 for the),
    CONTENT#1552(   first set of 1-RTT packets and toggled to signal each subsequent key),
    CONTENT#1553(   update.),
      BREAK#1554,
    CONTENT#1555(   The Key Phase bit allows a recipient to detect a change in keying),
    CONTENT#1556(   material without needing to receive the first packet that triggered),
    CONTENT#1557(   the change.  An endpoint that notices a changed Key Phase bit updates),
    CONTENT#1558(   keys and decrypts the packet that contains the changed value.),
      BREAK#1559,
    CONTENT#1560(   Initiating a key update results in both endpoints updating keys.),
    CONTENT#1561(   This differs from TLS where endpoints can update keys independently.),
      BREAK#1562,
    CONTENT#1563(   This mechanism replaces the key update mechanism of TLS, which relies),
    CONTENT#1564(   on KeyUpdate messages sent using 1-RTT encryption keys.  Endpoints),
    CONTENT#1565(   MUST NOT send a TLS KeyUpdate message.  Endpoints MUST treat the),
    CONTENT#1566(   receipt of a TLS KeyUpdate message as a connection error of type),
    CONTENT#1567(   0x010a, equivalent to a fatal TLS alert of unexpected_message; see),
    CONTENT#1568(   Section 4.8.),
      BREAK#1569,
    CONTENT#1570(   Figure 9 shows a key update process, where the initial set of keys),
    CONTENT#1571(   used (identified with @M) are replaced by updated keys (identified),
    CONTENT#1572(   with @N).  The value of the Key Phase bit is indicated in brackets),
    CONTENT#1573(   [].),
      BREAK#1574,
    CONTENT#1575(      Initiating Peer                    Responding Peer),
      BREAK#1576,
    CONTENT#1577(   @M [0] QUIC Packets),
      BREAK#1578,
    CONTENT#1579(   ... Update to @N),
    CONTENT#1580(   @N [1] QUIC Packets),
    CONTENT#1581(                         -------->),
    CONTENT#1582(                                            Update to @N ...),
    CONTENT#1583(                                         QUIC Packets [1] @N),
    CONTENT#1584(                         <--------),
    CONTENT#1585(                                         QUIC Packets [1] @N),
    CONTENT#1586(                                       containing ACK),
    CONTENT#1587(                         <--------),
    CONTENT#1588(   ... Key Update Permitted),
      BREAK#1589,
    CONTENT#1590(   @N [1] QUIC Packets),
    CONTENT#1591(            containing ACK for @N packets),
    CONTENT#1592(                         -------->),
    CONTENT#1593(                                    Key Update Permitted ...),
      BREAK#1594,
    CONTENT#1595(                            Figure 9: Key Update),
      BREAK#1596,
    SECTION#1597(id=6.1, title=Initiating a Key Update),
      BREAK#1598,
    CONTENT#1599(   Endpoints maintain separate read and write secrets for packet),
    CONTENT#1600(   protection.  An endpoint initiates a key update by updating its),
    CONTENT#1601(   packet protection write secret and using that to protect new packets.),
    CONTENT#1602(   The endpoint creates a new write secret from the existing write),
    CONTENT#1603(   secret as performed in Section 7.2 of [TLS13].  This uses the KDF),
    CONTENT#1604(   function provided by TLS with a label of "quic ku".  The),
    CONTENT#1605(   corresponding key and IV are created from that secret as defined in),
    CONTENT#1606(   Section 5.1.  The header protection key is not updated.),
      BREAK#1607,
    CONTENT#1608(   For example, to update write keys with TLS 1.3, HKDF-Expand-Label is),
    CONTENT#1609(   used as:),
      BREAK#1610,
    CONTENT#1611(   secret_<n+1> = HKDF-Expand-Label(secret_<n>, "quic ku",),
    CONTENT#1612(                                    "", Hash.length)),
      BREAK#1613,
    CONTENT#1614(   The endpoint toggles the value of the Key Phase bit and uses the),
    CONTENT#1615(   updated key and IV to protect all subsequent packets.),
      BREAK#1616,
    CONTENT#1617(   An endpoint MUST NOT initiate a key update prior to having confirmed),
    CONTENT#1618(   the handshake (Section 4.1.2).  An endpoint MUST NOT initiate a),
    CONTENT#1619(   subsequent key update unless it has received an acknowledgment for a),
    CONTENT#1620(   packet that was sent protected with keys from the current key phase.),
    CONTENT#1621(   This ensures that keys are available to both peers before another key),
    CONTENT#1622(   update can be initiated.  This can be implemented by tracking the),
    CONTENT#1623(   lowest packet number sent with each key phase and the highest),
    CONTENT#1624(   acknowledged packet number in the 1-RTT space: once the latter is),
    CONTENT#1625(   higher than or equal to the former, another key update can be),
    CONTENT#1626(   initiated.),
      BREAK#1627,
    CONTENT#1628(      |  Note: Keys of packets other than the 1-RTT packets are never),
    CONTENT#1629(      |  updated; their keys are derived solely from the TLS handshake),
    CONTENT#1630(      |  state.),
      BREAK#1631,
    CONTENT#1632(   The endpoint that initiates a key update also updates the keys that),
    CONTENT#1633(   it uses for receiving packets.  These keys will be needed to process),
    CONTENT#1634(   packets the peer sends after updating.),
      BREAK#1635,
    CONTENT#1636(   An endpoint MUST retain old keys until it has successfully),
    CONTENT#1637(   unprotected a packet sent using the new keys.  An endpoint SHOULD),
    CONTENT#1638(   retain old keys for some time after unprotecting a packet sent using),
    CONTENT#1639(   the new keys.  Discarding old keys too early can cause delayed),
    CONTENT#1640(   packets to be discarded.  Discarding packets will be interpreted as),
    CONTENT#1641(   packet loss by the peer and could adversely affect performance.),
      BREAK#1642,
    SECTION#1643(id=6.2, title=Responding to a Key Update),
      BREAK#1644,
    CONTENT#1645(   A peer is permitted to initiate a key update after receiving an),
    CONTENT#1646(   acknowledgment of a packet in the current key phase.  An endpoint),
    CONTENT#1647(   detects a key update when processing a packet with a key phase that),
    CONTENT#1648(   differs from the value used to protect the last packet it sent.  To),
    CONTENT#1649(   process this packet, the endpoint uses the next packet protection key),
    CONTENT#1650(   and IV.  See Section 6.3 for considerations about generating these),
    CONTENT#1651(   keys.),
      BREAK#1652,
    CONTENT#1653(   If a packet is successfully processed using the next key and IV, then),
    CONTENT#1654(   the peer has initiated a key update.  The endpoint MUST update its),
    CONTENT#1655(   send keys to the corresponding key phase in response, as described in),
    CONTENT#1656(   Section 6.1.  Sending keys MUST be updated before sending an),
    CONTENT#1657(   acknowledgment for the packet that was received with updated keys.),
    CONTENT#1658(   By acknowledging the packet that triggered the key update in a packet),
    CONTENT#1659(   protected with the updated keys, the endpoint signals that the key),
    CONTENT#1660(   update is complete.),
      BREAK#1661,
    CONTENT#1662(   An endpoint can defer sending the packet or acknowledgment according),
    CONTENT#1663(   to its normal packet sending behavior; it is not necessary to),
    CONTENT#1664(   immediately generate a packet in response to a key update.  The next),
    CONTENT#1665(   packet sent by the endpoint will use the updated keys.  The next),
    CONTENT#1666(   packet that contains an acknowledgment will cause the key update to),
    CONTENT#1667(   be completed.  If an endpoint detects a second update before it has),
    CONTENT#1668(   sent any packets with updated keys containing an acknowledgment for),
    CONTENT#1669(   the packet that initiated the key update, it indicates that its peer),
    CONTENT#1670(   has updated keys twice without awaiting confirmation.  An endpoint),
    CONTENT#1671(   MAY treat such consecutive key updates as a connection error of type),
    CONTENT#1672(   KEY_UPDATE_ERROR.),
      BREAK#1673,
    CONTENT#1674(   An endpoint that receives an acknowledgment that is carried in a),
    CONTENT#1675(   packet protected with old keys where any acknowledged packet was),
    CONTENT#1676(   protected with newer keys MAY treat that as a connection error of),
    CONTENT#1677(   type KEY_UPDATE_ERROR.  This indicates that a peer has received and),
    CONTENT#1678(   acknowledged a packet that initiates a key update, but has not),
    CONTENT#1679(   updated keys in response.),
      BREAK#1680,
    SECTION#1681(id=6.3, title=Timing of Receive Key Generation),
      BREAK#1682,
    CONTENT#1683(   Endpoints responding to an apparent key update MUST NOT generate a),
    CONTENT#1684(   timing side-channel signal that might indicate that the Key Phase bit),
    CONTENT#1685(   was invalid (see Section 9.5).  Endpoints can use randomized packet),
    CONTENT#1686(   protection keys in place of discarded keys when key updates are not),
    CONTENT#1687(   yet permitted.  Using randomized keys ensures that attempting to),
    CONTENT#1688(   remove packet protection does not result in timing variations, and),
    CONTENT#1689(   results in packets with an invalid Key Phase bit being rejected.),
      BREAK#1690,
    CONTENT#1691(   The process of creating new packet protection keys for receiving),
    CONTENT#1692(   packets could reveal that a key update has occurred.  An endpoint MAY),
    CONTENT#1693(   generate new keys as part of packet processing, but this creates a),
    CONTENT#1694(   timing signal that could be used by an attacker to learn when key),
    CONTENT#1695(   updates happen and thus leak the value of the Key Phase bit.),
      BREAK#1696,
    CONTENT#1697(   Endpoints are generally expected to have current and next receive),
    CONTENT#1698(   packet protection keys available.  For a short period after a key),
    CONTENT#1699(   update completes, up to the PTO, endpoints MAY defer generation of),
    CONTENT#1700(   the next set of receive packet protection keys.  This allows),
    CONTENT#1701(   endpoints to retain only two sets of receive keys; see Section 6.5.),
      BREAK#1702,
    CONTENT#1703(   Once generated, the next set of packet protection keys SHOULD be),
    CONTENT#1704(   retained, even if the packet that was received was subsequently),
    CONTENT#1705(   discarded.  Packets containing apparent key updates are easy to),
    CONTENT#1706(   forge, and while the process of key update does not require),
    CONTENT#1707(   significant effort, triggering this process could be used by an),
    CONTENT#1708(   attacker for DoS.),
      BREAK#1709,
    CONTENT#1710(   For this reason, endpoints MUST be able to retain two sets of packet),
    CONTENT#1711(   protection keys for receiving packets: the current and the next.),
    CONTENT#1712(   Retaining the previous keys in addition to these might improve),
    CONTENT#1713(   performance, but this is not essential.),
      BREAK#1714,
    SECTION#1715(id=6.4, title=Sending with Updated Keys),
      BREAK#1716,
    CONTENT#1717(   An endpoint never sends packets that are protected with old keys.),
    CONTENT#1718(   Only the current keys are used.  Keys used for protecting packets can),
    CONTENT#1719(   be discarded immediately after switching to newer keys.),
      BREAK#1720,
    CONTENT#1721(   Packets with higher packet numbers MUST be protected with either the),
    CONTENT#1722(   same or newer packet protection keys than packets with lower packet),
    CONTENT#1723(   numbers.  An endpoint that successfully removes protection with old),
    CONTENT#1724(   keys when newer keys were used for packets with lower packet numbers),
    CONTENT#1725(   MUST treat this as a connection error of type KEY_UPDATE_ERROR.),
      BREAK#1726,
    SECTION#1727(id=6.5, title=Receiving with Different Keys),
      BREAK#1728,
    CONTENT#1729(   For receiving packets during a key update, packets protected with),
    CONTENT#1730(   older keys might arrive if they were delayed by the network.),
    CONTENT#1731(   Retaining old packet protection keys allows these packets to be),
    CONTENT#1732(   successfully processed.),
      BREAK#1733,
    CONTENT#1734(   As packets protected with keys from the next key phase use the same),
    CONTENT#1735(   Key Phase value as those protected with keys from the previous key),
    CONTENT#1736(   phase, it is necessary to distinguish between the two if packets),
    CONTENT#1737(   protected with old keys are to be processed.  This can be done using),
    CONTENT#1738(   packet numbers.  A recovered packet number that is lower than any),
    CONTENT#1739(   packet number from the current key phase uses the previous packet),
    CONTENT#1740(   protection keys; a recovered packet number that is higher than any),
    CONTENT#1741(   packet number from the current key phase requires the use of the next),
    CONTENT#1742(   packet protection keys.),
      BREAK#1743,
    CONTENT#1744(   Some care is necessary to ensure that any process for selecting),
    CONTENT#1745(   between previous, current, and next packet protection keys does not),
    CONTENT#1746(   expose a timing side channel that might reveal which keys were used),
    CONTENT#1747(   to remove packet protection.  See Section 9.5 for more information.),
      BREAK#1748,
    CONTENT#1749(   Alternatively, endpoints can retain only two sets of packet),
    CONTENT#1750(   protection keys, swapping previous for next after enough time has),
    CONTENT#1751(   passed to allow for reordering in the network.  In this case, the Key),
    CONTENT#1752(   Phase bit alone can be used to select keys.),
      BREAK#1753,
    CONTENT#1754(   An endpoint MAY allow a period of approximately the Probe Timeout),
    CONTENT#1755(   (PTO; see [QUIC-RECOVERY]) after promoting the next set of receive),
    CONTENT#1756(   keys to be current before it creates the subsequent set of packet),
    CONTENT#1757(   protection keys.  These updated keys MAY replace the previous keys at),
    CONTENT#1758(   that time.  With the caveat that PTO is a subjective measure -- that),
    CONTENT#1759(   is, a peer could have a different view of the RTT -- this time is),
    CONTENT#1760(   expected to be long enough that any reordered packets would be),
    CONTENT#1761(   declared lost by a peer even if they were acknowledged and short),
    CONTENT#1762(   enough to allow a peer to initiate further key updates.),
      BREAK#1763,
    CONTENT#1764(   Endpoints need to allow for the possibility that a peer might not be),
    CONTENT#1765(   able to decrypt packets that initiate a key update during the period),
    CONTENT#1766(   when the peer retains old keys.  Endpoints SHOULD wait three times),
    CONTENT#1767(   the PTO before initiating a key update after receiving an),
    CONTENT#1768(   acknowledgment that confirms that the previous key update was),
    CONTENT#1769(   received.  Failing to allow sufficient time could lead to packets),
    CONTENT#1770(   being discarded.),
      BREAK#1771,
    CONTENT#1772(   An endpoint SHOULD retain old read keys for no more than three times),
    CONTENT#1773(   the PTO after having received a packet protected using the new keys.),
    CONTENT#1774(   After this period, old read keys and their corresponding secrets),
    CONTENT#1775(   SHOULD be discarded.),
      BREAK#1776,
    SECTION#1777(id=6.6, title=Limits on AEAD Usage),
      BREAK#1778,
    CONTENT#1779(   This document sets usage limits for AEAD algorithms to ensure that),
    CONTENT#1780(   overuse does not give an adversary a disproportionate advantage in),
    CONTENT#1781(   attacking the confidentiality and integrity of communications when),
    CONTENT#1782(   using QUIC.),
      BREAK#1783,
    CONTENT#1784(   The usage limits defined in TLS 1.3 exist for protection against),
    CONTENT#1785(   attacks on confidentiality and apply to successful applications of),
    CONTENT#1786(   AEAD protection.  The integrity protections in authenticated),
    CONTENT#1787(   encryption also depend on limiting the number of attempts to forge),
    CONTENT#1788(   packets.  TLS achieves this by closing connections after any record),
    CONTENT#1789(   fails an authentication check.  In comparison, QUIC ignores any),
    CONTENT#1790(   packet that cannot be authenticated, allowing multiple forgery),
    CONTENT#1791(   attempts.),
      BREAK#1792,
    CONTENT#1793(   QUIC accounts for AEAD confidentiality and integrity limits),
    CONTENT#1794(   separately.  The confidentiality limit applies to the number of),
    CONTENT#1795(   packets encrypted with a given key.  The integrity limit applies to),
    CONTENT#1796(   the number of packets decrypted within a given connection.  Details),
    CONTENT#1797(   on enforcing these limits for each AEAD algorithm follow below.),
      BREAK#1798,
    CONTENT#1799(   Endpoints MUST count the number of encrypted packets for each set of),
    CONTENT#1800(   keys.  If the total number of encrypted packets with the same key),
    CONTENT#1801(   exceeds the confidentiality limit for the selected AEAD, the endpoint),
    CONTENT#1802(   MUST stop using those keys.  Endpoints MUST initiate a key update),
    CONTENT#1803(   before sending more protected packets than the confidentiality limit),
    CONTENT#1804(   for the selected AEAD permits.  If a key update is not possible or),
    CONTENT#1805(   integrity limits are reached, the endpoint MUST stop using the),
    CONTENT#1806(   connection and only send stateless resets in response to receiving),
    CONTENT#1807(   packets.  It is RECOMMENDED that endpoints immediately close the),
    CONTENT#1808(   connection with a connection error of type AEAD_LIMIT_REACHED before),
    CONTENT#1809(   reaching a state where key updates are not possible.),
      BREAK#1810,
    CONTENT#1811(   For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the confidentiality limit),
    CONTENT#1812(   is 2^23 encrypted packets; see Appendix B.1.  For),
    CONTENT#1813(   AEAD_CHACHA20_POLY1305, the confidentiality limit is greater than the),
    CONTENT#1814(   number of possible packets (2^62) and so can be disregarded.  For),
    CONTENT#1815(   AEAD_AES_128_CCM, the confidentiality limit is 2^21.5 encrypted),
    CONTENT#1816(   packets; see Appendix B.2.  Applying a limit reduces the probability),
    CONTENT#1817(   that an attacker can distinguish the AEAD in use from a random),
    CONTENT#1818(   permutation; see [AEBounds], [ROBUST], and [GCM-MU].),
      BREAK#1819,
    CONTENT#1820(   In addition to counting packets sent, endpoints MUST count the number),
    CONTENT#1821(   of received packets that fail authentication during the lifetime of a),
    CONTENT#1822(   connection.  If the total number of received packets that fail),
    CONTENT#1823(   authentication within the connection, across all keys, exceeds the),
    CONTENT#1824(   integrity limit for the selected AEAD, the endpoint MUST immediately),
    CONTENT#1825(   close the connection with a connection error of type),
    CONTENT#1826(   AEAD_LIMIT_REACHED and not process any more packets.),
      BREAK#1827,
    CONTENT#1828(   For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the integrity limit is),
    CONTENT#1829(   2^52 invalid packets; see Appendix B.1.  For AEAD_CHACHA20_POLY1305,),
    CONTENT#1830(   the integrity limit is 2^36 invalid packets; see [AEBounds].  For),
    CONTENT#1831(   AEAD_AES_128_CCM, the integrity limit is 2^21.5 invalid packets; see),
    CONTENT#1832(   Appendix B.2.  Applying this limit reduces the probability that an),
    CONTENT#1833(   attacker can successfully forge a packet; see [AEBounds], [ROBUST],),
    CONTENT#1834(   and [GCM-MU].),
      BREAK#1835,
    CONTENT#1836(   Endpoints that limit the size of packets MAY use higher),
    CONTENT#1837(   confidentiality and integrity limits; see Appendix B for details.),
      BREAK#1838,
    CONTENT#1839(   Future analyses and specifications MAY relax confidentiality or),
    CONTENT#1840(   integrity limits for an AEAD.),
      BREAK#1841,
    CONTENT#1842(   Any TLS cipher suite that is specified for use with QUIC MUST define),
    CONTENT#1843(   limits on the use of the associated AEAD function that preserves),
    CONTENT#1844(   margins for confidentiality and integrity.  That is, limits MUST be),
    CONTENT#1845(   specified for the number of packets that can be authenticated and for),
    CONTENT#1846(   the number of packets that can fail authentication.  Providing a),
    CONTENT#1847(   reference to any analysis upon which values are based -- and any),
    CONTENT#1848(   assumptions used in that analysis -- allows limits to be adapted to),
    CONTENT#1849(   varying usage conditions.),
      BREAK#1850,
    SECTION#1851(id=6.7, title=Key Update Error Code),
      BREAK#1852,
    CONTENT#1853(   The KEY_UPDATE_ERROR error code (0x0e) is used to signal errors),
    CONTENT#1854(   related to key updates.),
      BREAK#1855,
    SECTION#1856(id=7, title=Security of Initial Messages),
      BREAK#1857,
    CONTENT#1858(   Initial packets are not protected with a secret key, so they are),
    CONTENT#1859(   subject to potential tampering by an attacker.  QUIC provides),
    CONTENT#1860(   protection against attackers that cannot read packets but does not),
    CONTENT#1861(   attempt to provide additional protection against attacks where the),
    CONTENT#1862(   attacker can observe and inject packets.  Some forms of tampering --),
    CONTENT#1863(   such as modifying the TLS messages themselves -- are detectable, but),
    CONTENT#1864(   some -- such as modifying ACKs -- are not.),
      BREAK#1865,
    CONTENT#1866(   For example, an attacker could inject a packet containing an ACK),
    CONTENT#1867(   frame to make it appear that a packet had not been received or to),
    CONTENT#1868(   create a false impression of the state of the connection (e.g., by),
    CONTENT#1869(   modifying the ACK Delay).  Note that such a packet could cause a),
    CONTENT#1870(   legitimate packet to be dropped as a duplicate.  Implementations),
    CONTENT#1871(   SHOULD use caution in relying on any data that is contained in),
    CONTENT#1872(   Initial packets that is not otherwise authenticated.),
      BREAK#1873,
    CONTENT#1874(   It is also possible for the attacker to tamper with data that is),
    CONTENT#1875(   carried in Handshake packets, but because that sort of tampering),
    CONTENT#1876(   requires modifying TLS handshake messages, any such tampering will),
    CONTENT#1877(   cause the TLS handshake to fail.),
      BREAK#1878,
    SECTION#1879(id=8, title=QUIC-Specific Adjustments to the TLS Handshake),
      BREAK#1880,
    CONTENT#1881(   Certain aspects of the TLS handshake are different when used with),
    CONTENT#1882(   QUIC.),
      BREAK#1883,
    CONTENT#1884(   QUIC also requires additional features from TLS.  In addition to),
    CONTENT#1885(   negotiation of cryptographic parameters, the TLS handshake carries),
    CONTENT#1886(   and authenticates values for QUIC transport parameters.),
      BREAK#1887,
    SECTION#1888(id=8.1, title=Protocol Negotiation),
      BREAK#1889,
    CONTENT#1890(   QUIC requires that the cryptographic handshake provide authenticated),
    CONTENT#1891(   protocol negotiation.  TLS uses Application-Layer Protocol),
    CONTENT#1892(   Negotiation [ALPN] to select an application protocol.  Unless another),
    CONTENT#1893(   mechanism is used for agreeing on an application protocol, endpoints),
    CONTENT#1894(   MUST use ALPN for this purpose.),
      BREAK#1895,
    CONTENT#1896(   When using ALPN, endpoints MUST immediately close a connection (see),
    CONTENT#1897(   Section 10.2 of [QUIC-TRANSPORT]) with a no_application_protocol TLS),
    CONTENT#1898(   alert (QUIC error code 0x0178; see Section 4.8) if an application),
    CONTENT#1899(   protocol is not negotiated.  While [ALPN] only specifies that servers),
    CONTENT#1900(   use this alert, QUIC clients MUST use error 0x0178 to terminate a),
    CONTENT#1901(   connection when ALPN negotiation fails.),
      BREAK#1902,
    CONTENT#1903(   An application protocol MAY restrict the QUIC versions that it can),
    CONTENT#1904(   operate over.  Servers MUST select an application protocol compatible),
    CONTENT#1905(   with the QUIC version that the client has selected.  The server MUST),
    CONTENT#1906(   treat the inability to select a compatible application protocol as a),
    CONTENT#1907(   connection error of type 0x0178 (no_application_protocol).),
    CONTENT#1908(   Similarly, a client MUST treat the selection of an incompatible),
    CONTENT#1909(   application protocol by a server as a connection error of type),
    CONTENT#1910(   0x0178.),
      BREAK#1911,
    SECTION#1912(id=8.2, title=QUIC Transport Parameters Extension),
      BREAK#1913,
    CONTENT#1914(   QUIC transport parameters are carried in a TLS extension.  Different),
    CONTENT#1915(   versions of QUIC might define a different method for negotiating),
    CONTENT#1916(   transport configuration.),
      BREAK#1917,
    CONTENT#1918(   Including transport parameters in the TLS handshake provides),
    CONTENT#1919(   integrity protection for these values.),
      BREAK#1920,
    CONTENT#1921(      enum {),
    CONTENT#1922(         quic_transport_parameters(0x39), (65535)),
    CONTENT#1923(      } ExtensionType;),
      BREAK#1924,
    CONTENT#1925(   The extension_data field of the quic_transport_parameters extension),
    CONTENT#1926(   contains a value that is defined by the version of QUIC that is in),
    CONTENT#1927(   use.),
      BREAK#1928,
    CONTENT#1929(   The quic_transport_parameters extension is carried in the ClientHello),
    CONTENT#1930(   and the EncryptedExtensions messages during the handshake.  Endpoints),
    CONTENT#1931(   MUST send the quic_transport_parameters extension; endpoints that),
    CONTENT#1932(   receive ClientHello or EncryptedExtensions messages without the),
    CONTENT#1933(   quic_transport_parameters extension MUST close the connection with an),
    CONTENT#1934(   error of type 0x016d (equivalent to a fatal TLS missing_extension),
    CONTENT#1935(   alert, see Section 4.8).),
      BREAK#1936,
    CONTENT#1937(   Transport parameters become available prior to the completion of the),
    CONTENT#1938(   handshake.  A server might use these values earlier than handshake),
    CONTENT#1939(   completion.  However, the value of transport parameters is not),
    CONTENT#1940(   authenticated until the handshake completes, so any use of these),
    CONTENT#1941(   parameters cannot depend on their authenticity.  Any tampering with),
    CONTENT#1942(   transport parameters will cause the handshake to fail.),
      BREAK#1943,
    CONTENT#1944(   Endpoints MUST NOT send this extension in a TLS connection that does),
    CONTENT#1945(   not use QUIC (such as the use of TLS with TCP defined in [TLS13]).  A),
    CONTENT#1946(   fatal unsupported_extension alert MUST be sent by an implementation),
    CONTENT#1947(   that supports this extension if the extension is received when the),
    CONTENT#1948(   transport is not QUIC.),
      BREAK#1949,
    CONTENT#1950(   Negotiating the quic_transport_parameters extension causes the),
    CONTENT#1951(   EndOfEarlyData to be removed; see Section 8.3.),
      BREAK#1952,
    SECTION#1953(id=8.3, title=Removing the EndOfEarlyData Message),
      BREAK#1954,
    CONTENT#1955(   The TLS EndOfEarlyData message is not used with QUIC.  QUIC does not),
    CONTENT#1956(   rely on this message to mark the end of 0-RTT data or to signal the),
    CONTENT#1957(   change to Handshake keys.),
      BREAK#1958,
    CONTENT#1959(   Clients MUST NOT send the EndOfEarlyData message.  A server MUST),
    CONTENT#1960(   treat receipt of a CRYPTO frame in a 0-RTT packet as a connection),
    CONTENT#1961(   error of type PROTOCOL_VIOLATION.),
      BREAK#1962,
    CONTENT#1963(   As a result, EndOfEarlyData does not appear in the TLS handshake),
    CONTENT#1964(   transcript.),
      BREAK#1965,
    SECTION#1966(id=8.4, title=Prohibit TLS Middlebox Compatibility Mode),
      BREAK#1967,
    CONTENT#1968(   Appendix D.4 of [TLS13] describes an alteration to the TLS 1.3),
    CONTENT#1969(   handshake as a workaround for bugs in some middleboxes.  The TLS 1.3),
    CONTENT#1970(   middlebox compatibility mode involves setting the legacy_session_id),
    CONTENT#1971(   field to a 32-byte value in the ClientHello and ServerHello, then),
    CONTENT#1972(   sending a change_cipher_spec record.  Both field and record carry no),
    CONTENT#1973(   semantic content and are ignored.),
      BREAK#1974,
    CONTENT#1975(   This mode has no use in QUIC as it only applies to middleboxes that),
    CONTENT#1976(   interfere with TLS over TCP.  QUIC also provides no means to carry a),
    CONTENT#1977(   change_cipher_spec record.  A client MUST NOT request the use of the),
    CONTENT#1978(   TLS 1.3 compatibility mode.  A server SHOULD treat the receipt of a),
    CONTENT#1979(   TLS ClientHello with a non-empty legacy_session_id field as a),
    CONTENT#1980(   connection error of type PROTOCOL_VIOLATION.),
      BREAK#1981,
    SECTION#1982(id=9, title=Security Considerations),
      BREAK#1983,
    CONTENT#1984(   All of the security considerations that apply to TLS also apply to),
    CONTENT#1985(   the use of TLS in QUIC.  Reading all of [TLS13] and its appendices is),
    CONTENT#1986(   the best way to gain an understanding of the security properties of),
    CONTENT#1987(   QUIC.),
      BREAK#1988,
    CONTENT#1989(   This section summarizes some of the more important security aspects),
    CONTENT#1990(   specific to the TLS integration, though there are many security-),
    CONTENT#1991(   relevant details in the remainder of the document.),
      BREAK#1992,
    SECTION#1993(id=9.1, title=Session Linkability),
      BREAK#1994,
    CONTENT#1995(   Use of TLS session tickets allows servers and possibly other entities),
    CONTENT#1996(   to correlate connections made by the same client; see Section 4.5 for),
    CONTENT#1997(   details.),
      BREAK#1998,
    SECTION#1999(id=9.2, title=Replay Attacks with 0-RTT),
      BREAK#2000,
    CONTENT#2001(   As described in Section 8 of [TLS13], use of TLS early data comes),
    CONTENT#2002(   with an exposure to replay attack.  The use of 0-RTT in QUIC is),
    CONTENT#2003(   similarly vulnerable to replay attack.),
      BREAK#2004,
    CONTENT#2005(   Endpoints MUST implement and use the replay protections described in),
    CONTENT#2006(   [TLS13], however it is recognized that these protections are),
    CONTENT#2007(   imperfect.  Therefore, additional consideration of the risk of replay),
    CONTENT#2008(   is needed.),
      BREAK#2009,
    CONTENT#2010(   QUIC is not vulnerable to replay attack, except via the application),
    CONTENT#2011(   protocol information it might carry.  The management of QUIC protocol),
    CONTENT#2012(   state based on the frame types defined in [QUIC-TRANSPORT] is not),
    CONTENT#2013(   vulnerable to replay.  Processing of QUIC frames is idempotent and),
    CONTENT#2014(   cannot result in invalid connection states if frames are replayed,),
    CONTENT#2015(   reordered, or lost.  QUIC connections do not produce effects that),
    CONTENT#2016(   last beyond the lifetime of the connection, except for those produced),
    CONTENT#2017(   by the application protocol that QUIC serves.),
      BREAK#2018,
    CONTENT#2019(   TLS session tickets and address validation tokens are used to carry),
    CONTENT#2020(   QUIC configuration information between connections, specifically, to),
    CONTENT#2021(   enable a server to efficiently recover state that is used in),
    CONTENT#2022(   connection establishment and address validation.  These MUST NOT be),
    CONTENT#2023(   used to communicate application semantics between endpoints; clients),
    CONTENT#2024(   MUST treat them as opaque values.  The potential for reuse of these),
    CONTENT#2025(   tokens means that they require stronger protections against replay.),
      BREAK#2026,
    CONTENT#2027(   A server that accepts 0-RTT on a connection incurs a higher cost than),
    CONTENT#2028(   accepting a connection without 0-RTT.  This includes higher),
    CONTENT#2029(   processing and computation costs.  Servers need to consider the),
    CONTENT#2030(   probability of replay and all associated costs when accepting 0-RTT.),
      BREAK#2031,
    CONTENT#2032(   Ultimately, the responsibility for managing the risks of replay),
    CONTENT#2033(   attacks with 0-RTT lies with an application protocol.  An application),
    CONTENT#2034(   protocol that uses QUIC MUST describe how the protocol uses 0-RTT and),
    CONTENT#2035(   the measures that are employed to protect against replay attack.  An),
    CONTENT#2036(   analysis of replay risk needs to consider all QUIC protocol features),
    CONTENT#2037(   that carry application semantics.),
      BREAK#2038,
    CONTENT#2039(   Disabling 0-RTT entirely is the most effective defense against replay),
    CONTENT#2040(   attack.),
      BREAK#2041,
    CONTENT#2042(   QUIC extensions MUST either describe how replay attacks affect their),
    CONTENT#2043(   operation or prohibit the use of the extension in 0-RTT.  Application),
    CONTENT#2044(   protocols MUST either prohibit the use of extensions that carry),
    CONTENT#2045(   application semantics in 0-RTT or provide replay mitigation),
    CONTENT#2046(   strategies.),
      BREAK#2047,
    SECTION#2048(id=9.3, title=Packet Reflection Attack Mitigation),
      BREAK#2049,
    CONTENT#2050(   A small ClientHello that results in a large block of handshake),
    CONTENT#2051(   messages from a server can be used in packet reflection attacks to),
    CONTENT#2052(   amplify the traffic generated by an attacker.),
      BREAK#2053,
    CONTENT#2054(   QUIC includes three defenses against this attack.  First, the packet),
    CONTENT#2055(   containing a ClientHello MUST be padded to a minimum size.  Second,),
    CONTENT#2056(   if responding to an unverified source address, the server is),
    CONTENT#2057(   forbidden to send more than three times as many bytes as the number),
    CONTENT#2058(   of bytes it has received (see Section 8.1 of [QUIC-TRANSPORT]).),
    CONTENT#2059(   Finally, because acknowledgments of Handshake packets are),
    CONTENT#2060(   authenticated, a blind attacker cannot forge them.  Put together,),
    CONTENT#2061(   these defenses limit the level of amplification.),
      BREAK#2062,
    SECTION#2063(id=9.4, title=Header Protection Analysis),
      BREAK#2064,
    CONTENT#2065(   [NAN] analyzes authenticated encryption algorithms that provide nonce),
    CONTENT#2066(   privacy, referred to as "Hide Nonce" (HN) transforms.  The general),
    CONTENT#2067(   header protection construction in this document is one of those),
    CONTENT#2068(   algorithms (HN1).  Header protection is applied after the packet),
    CONTENT#2069(   protection AEAD, sampling a set of bytes ("sample") from the AEAD),
    CONTENT#2070(   output and encrypting the header field using a pseudorandom function),
    CONTENT#2071(   (PRF) as follows:),
      BREAK#2072,
    CONTENT#2073(   protected_field = field XOR PRF(hp_key, sample)),
      BREAK#2074,
    CONTENT#2075(   The header protection variants in this document use a pseudorandom),
    CONTENT#2076(   permutation (PRP) in place of a generic PRF.  However, since all PRPs),
    CONTENT#2077(   are also PRFs [IMC], these variants do not deviate from the HN1),
    CONTENT#2078(   construction.),
      BREAK#2079,
    CONTENT#2080(   As "hp_key" is distinct from the packet protection key, it follows),
    CONTENT#2081(   that header protection achieves AE2 security as defined in [NAN] and),
    CONTENT#2082(   therefore guarantees privacy of "field", the protected packet header.),
    CONTENT#2083(   Future header protection variants based on this construction MUST use),
    CONTENT#2084(   a PRF to ensure equivalent security guarantees.),
      BREAK#2085,
    CONTENT#2086(   Use of the same key and ciphertext sample more than once risks),
    CONTENT#2087(   compromising header protection.  Protecting two different headers),
    CONTENT#2088(   with the same key and ciphertext sample reveals the exclusive OR of),
    CONTENT#2089(   the protected fields.  Assuming that the AEAD acts as a PRF, if L),
    CONTENT#2090(   bits are sampled, the odds of two ciphertext samples being identical),
    CONTENT#2091(   approach 2^(-L/2), that is, the birthday bound.  For the algorithms),
    CONTENT#2092(   described in this document, that probability is one in 2^64.),
      BREAK#2093,
    CONTENT#2094(   To prevent an attacker from modifying packet headers, the header is),
    CONTENT#2095(   transitively authenticated using packet protection; the entire packet),
    CONTENT#2096(   header is part of the authenticated additional data.  Protected),
    CONTENT#2097(   fields that are falsified or modified can only be detected once the),
    CONTENT#2098(   packet protection is removed.),
      BREAK#2099,
    SECTION#2100(id=9.5, title=Header Protection Timing Side Channels),
      BREAK#2101,
    CONTENT#2102(   An attacker could guess values for packet numbers or Key Phase and),
    CONTENT#2103(   have an endpoint confirm guesses through timing side channels.),
    CONTENT#2104(   Similarly, guesses for the packet number length can be tried and),
    CONTENT#2105(   exposed.  If the recipient of a packet discards packets with),
    CONTENT#2106(   duplicate packet numbers without attempting to remove packet),
    CONTENT#2107(   protection, they could reveal through timing side channels that the),
    CONTENT#2108(   packet number matches a received packet.  For authentication to be),
    CONTENT#2109(   free from side channels, the entire process of header protection),
    CONTENT#2110(   removal, packet number recovery, and packet protection removal MUST),
    CONTENT#2111(   be applied together without timing and other side channels.),
      BREAK#2112,
    CONTENT#2113(   For the sending of packets, construction and protection of packet),
    CONTENT#2114(   payloads and packet numbers MUST be free from side channels that),
    CONTENT#2115(   would reveal the packet number or its encoded size.),
      BREAK#2116,
    CONTENT#2117(   During a key update, the time taken to generate new keys could reveal),
    CONTENT#2118(   through timing side channels that a key update has occurred.),
    CONTENT#2119(   Alternatively, where an attacker injects packets, this side channel),
    CONTENT#2120(   could reveal the value of the Key Phase on injected packets.  After),
    CONTENT#2121(   receiving a key update, an endpoint SHOULD generate and save the next),
    CONTENT#2122(   set of receive packet protection keys, as described in Section 6.3.),
    CONTENT#2123(   By generating new keys before a key update is received, receipt of),
    CONTENT#2124(   packets will not create timing signals that leak the value of the Key),
    CONTENT#2125(   Phase.),
      BREAK#2126,
    CONTENT#2127(   This depends on not doing this key generation during packet),
    CONTENT#2128(   processing, and it can require that endpoints maintain three sets of),
    CONTENT#2129(   packet protection keys for receiving: for the previous key phase, for),
    CONTENT#2130(   the current key phase, and for the next key phase.  Endpoints can),
    CONTENT#2131(   instead choose to defer generation of the next receive packet),
    CONTENT#2132(   protection keys until they discard old keys so that only two sets of),
    CONTENT#2133(   receive keys need to be retained at any point in time.),
      BREAK#2134,
    SECTION#2135(id=9.6, title=Key Diversity),
      BREAK#2136,
    CONTENT#2137(   In using TLS, the central key schedule of TLS is used.  As a result),
    CONTENT#2138(   of the TLS handshake messages being integrated into the calculation),
    CONTENT#2139(   of secrets, the inclusion of the QUIC transport parameters extension),
    CONTENT#2140(   ensures that the handshake and 1-RTT keys are not the same as those),
    CONTENT#2141(   that might be produced by a server running TLS over TCP.  To avoid),
    CONTENT#2142(   the possibility of cross-protocol key synchronization, additional),
    CONTENT#2143(   measures are provided to improve key separation.),
      BREAK#2144,
    CONTENT#2145(   The QUIC packet protection keys and IVs are derived using a different),
    CONTENT#2146(   label than the equivalent keys in TLS.),
      BREAK#2147,
    CONTENT#2148(   To preserve this separation, a new version of QUIC SHOULD define new),
    CONTENT#2149(   labels for key derivation for packet protection key and IV, plus the),
    CONTENT#2150(   header protection keys.  This version of QUIC uses the string "quic".),
    CONTENT#2151(   Other versions can use a version-specific label in place of that),
    CONTENT#2152(   string.),
      BREAK#2153,
    CONTENT#2154(   The initial secrets use a key that is specific to the negotiated QUIC),
    CONTENT#2155(   version.  New QUIC versions SHOULD define a new salt value used in),
    CONTENT#2156(   calculating initial secrets.),
      BREAK#2157,
    SECTION#2158(id=9.7, title=Randomness),
      BREAK#2159,
    CONTENT#2160(   QUIC depends on endpoints being able to generate secure random),
    CONTENT#2161(   numbers, both directly for protocol values such as the connection ID,),
    CONTENT#2162(   and transitively via TLS.  See [RFC4086] for guidance on secure),
    CONTENT#2163(   random number generation.),
      BREAK#2164,
    SECTION#2165(id=10, title=IANA Considerations),
      BREAK#2166,
    CONTENT#2167(   IANA has registered a codepoint of 57 (or 0x39) for the),
    CONTENT#2168(   quic_transport_parameters extension (defined in Section 8.2) in the),
    CONTENT#2169(   "TLS ExtensionType Values" registry [TLS-REGISTRIES].),
      BREAK#2170,
    CONTENT#2171(   The Recommended column for this extension is marked Yes. The TLS 1.3),
    CONTENT#2172(   Column includes CH (ClientHello) and EE (EncryptedExtensions).),
      BREAK#2173,
    CONTENT#2174(   +=======+===========================+=====+=============+===========+),
    CONTENT#2175(   | Value | Extension Name            | TLS | Recommended | Reference |),
    CONTENT#2176(   |       |                           | 1.3 |             |           |),
    CONTENT#2177(   +=======+===========================+=====+=============+===========+),
    CONTENT#2178(   |    57 | quic_transport_parameters | CH, | Y           | This      |),
    CONTENT#2179(   |       |                           | EE  |             | document  |),
    CONTENT#2180(   +-------+---------------------------+-----+-------------+-----------+),
      BREAK#2181,
    CONTENT#2182(              Table 2: TLS ExtensionType Values Registry Entry),
      BREAK#2183,
    SECTION#2184(id=11, title=References),
      BREAK#2185,
    SECTION#2186(id=11.1, title=Normative References),
      BREAK#2187,
    CONTENT#2188(   [AEAD]     McGrew, D., "An Interface and Algorithms for Authenticated),
    CONTENT#2189(              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,),
    CONTENT#2190(              <https://www.rfc-editor.org/info/rfc5116>.),
      BREAK#2191,
    CONTENT#2192(   [AES]      "Advanced encryption standard (AES)", National Institute),
    CONTENT#2193(              of Standards and Technology report,),
    CONTENT#2194(              DOI 10.6028/nist.fips.197, November 2001,),
    CONTENT#2195(              <https://doi.org/10.6028/nist.fips.197>.),
      BREAK#2196,
    CONTENT#2197(   [ALPN]     Friedl, S., Popov, A., Langley, A., and E. Stephan,),
    CONTENT#2198(              "Transport Layer Security (TLS) Application-Layer Protocol),
    CONTENT#2199(              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,),
    CONTENT#2200(              July 2014, <https://www.rfc-editor.org/info/rfc7301>.),
      BREAK#2201,
    CONTENT#2202(   [CHACHA]   Nir, Y. and A. Langley, "ChaCha20 and Poly1305 for IETF),
    CONTENT#2203(              Protocols", RFC 8439, DOI 10.17487/RFC8439, June 2018,),
    CONTENT#2204(              <https://www.rfc-editor.org/info/rfc8439>.),
      BREAK#2205,
    CONTENT#2206(   [HKDF]     Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand),
    CONTENT#2207(              Key Derivation Function (HKDF)", RFC 5869,),
    CONTENT#2208(              DOI 10.17487/RFC5869, May 2010,),
    CONTENT#2209(              <https://www.rfc-editor.org/info/rfc5869>.),
      BREAK#2210,
    CONTENT#2211(   [QUIC-RECOVERY]),
    CONTENT#2212(              Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection),
    CONTENT#2213(              and Congestion Control", RFC 9002, DOI 10.17487/RFC9002,),
    CONTENT#2214(              May 2021, <https://www.rfc-editor.org/info/rfc9002>.),
      BREAK#2215,
    CONTENT#2216(   [QUIC-TRANSPORT]),
    CONTENT#2217(              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based),
    CONTENT#2218(              Multiplexed and Secure Transport", RFC 9000,),
    CONTENT#2219(              DOI 10.17487/RFC9000, May 2021,),
    CONTENT#2220(              <https://www.rfc-editor.org/info/rfc9000>.),
      BREAK#2221,
    CONTENT#2222(   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate),
    CONTENT#2223(              Requirement Levels", BCP 14, RFC 2119,),
    CONTENT#2224(              DOI 10.17487/RFC2119, March 1997,),
    CONTENT#2225(              <https://www.rfc-editor.org/info/rfc2119>.),
      BREAK#2226,
    CONTENT#2227(   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,),
    CONTENT#2228(              "Randomness Requirements for Security", BCP 106, RFC 4086,),
    CONTENT#2229(              DOI 10.17487/RFC4086, June 2005,),
    CONTENT#2230(              <https://www.rfc-editor.org/info/rfc4086>.),
      BREAK#2231,
    CONTENT#2232(   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC),
    CONTENT#2233(              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,),
    CONTENT#2234(              May 2017, <https://www.rfc-editor.org/info/rfc8174>.),
      BREAK#2235,
    CONTENT#2236(   [SHA]      Dang, Q., "Secure Hash Standard", National Institute of),
    CONTENT#2237(              Standards and Technology report,),
    CONTENT#2238(              DOI 10.6028/nist.fips.180-4, July 2015,),
    CONTENT#2239(              <https://doi.org/10.6028/nist.fips.180-4>.),
      BREAK#2240,
    CONTENT#2241(   [TLS-REGISTRIES]),
    CONTENT#2242(              Salowey, J. and S. Turner, "IANA Registry Updates for TLS),
    CONTENT#2243(              and DTLS", RFC 8447, DOI 10.17487/RFC8447, August 2018,),
    CONTENT#2244(              <https://www.rfc-editor.org/info/rfc8447>.),
      BREAK#2245,
    CONTENT#2246(   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol),
    CONTENT#2247(              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,),
    CONTENT#2248(              <https://www.rfc-editor.org/info/rfc8446>.),
      BREAK#2249,
    SECTION#2250(id=11.2, title=Informative References),
      BREAK#2251,
    CONTENT#2252(   [AEBounds] Luykx, A. and K. Paterson, "Limits on Authenticated),
    CONTENT#2253(              Encryption Use in TLS", 28 August 2017,),
    CONTENT#2254(              <https://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.),
      BREAK#2255,
    CONTENT#2256(   [ASCII]    Cerf, V., "ASCII format for network interchange", STD 80,),
    CONTENT#2257(              RFC 20, DOI 10.17487/RFC0020, October 1969,),
    CONTENT#2258(              <https://www.rfc-editor.org/info/rfc20>.),
      BREAK#2259,
    CONTENT#2260(   [CCM-ANALYSIS]),
    CONTENT#2261(              Jonsson, J., "On the Security of CTR + CBC-MAC", Selected),
    CONTENT#2262(              Areas in Cryptography, SAC 2002, Lecture Notes in Computer),
    CONTENT#2263(              Science, vol 2595, pp. 76-93, DOI 10.1007/3-540-36492-7_7,),
    CONTENT#2264(              2003, <https://doi.org/10.1007/3-540-36492-7_7>.),
      BREAK#2265,
    CONTENT#2266(   [COMPRESS] Ghedini, A. and V. Vasiliev, "TLS Certificate),
    CONTENT#2267(              Compression", RFC 8879, DOI 10.17487/RFC8879, December),
    CONTENT#2268(              2020, <https://www.rfc-editor.org/info/rfc8879>.),
      BREAK#2269,
    CONTENT#2270(   [GCM-MU]   Hoang, V., Tessaro, S., and A. Thiruvengadam, "The Multi-),
    CONTENT#2271(              user Security of GCM, Revisited: Tight Bounds for Nonce),
    CONTENT#2272(              Randomization", CCS '18: Proceedings of the 2018 ACM),
    CONTENT#2273(              SIGSAC Conference on Computer and Communications Security,),
    CONTENT#2274(              pp. 1429-1440, DOI 10.1145/3243734.3243816, 2018,),
    CONTENT#2275(              <https://doi.org/10.1145/3243734.3243816>.),
      BREAK#2276,
    CONTENT#2277(   [HTTP-REPLAY]),
    CONTENT#2278(              Thomson, M., Nottingham, M., and W. Tarreau, "Using Early),
    CONTENT#2279(              Data in HTTP", RFC 8470, DOI 10.17487/RFC8470, September),
    CONTENT#2280(              2018, <https://www.rfc-editor.org/info/rfc8470>.),
      BREAK#2281,
    CONTENT#2282(   [HTTP2-TLS13]),
    CONTENT#2283(              Benjamin, D., "Using TLS 1.3 with HTTP/2", RFC 8740,),
    CONTENT#2284(              DOI 10.17487/RFC8740, February 2020,),
    CONTENT#2285(              <https://www.rfc-editor.org/info/rfc8740>.),
      BREAK#2286,
    CONTENT#2287(   [IMC]      Katz, J. and Y. Lindell, "Introduction to Modern),
    CONTENT#2288(              Cryptography, Second Edition", ISBN 978-1466570269, 6),
    CONTENT#2289(              November 2014.),
      BREAK#2290,
    CONTENT#2291(   [NAN]      Bellare, M., Ng, R., and B. Tackmann, "Nonces Are Noticed:),
    CONTENT#2292(              AEAD Revisited", Advances in Cryptology - CRYPTO 2019,),
    CONTENT#2293(              Lecture Notes in Computer Science, vol 11692, pp. 235-265,),
    CONTENT#2294(              DOI 10.1007/978-3-030-26948-7_9, 2019,),
    CONTENT#2295(              <https://doi.org/10.1007/978-3-030-26948-7_9>.),
      BREAK#2296,
    CONTENT#2297(   [QUIC-HTTP]),
    CONTENT#2298(              Bishop, M., Ed., "Hypertext Transfer Protocol Version 3),
    CONTENT#2299(              (HTTP/3)", Work in Progress, Internet-Draft, draft-ietf-),
    CONTENT#2300(              quic-http-34, 2 February 2021,),
    CONTENT#2301(              <https://tools.ietf.org/html/draft-ietf-quic-http-34>.),
      BREAK#2302,
    CONTENT#2303(   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,),
    CONTENT#2304(              DOI 10.17487/RFC2818, May 2000,),
    CONTENT#2305(              <https://www.rfc-editor.org/info/rfc2818>.),
      BREAK#2306,
    CONTENT#2307(   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,),
    CONTENT#2308(              Housley, R., and W. Polk, "Internet X.509 Public Key),
    CONTENT#2309(              Infrastructure Certificate and Certificate Revocation List),
    CONTENT#2310(              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,),
    CONTENT#2311(              <https://www.rfc-editor.org/info/rfc5280>.),
      BREAK#2312,
    CONTENT#2313(   [ROBUST]   Fischlin, M., Günther, F., and C. Janson, "Robust),
    CONTENT#2314(              Channels: Handling Unreliable Networks in the Record),
    CONTENT#2315(              Layers of QUIC and DTLS 1.3", 16 May 2020,),
    CONTENT#2316(              <https://eprint.iacr.org/2020/718>.),
      BREAK#2317,
    SECTION#2318(id=A, title=Sample Packet Protection),
      BREAK#2319,
    CONTENT#2320(   This section shows examples of packet protection so that),
    CONTENT#2321(   implementations can be verified incrementally.  Samples of Initial),
    CONTENT#2322(   packets from both client and server plus a Retry packet are defined.),
    CONTENT#2323(   These packets use an 8-byte client-chosen Destination Connection ID),
    CONTENT#2324(   of 0x8394c8f03e515708.  Some intermediate values are included.  All),
    CONTENT#2325(   values are shown in hexadecimal.),
      BREAK#2326,
    SECTION#2327(id=A.1, title=Keys),
      BREAK#2328,
    CONTENT#2329(   The labels generated during the execution of the HKDF-Expand-Label),
    CONTENT#2330(   function (that is, HkdfLabel.label) and part of the value given to),
    CONTENT#2331(   the HKDF-Expand function in order to produce its output are:),
      BREAK#2332,
    CONTENT#2333(   client in:  00200f746c73313320636c69656e7420696e00),
      BREAK#2334,
    CONTENT#2335(   server in:  00200f746c7331332073657276657220696e00),
      BREAK#2336,
    CONTENT#2337(   quic key:  00100e746c7331332071756963206b657900),
      BREAK#2338,
    CONTENT#2339(   quic iv:  000c0d746c733133207175696320697600),
      BREAK#2340,
    CONTENT#2341(   quic hp:  00100d746c733133207175696320687000),
      BREAK#2342,
    CONTENT#2343(   The initial secret is common:),
      BREAK#2344,
    CONTENT#2345(   initial_secret = HKDF-Extract(initial_salt, cid)),
    CONTENT#2346(       = 7db5df06e7a69e432496adedb0085192),
    CONTENT#2347(         3595221596ae2ae9fb8115c1e9ed0a44),
      BREAK#2348,
    CONTENT#2349(   The secrets for protecting client packets are:),
      BREAK#2350,
    CONTENT#2351(   client_initial_secret),
    CONTENT#2352(       = HKDF-Expand-Label(initial_secret, "client in", "", 32)),
    CONTENT#2353(       = c00cf151ca5be075ed0ebfb5c80323c4),
    CONTENT#2354(         2d6b7db67881289af4008f1f6c357aea),
      BREAK#2355,
    CONTENT#2356(   key = HKDF-Expand-Label(client_initial_secret, "quic key", "", 16)),
    CONTENT#2357(       = 1f369613dd76d5467730efcbe3b1a22d),
      BREAK#2358,
    CONTENT#2359(   iv  = HKDF-Expand-Label(client_initial_secret, "quic iv", "", 12)),
    CONTENT#2360(       = fa044b2f42a3fd3b46fb255c),
      BREAK#2361,
    CONTENT#2362(   hp  = HKDF-Expand-Label(client_initial_secret, "quic hp", "", 16)),
    CONTENT#2363(       = 9f50449e04a0e810283a1e9933adedd2),
      BREAK#2364,
    CONTENT#2365(   The secrets for protecting server packets are:),
      BREAK#2366,
    CONTENT#2367(   server_initial_secret),
    CONTENT#2368(       = HKDF-Expand-Label(initial_secret, "server in", "", 32)),
    CONTENT#2369(       = 3c199828fd139efd216c155ad844cc81),
    CONTENT#2370(         fb82fa8d7446fa7d78be803acdda951b),
      BREAK#2371,
    CONTENT#2372(   key = HKDF-Expand-Label(server_initial_secret, "quic key", "", 16)),
    CONTENT#2373(       = cf3a5331653c364c88f0f379b6067e37),
      BREAK#2374,
    CONTENT#2375(   iv  = HKDF-Expand-Label(server_initial_secret, "quic iv", "", 12)),
    CONTENT#2376(       = 0ac1493ca1905853b0bba03e),
      BREAK#2377,
    CONTENT#2378(   hp  = HKDF-Expand-Label(server_initial_secret, "quic hp", "", 16)),
    CONTENT#2379(       = c206b8d9b9f0f37644430b490eeaa314),
      BREAK#2380,
    SECTION#2381(id=A.2, title=Client Initial),
      BREAK#2382,
    CONTENT#2383(   The client sends an Initial packet.  The unprotected payload of this),
    CONTENT#2384(   packet contains the following CRYPTO frame, plus enough PADDING),
    CONTENT#2385(   frames to make a 1162-byte payload:),
      BREAK#2386,
    CONTENT#2387(   060040f1010000ed0303ebf8fa56f129 39b9584a3896472ec40bb863cfd3e868),
    CONTENT#2388(   04fe3a47f06a2b69484c000004130113 02010000c000000010000e00000b6578),
    CONTENT#2389(   616d706c652e636f6dff01000100000a 00080006001d00170018001000070005),
    CONTENT#2390(   04616c706e0005000501000000000033 00260024001d00209370b2c9caa47fba),
    CONTENT#2391(   baf4559fedba753de171fa71f50f1ce1 5d43e994ec74d748002b000302030400),
    CONTENT#2392(   0d0010000e0403050306030203080408 050806002d00020101001c0002400100),
    CONTENT#2393(   3900320408ffffffffffffffff050480 00ffff07048000ffff08011001048000),
    CONTENT#2394(   75300901100f088394c8f03e51570806 048000ffff),
      BREAK#2395,
    CONTENT#2396(   The unprotected header indicates a length of 1182 bytes: the 4-byte),
    CONTENT#2397(   packet number, 1162 bytes of frames, and the 16-byte authentication),
    CONTENT#2398(   tag.  The header includes the connection ID and a packet number of 2:),
      BREAK#2399,
    CONTENT#2400(   c300000001088394c8f03e5157080000449e00000002),
      BREAK#2401,
    CONTENT#2402(   Protecting the payload produces output that is sampled for header),
    CONTENT#2403(   protection.  Because the header uses a 4-byte packet number encoding,),
    CONTENT#2404(   the first 16 bytes of the protected payload is sampled and then),
    CONTENT#2405(   applied to the header as follows:),
      BREAK#2406,
    CONTENT#2407(   sample = d1b1c98dd7689fb8ec11d242b123dc9b),
      BREAK#2408,
    CONTENT#2409(   mask = AES-ECB(hp, sample)[0..4]),
    CONTENT#2410(        = 437b9aec36),
      BREAK#2411,
    CONTENT#2412(   header[0] ^= mask[0] & 0x0f),
    CONTENT#2413(        = c0),
    CONTENT#2414(   header[18..21] ^= mask[1..4]),
    CONTENT#2415(        = 7b9aec34),
    CONTENT#2416(   header = c000000001088394c8f03e5157080000449e7b9aec34),
      BREAK#2417,
    CONTENT#2418(   The resulting protected packet is:),
      BREAK#2419,
    CONTENT#2420(   c000000001088394c8f03e5157080000 449e7b9aec34d1b1c98dd7689fb8ec11),
    CONTENT#2421(   d242b123dc9bd8bab936b47d92ec356c 0bab7df5976d27cd449f63300099f399),
    CONTENT#2422(   1c260ec4c60d17b31f8429157bb35a12 82a643a8d2262cad67500cadb8e7378c),
    CONTENT#2423(   8eb7539ec4d4905fed1bee1fc8aafba1 7c750e2c7ace01e6005f80fcb7df6212),
    CONTENT#2424(   30c83711b39343fa028cea7f7fb5ff89 eac2308249a02252155e2347b63d58c5),
    CONTENT#2425(   457afd84d05dfffdb20392844ae81215 4682e9cf012f9021a6f0be17ddd0c208),
    CONTENT#2426(   4dce25ff9b06cde535d0f920a2db1bf3 62c23e596d11a4f5a6cf3948838a3aec),
    CONTENT#2427(   4e15daf8500a6ef69ec4e3feb6b1d98e 610ac8b7ec3faf6ad760b7bad1db4ba3),
    CONTENT#2428(   485e8a94dc250ae3fdb41ed15fb6a8e5 eba0fc3dd60bc8e30c5c4287e53805db),
    CONTENT#2429(   059ae0648db2f64264ed5e39be2e20d8 2df566da8dd5998ccabdae053060ae6c),
    CONTENT#2430(   7b4378e846d29f37ed7b4ea9ec5d82e7 961b7f25a9323851f681d582363aa5f8),
    CONTENT#2431(   9937f5a67258bf63ad6f1a0b1d96dbd4 faddfcefc5266ba6611722395c906556),
    CONTENT#2432(   be52afe3f565636ad1b17d508b73d874 3eeb524be22b3dcbc2c7468d54119c74),
    CONTENT#2433(   68449a13d8e3b95811a198f3491de3e7 fe942b330407abf82a4ed7c1b311663a),
    CONTENT#2434(   c69890f4157015853d91e923037c227a 33cdd5ec281ca3f79c44546b9d90ca00),
    CONTENT#2435(   f064c99e3dd97911d39fe9c5d0b23a22 9a234cb36186c4819e8b9c5927726632),
    CONTENT#2436(   291d6a418211cc2962e20fe47feb3edf 330f2c603a9d48c0fcb5699dbfe58964),
    CONTENT#2437(   25c5bac4aee82e57a85aaf4e2513e4f0 5796b07ba2ee47d80506f8d2c25e50fd),
    CONTENT#2438(   14de71e6c418559302f939b0e1abd576 f279c4b2e0feb85c1f28ff18f58891ff),
    CONTENT#2439(   ef132eef2fa09346aee33c28eb130ff2 8f5b766953334113211996d20011a198),
    CONTENT#2440(   e3fc433f9f2541010ae17c1bf202580f 6047472fb36857fe843b19f5984009dd),
    CONTENT#2441(   c324044e847a4f4a0ab34f719595de37 252d6235365e9b84392b061085349d73),
    CONTENT#2442(   203a4a13e96f5432ec0fd4a1ee65accd d5e3904df54c1da510b0ff20dcc0c77f),
    CONTENT#2443(   cb2c0e0eb605cb0504db87632cf3d8b4 dae6e705769d1de354270123cb11450e),
    CONTENT#2444(   fc60ac47683d7b8d0f811365565fd98c 4c8eb936bcab8d069fc33bd801b03ade),
    CONTENT#2445(   a2e1fbc5aa463d08ca19896d2bf59a07 1b851e6c239052172f296bfb5e724047),
    CONTENT#2446(   90a2181014f3b94a4e97d117b4381303 68cc39dbb2d198065ae3986547926cd2),
    CONTENT#2447(   162f40a29f0c3c8745c0f50fba3852e5 66d44575c29d39a03f0cda721984b6f4),
    CONTENT#2448(   40591f355e12d439ff150aab7613499d bd49adabc8676eef023b15b65bfc5ca0),
    CONTENT#2449(   6948109f23f350db82123535eb8a7433 bdabcb909271a6ecbcb58b936a88cd4e),
    CONTENT#2450(   8f2e6ff5800175f113253d8fa9ca8885 c2f552e657dc603f252e1a8e308f76f0),
    CONTENT#2451(   be79e2fb8f5d5fbbe2e30ecadd220723 c8c0aea8078cdfcb3868263ff8f09400),
    CONTENT#2452(   54da48781893a7e49ad5aff4af300cd8 04a6b6279ab3ff3afb64491c85194aab),
    CONTENT#2453(   760d58a606654f9f4400e8b38591356f bf6425aca26dc85244259ff2b19c41b9),
    CONTENT#2454(   f96f3ca9ec1dde434da7d2d392b905dd f3d1f9af93d1af5950bd493f5aa731b4),
    CONTENT#2455(   056df31bd267b6b90a079831aaf579be 0a39013137aac6d404f518cfd4684064),
    CONTENT#2456(   7e78bfe706ca4cf5e9c5453e9f7cfd2b 8b4c8d169a44e55c88d4a9a7f9474241),
    CONTENT#2457(   e221af44860018ab0856972e194cd934),
      BREAK#2458,
    SECTION#2459(id=A.3, title=Server Initial),
      BREAK#2460,
    CONTENT#2461(   The server sends the following payload in response, including an ACK),
    CONTENT#2462(   frame, a CRYPTO frame, and no PADDING frames:),
      BREAK#2463,
    CONTENT#2464(   02000000000600405a020000560303ee fce7f7b37ba1d1632e96677825ddf739),
    CONTENT#2465(   88cfc79825df566dc5430b9a045a1200 130100002e00330024001d00209d3c94),
    CONTENT#2466(   0d89690b84d08a60993c144eca684d10 81287c834d5311bcf32bb9da1a002b00),
    CONTENT#2467(   020304),
      BREAK#2468,
    CONTENT#2469(   The header from the server includes a new connection ID and a 2-byte),
    CONTENT#2470(   packet number encoding for a packet number of 1:),
      BREAK#2471,
    CONTENT#2472(   c1000000010008f067a5502a4262b50040750001),
      BREAK#2473,
    CONTENT#2474(   As a result, after protection, the header protection sample is taken),
    CONTENT#2475(   starting from the third protected byte:),
      BREAK#2476,
    CONTENT#2477(   sample = 2cd0991cd25b0aac406a5816b6394100),
    CONTENT#2478(   mask   = 2ec0d8356a),
    CONTENT#2479(   header = cf000000010008f067a5502a4262b5004075c0d9),
      BREAK#2480,
    CONTENT#2481(   The final protected packet is then:),
      BREAK#2482,
    CONTENT#2483(   cf000000010008f067a5502a4262b500 4075c0d95a482cd0991cd25b0aac406a),
    CONTENT#2484(   5816b6394100f37a1c69797554780bb3 8cc5a99f5ede4cf73c3ec2493a1839b3),
    CONTENT#2485(   dbcba3f6ea46c5b7684df3548e7ddeb9 c3bf9c73cc3f3bded74b562bfb19fb84),
    CONTENT#2486(   022f8ef4cdd93795d77d06edbb7aaf2f 58891850abbdca3d20398c276456cbc4),
    CONTENT#2487(   2158407dd074ee),
      BREAK#2488,
    SECTION#2489(id=A.4, title=Retry),
      BREAK#2490,
    CONTENT#2491(   This shows a Retry packet that might be sent in response to the),
    CONTENT#2492(   Initial packet in Appendix A.2.  The integrity check includes the),
    CONTENT#2493(   client-chosen connection ID value of 0x8394c8f03e515708, but that),
    CONTENT#2494(   value is not included in the final Retry packet:),
      BREAK#2495,
    CONTENT#2496(   ff000000010008f067a5502a4262b574 6f6b656e04a265ba2eff4d829058fb3f),
    CONTENT#2497(   0f2496ba),
      BREAK#2498,
    SECTION#2499(id=A.5, title=ChaCha20-Poly1305 Short Header Packet),
      BREAK#2500,
    CONTENT#2501(   This example shows some of the steps required to protect a packet),
    CONTENT#2502(   with a short header.  This example uses AEAD_CHACHA20_POLY1305.),
      BREAK#2503,
    CONTENT#2504(   In this example, TLS produces an application write secret from which),
    CONTENT#2505(   a server uses HKDF-Expand-Label to produce four values: a key, an IV,),
    CONTENT#2506(   a header protection key, and the secret that will be used after keys),
    CONTENT#2507(   are updated (this last value is not used further in this example).),
      BREAK#2508,
    CONTENT#2509(   secret),
    CONTENT#2510(       = 9ac312a7f877468ebe69422748ad00a1),
    CONTENT#2511(         5443f18203a07d6060f688f30f21632b),
      BREAK#2512,
    CONTENT#2513(   key = HKDF-Expand-Label(secret, "quic key", "", 32)),
    CONTENT#2514(       = c6d98ff3441c3fe1b2182094f69caa2e),
    CONTENT#2515(         d4b716b65488960a7a984979fb23e1c8),
      BREAK#2516,
    CONTENT#2517(   iv  = HKDF-Expand-Label(secret, "quic iv", "", 12)),
    CONTENT#2518(       = e0459b3474bdd0e44a41c144),
      BREAK#2519,
    CONTENT#2520(   hp  = HKDF-Expand-Label(secret, "quic hp", "", 32)),
    CONTENT#2521(       = 25a282b9e82f06f21f488917a4fc8f1b),
    CONTENT#2522(         73573685608597d0efcb076b0ab7a7a4),
      BREAK#2523,
    CONTENT#2524(   ku  = HKDF-Expand-Label(secret, "quic ku", "", 32)),
    CONTENT#2525(       = 1223504755036d556342ee9361d25342),
    CONTENT#2526(         1a826c9ecdf3c7148684b36b714881f9),
      BREAK#2527,
    CONTENT#2528(   The following shows the steps involved in protecting a minimal packet),
    CONTENT#2529(   with an empty Destination Connection ID.  This packet contains a),
    CONTENT#2530(   single PING frame (that is, a payload of just 0x01) and has a packet),
    CONTENT#2531(   number of 654360564.  In this example, using a packet number of),
    CONTENT#2532(   length 3 (that is, 49140 is encoded) avoids having to pad the payload),
    CONTENT#2533(   of the packet; PADDING frames would be needed if the packet number is),
    CONTENT#2534(   encoded on fewer bytes.),
      BREAK#2535,
    CONTENT#2536(   pn                 = 654360564 (decimal)),
    CONTENT#2537(   nonce              = e0459b3474bdd0e46d417eb0),
    CONTENT#2538(   unprotected header = 4200bff4),
    CONTENT#2539(   payload plaintext  = 01),
    CONTENT#2540(   payload ciphertext = 655e5cd55c41f69080575d7999c25a5bfb),
      BREAK#2541,
    CONTENT#2542(   The resulting ciphertext is the minimum size possible.  One byte is),
    CONTENT#2543(   skipped to produce the sample for header protection.),
      BREAK#2544,
    CONTENT#2545(   sample = 5e5cd55c41f69080575d7999c25a5bfb),
    CONTENT#2546(   mask   = aefefe7d03),
    CONTENT#2547(   header = 4cfe4189),
      BREAK#2548,
    CONTENT#2549(   The protected packet is the smallest possible packet size of 21),
    CONTENT#2550(   bytes.),
      BREAK#2551,
    CONTENT#2552(   packet = 4cfe4189655e5cd55c41f69080575d7999c25a5bfb),
      BREAK#2553,
    SECTION#2554(id=B, title=AEAD Algorithm Analysis),
      BREAK#2555,
    CONTENT#2556(   This section documents analyses used in deriving AEAD algorithm),
    CONTENT#2557(   limits for AEAD_AES_128_GCM, AEAD_AES_128_CCM, and AEAD_AES_256_GCM.),
    CONTENT#2558(   The analyses that follow use symbols for multiplication (*), division),
    CONTENT#2559(   (/), and exponentiation (^), plus parentheses for establishing),
    CONTENT#2560(   precedence.  The following symbols are also used:),
      BREAK#2561,
    CONTENT#2562(   t:  The size of the authentication tag in bits.  For these ciphers, t),
    CONTENT#2563(      is 128.),
      BREAK#2564,
    CONTENT#2565(   n:  The size of the block function in bits.  For these ciphers, n is),
    CONTENT#2566(      128.),
      BREAK#2567,
    CONTENT#2568(   k:  The size of the key in bits.  This is 128 for AEAD_AES_128_GCM),
    CONTENT#2569(      and AEAD_AES_128_CCM; 256 for AEAD_AES_256_GCM.),
      BREAK#2570,
    CONTENT#2571(   l:  The number of blocks in each packet (see below).),
      BREAK#2572,
    CONTENT#2573(   q:  The number of genuine packets created and protected by endpoints.),
    CONTENT#2574(      This value is the bound on the number of packets that can be),
    CONTENT#2575(      protected before updating keys.),
      BREAK#2576,
    CONTENT#2577(   v:  The number of forged packets that endpoints will accept.  This),
    CONTENT#2578(      value is the bound on the number of forged packets that an),
    CONTENT#2579(      endpoint can reject before updating keys.),
      BREAK#2580,
    CONTENT#2581(   o:  The amount of offline ideal cipher queries made by an adversary.),
      BREAK#2582,
    CONTENT#2583(   The analyses that follow rely on a count of the number of block),
    CONTENT#2584(   operations involved in producing each message.  This analysis is),
    CONTENT#2585(   performed for packets of size up to 2^11 (l = 2^7) and 2^16 (l =),
    CONTENT#2586(   2^12).  A size of 2^11 is expected to be a limit that matches common),
    CONTENT#2587(   deployment patterns, whereas the 2^16 is the maximum possible size of),
    CONTENT#2588(   a QUIC packet.  Only endpoints that strictly limit packet size can),
    CONTENT#2589(   use the larger confidentiality and integrity limits that are derived),
    CONTENT#2590(   using the smaller packet size.),
      BREAK#2591,
    CONTENT#2592(   For AEAD_AES_128_GCM and AEAD_AES_256_GCM, the message length (l) is),
    CONTENT#2593(   the length of the associated data in blocks plus the length of the),
    CONTENT#2594(   plaintext in blocks.),
      BREAK#2595,
    CONTENT#2596(   For AEAD_AES_128_CCM, the total number of block cipher operations is),
    CONTENT#2597(   the sum of the following: the length of the associated data in),
    CONTENT#2598(   blocks, the length of the ciphertext in blocks, the length of the),
    CONTENT#2599(   plaintext in blocks, plus 1.  In this analysis, this is simplified to),
    CONTENT#2600(   a value of twice the length of the packet in blocks (that is, "2l =),
    CONTENT#2601(   2^8" for packets that are limited to 2^11 bytes, or "2l = 2^13"),
    CONTENT#2602(   otherwise).  This simplification is based on the packet containing),
    CONTENT#2603(   all of the associated data and ciphertext.  This results in a one to),
    CONTENT#2604(   three block overestimation of the number of operations per packet.),
      BREAK#2605,
    SECTION#2606(id=B.1, title=Analysis of AEAD_AES_128_GCM and AEAD_AES_256_GCM Usage Limits),
      BREAK#2607,
    CONTENT#2608(   [GCM-MU] specifies concrete bounds for AEAD_AES_128_GCM and),
    CONTENT#2609(   AEAD_AES_256_GCM as used in TLS 1.3 and QUIC.  This section documents),
    CONTENT#2610(   this analysis using several simplifying assumptions:),
      BREAK#2611,
    CONTENT#2612(   *  The number of ciphertext blocks an attacker uses in forgery),
    CONTENT#2613(      attempts is bounded by v * l, which is the number of forgery),
    CONTENT#2614(      attempts multiplied by the size of each packet (in blocks).),
      BREAK#2615,
    CONTENT#2616(   *  The amount of offline work done by an attacker does not dominate),
    CONTENT#2617(      other factors in the analysis.),
      BREAK#2618,
    CONTENT#2619(   The bounds in [GCM-MU] are tighter and more complete than those used),
    CONTENT#2620(   in [AEBounds], which allows for larger limits than those described in),
    CONTENT#2621(   [TLS13].),
      BREAK#2622,
    SECTION#2623(id=B.1.1, title=Confidentiality Limit),
      BREAK#2624,
    CONTENT#2625(   For confidentiality, Theorem (4.3) in [GCM-MU] establishes that, for),
    CONTENT#2626(   a single user that does not repeat nonces, the dominant term in),
    CONTENT#2627(   determining the distinguishing advantage between a real and random),
    CONTENT#2628(   AEAD algorithm gained by an attacker is:),
      BREAK#2629,
    CONTENT#2630(   2 * (q * l)^2 / 2^n),
      BREAK#2631,
    CONTENT#2632(   For a target advantage of 2^-57, this results in the relation:),
      BREAK#2633,
    CONTENT#2634(   q <= 2^35 / l),
      BREAK#2635,
    CONTENT#2636(   Thus, endpoints that do not send packets larger than 2^11 bytes),
    CONTENT#2637(   cannot protect more than 2^28 packets in a single connection without),
    CONTENT#2638(   causing an attacker to gain a more significant advantage than the),
    CONTENT#2639(   target of 2^-57.  The limit for endpoints that allow for the packet),
    CONTENT#2640(   size to be as large as 2^16 is instead 2^23.),
      BREAK#2641,
    SECTION#2642(id=B.1.2, title=Integrity Limit),
      BREAK#2643,
    CONTENT#2644(   For integrity, Theorem (4.3) in [GCM-MU] establishes that an attacker),
    CONTENT#2645(   gains an advantage in successfully forging a packet of no more than),
    CONTENT#2646(   the following:),
      BREAK#2647,
    CONTENT#2648(   (1 / 2^(8 * n)) + ((2 * v) / 2^(2 * n))),
    CONTENT#2649(           + ((2 * o * v) / 2^(k + n)) + (n * (v + (v * l)) / 2^k)),
      BREAK#2650,
    CONTENT#2651(   The goal is to limit this advantage to 2^-57.  For AEAD_AES_128_GCM,),
    CONTENT#2652(   the fourth term in this inequality dominates the rest, so the others),
    CONTENT#2653(   can be removed without significant effect on the result.  This),
    CONTENT#2654(   produces the following approximation:),
      BREAK#2655,
    CONTENT#2656(   v <= 2^64 / l),
      BREAK#2657,
    CONTENT#2658(   Endpoints that do not attempt to remove protection from packets),
    CONTENT#2659(   larger than 2^11 bytes can attempt to remove protection from at most),
    CONTENT#2660(   2^57 packets.  Endpoints that do not restrict the size of processed),
    CONTENT#2661(   packets can attempt to remove protection from at most 2^52 packets.),
      BREAK#2662,
    CONTENT#2663(   For AEAD_AES_256_GCM, the same term dominates, but the larger value),
    CONTENT#2664(   of k produces the following approximation:),
      BREAK#2665,
    CONTENT#2666(   v <= 2^192 / l),
      BREAK#2667,
    CONTENT#2668(   This is substantially larger than the limit for AEAD_AES_128_GCM.),
    CONTENT#2669(   However, this document recommends that the same limit be applied to),
    CONTENT#2670(   both functions as either limit is acceptably large.),
      BREAK#2671,
    SECTION#2672(id=B.2, title=Analysis of AEAD_AES_128_CCM Usage Limits),
      BREAK#2673,
    CONTENT#2674(   TLS [TLS13] and [AEBounds] do not specify limits on usage for),
    CONTENT#2675(   AEAD_AES_128_CCM.  However, any AEAD that is used with QUIC requires),
    CONTENT#2676(   limits on use that ensure that both confidentiality and integrity are),
    CONTENT#2677(   preserved.  This section documents that analysis.),
      BREAK#2678,
    CONTENT#2679(   [CCM-ANALYSIS] is used as the basis of this analysis.  The results of),
    CONTENT#2680(   that analysis are used to derive usage limits that are based on those),
    CONTENT#2681(   chosen in [TLS13].),
      BREAK#2682,
    CONTENT#2683(   For confidentiality, Theorem 2 in [CCM-ANALYSIS] establishes that an),
    CONTENT#2684(   attacker gains a distinguishing advantage over an ideal pseudorandom),
    CONTENT#2685(   permutation (PRP) of no more than the following:),
      BREAK#2686,
    CONTENT#2687(   (2l * q)^2 / 2^n),
      BREAK#2688,
    CONTENT#2689(   The integrity limit in Theorem 1 in [CCM-ANALYSIS] provides an),
    CONTENT#2690(   attacker a strictly higher advantage for the same number of messages.),
    CONTENT#2691(   As the targets for the confidentiality advantage and the integrity),
    CONTENT#2692(   advantage are the same, only Theorem 1 needs to be considered.),
      BREAK#2693,
    CONTENT#2694(   Theorem 1 establishes that an attacker gains an advantage over an),
    CONTENT#2695(   ideal PRP of no more than the following:),
      BREAK#2696,
    CONTENT#2697(   v / 2^t + (2l * (v + q))^2 / 2^n),
      BREAK#2698,
    CONTENT#2699(   As "t" and "n" are both 128, the first term is negligible relative to),
    CONTENT#2700(   the second, so that term can be removed without a significant effect),
    CONTENT#2701(   on the result.),
      BREAK#2702,
    CONTENT#2703(   This produces a relation that combines both encryption and decryption),
    CONTENT#2704(   attempts with the same limit as that produced by the theorem for),
    CONTENT#2705(   confidentiality alone.  For a target advantage of 2^-57, this results),
    CONTENT#2706(   in the following:),
      BREAK#2707,
    CONTENT#2708(   v + q <= 2^34.5 / l),
      BREAK#2709,
    CONTENT#2710(   By setting "q = v", values for both confidentiality and integrity),
    CONTENT#2711(   limits can be produced.  Endpoints that limit packets to 2^11 bytes),
    CONTENT#2712(   therefore have both confidentiality and integrity limits of 2^26.5),
    CONTENT#2713(   packets.  Endpoints that do not restrict packet size have a limit of),
    CONTENT#2714(   2^21.5.),
      BREAK#2715,
      BREAK#2717,
    CONTENT#2718(   The IETF QUIC Working Group received an enormous amount of support),
    CONTENT#2719(   from many people.  The following people provided substantive),
    CONTENT#2720(   contributions to this document:),
      BREAK#2721,
    CONTENT#2722(   *  Adam Langley),
    CONTENT#2723(   *  Alessandro Ghedini),
    CONTENT#2724(   *  Christian Huitema),
    CONTENT#2725(   *  Christopher Wood),
    CONTENT#2726(   *  David Schinazi),
    CONTENT#2727(   *  Dragana Damjanovic),
    CONTENT#2728(   *  Eric Rescorla),
    CONTENT#2729(   *  Felix Günther),
    CONTENT#2730(   *  Ian Swett),
    CONTENT#2731(   *  Jana Iyengar),
    CONTENT#2732(   *  奥 一穂 (Kazuho Oku)),
    CONTENT#2733(   *  Marten Seemann),
    CONTENT#2734(   *  Martin Duke),
    CONTENT#2735(   *  Mike Bishop),
    CONTENT#2736(   *  Mikkel Fahnøe Jørgensen),
    CONTENT#2737(   *  Nick Banks),
    CONTENT#2738(   *  Nick Harper),
    CONTENT#2739(   *  Roberto Peon),
    CONTENT#2740(   *  Rui Paulo),
    CONTENT#2741(   *  Ryan Hamilton),
    CONTENT#2742(   *  Victor Vasiliev),
      BREAK#2743,
      BREAK#2745,
    CONTENT#2746(   Martin Thomson (editor)),
    CONTENT#2747(   Mozilla),
      BREAK#2748,
    CONTENT#2749(   Email: mt@lowentropy.net),
      BREAK#2750,
      BREAK#2751,
    CONTENT#2752(   Sean Turner (editor)),
    CONTENT#2753(   sn3rd),
      BREAK#2754,
    CONTENT#2755(   Email: sean@sn3rd.com),
]
